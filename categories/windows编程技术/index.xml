<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Windows编程技术 on 倾旋的博客</title><link>https://payloads.online/categories/windows%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/</link><description>Recent content in Windows编程技术 on 倾旋的博客</description><generator>Hugo</generator><language>zh-cn</language><copyright>倾旋 All rights reserved</copyright><lastBuildDate>Wed, 02 Oct 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://payloads.online/categories/windows%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml"/><item><title>DllMain与rundll32详解</title><link>https://payloads.online/archivers/2019-10-02/1/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-10-02/1/</guid><description>&lt;h2 id="0x00-dllmain">0x00 DllMain&lt;/h2>
&lt;p>对于动态链接库，DllMain是一个&lt;strong>可选的&lt;/strong>入口函数。&lt;/p>
&lt;h3 id="程序调用dll中的导出函数的流程">程序调用DLL中的导出函数的流程&lt;/h3>
&lt;ul>
&lt;li>程序调用Windows API &lt;code>LoadLibrary&lt;/code>&lt;/li>
&lt;li>操作系统寻找LoadLibrary所加载的DLL文件&lt;/li>
&lt;li>操作系统将DLL文件加载至目标程序进程的内存空间&lt;/li>
&lt;li>程序自动调用&lt;code>DllMain&lt;/code>函数&lt;/li>
&lt;li>程序调用DLL中导出函数&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>如果DLL被多次&lt;code>LoadLibrary&lt;/code>，那么&lt;code>DllMain&lt;/code>只执行一次，引用基数+1。&lt;/strong>&lt;/p>
&lt;h3 id="dllmain的原型">DllMain的原型&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>BOOL WINAPI &lt;span style="color:#a6e22e">DllMain&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _In_ HINSTANCE hinstDLL, &lt;span style="color:#75715e">// 指向自身的句柄
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> _In_ DWORD fdwReason, &lt;span style="color:#75715e">// 调用原因
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> _In_ LPVOID lpvReserved &lt;span style="color:#75715e">// 隐式加载和显式加载
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="0x01-dllmain调用原因">0x01 DllMain调用原因&lt;/h2>
&lt;p>其中&lt;code>fdwReason&lt;/code>用来表示Dll被调用的状态，一共分为四种：&lt;/p>
&lt;ul>
&lt;li>DLL_PROCESS_ATTACH 被进程加载&lt;/li>
&lt;li>DLL_PROCESS_DETACH 被进程释放&lt;/li>
&lt;li>DLL_THREAD_ATTACH 被线程加载&lt;/li>
&lt;li>DLL_THREAD_DETACH 被线程释放&lt;/li>
&lt;/ul>
&lt;p>在DllMain中通常为了捕获DLL被调用的方式来进行某些动作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>BOOL APIENTRY &lt;span style="color:#a6e22e">DllMain&lt;/span>( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　&lt;span style="color:#66d9ef">switch&lt;/span> (ul_reason_for_call)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　　&lt;span style="color:#66d9ef">case&lt;/span> DLL_PROCESS_ATTACH:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　　　printf(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">process attach of dll&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　　　&lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　　&lt;span style="color:#66d9ef">case&lt;/span> DLL_THREAD_ATTACH:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　　　printf(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">thread attach of dll&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　　　&lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　　&lt;span style="color:#66d9ef">case&lt;/span> DLL_THREAD_DETACH:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　　　printf(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">thread detach of dll&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　　　&lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　　&lt;span style="color:#66d9ef">case&lt;/span> DLL_PROCESS_DETACH:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　　　printf(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">process detach of dll&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　　　&lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　&lt;span style="color:#66d9ef">return&lt;/span> TRUE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="0x02-那些用于测试dll劫持的dllmain-poc">0x02 那些用于测试DLL劫持的DllMain POC&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://cxsecurity.com/issue/WLB-2018090232">https://cxsecurity.com/issue/WLB-2018090232&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cxsecurity.com/issue/WLB-2015010114">https://cxsecurity.com/issue/WLB-2015010114&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>在测试很多DLL劫持的漏洞时，都喜欢用DllMain，是因为DllMain被进程加载或者释放都会自动调用运行。&lt;/p></description></item></channel></rss>