<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Windows编程技术 on 倾旋的博客</title><link>https://payloads.online/categories/windows%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/</link><description>Recent content in Windows编程技术 on 倾旋的博客</description><generator>Hugo</generator><language>zh-cn</language><copyright>倾旋 All rights reserved</copyright><lastBuildDate>Wed, 02 Oct 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://payloads.online/categories/windows%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml"/><item><title>DllMain与rundll32详解</title><link>https://payloads.online/archivers/2019-10-02/1/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-10-02/1/</guid><description>0x00 DllMain 对于动态链接库，DllMain是一个可选的入口函数。
程序调用DLL中的导出函数的流程 程序调用Windows API LoadLibrary 操作系统寻找LoadLibrary所加载的DLL文件 操作系统将DLL文件加载至目标程序进程的内存空间 程序自动调用DllMain函数 程序调用DLL中导出函数 如果DLL被多次LoadLibrary，那么DllMain只执行一次，引用基数+1。
DllMain的原型 1 2 3 4 5 BOOL WINAPI DllMain( _In_ HINSTANCE hinstDLL, // 指向自身的句柄 _In_ DWORD fdwReason, // 调用原因 _In_ LPVOID lpvReserved // 隐式加载和显式加载 ); 0x01 DllMain调用原因 其中fdwReason用来表示Dll被调用的状态，一共分为四种：
DLL_PROCESS_ATTACH 被进程加载 DLL_PROCESS_DETACH 被进程释放 DLL_THREAD_ATTACH 被线程加载 DLL_THREAD_DETACH 被线程释放 在DllMain中通常为了捕获DLL被调用的方式来进行某些动作：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: printf(&amp;#34;\nprocess attach of dll&amp;#34;); break; case DLL_THREAD_ATTACH: printf(&amp;#34;\nthread attach of dll&amp;#34;); break; case DLL_THREAD_DETACH: printf(&amp;#34;\nthread detach of dll&amp;#34;); break; case DLL_PROCESS_DETACH: printf(&amp;#34;\nprocess detach of dll&amp;#34;); break; } return TRUE; } 0x02 那些用于测试DLL劫持的DllMain POC https://cxsecurity.</description></item></channel></rss>