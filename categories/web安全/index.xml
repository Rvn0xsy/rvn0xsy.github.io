<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Web安全 on 倾旋的博客</title><link>https://payloads.online/categories/web%E5%AE%89%E5%85%A8/</link><description>Recent content in Web安全 on 倾旋的博客</description><generator>Hugo</generator><language>zh-cn</language><copyright>倾旋 All rights reserved</copyright><lastBuildDate>Sun, 04 Nov 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://payloads.online/categories/web%E5%AE%89%E5%85%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>ASP.NET 文件上传黑名单解决办法</title><link>https://payloads.online/archivers/2018-11-04/1/</link><pubDate>Sun, 04 Nov 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-11-04/1/</guid><description>ASP.NET 文件上传黑名单解决办法 来源：https://poc-server.com/blog/2018/05/22/rce-by-uploading-a-web-config/
同过上传web.config配置文件可以使得任意扩展名的文件以脚本代码运行
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;system.webServer&amp;gt; &amp;lt;handlers accessPolicy=&amp;#34;Read, Script, Write&amp;#34;&amp;gt; &amp;lt;add name=&amp;#34;web_config&amp;#34; path=&amp;#34;*.jpa&amp;#34; verb=&amp;#34;*&amp;#34; modules=&amp;#34;IsapiModule&amp;#34; scriptProcessor=&amp;#34;%windir%\system32\inetsrv\asp.dll&amp;#34; resourceType=&amp;#34;Unspecified&amp;#34; requireAccess=&amp;#34;Write&amp;#34; preCondition=&amp;#34;bitness64&amp;#34; /&amp;gt; &amp;lt;/handlers&amp;gt; &amp;lt;security&amp;gt; &amp;lt;requestFiltering&amp;gt; &amp;lt;fileExtensions&amp;gt; &amp;lt;remove fileExtension=&amp;#34;.jpa&amp;#34; /&amp;gt; &amp;lt;/fileExtensions&amp;gt; &amp;lt;hiddenSegments&amp;gt; &amp;lt;remove segment=&amp;#34;web.config&amp;#34; /&amp;gt; &amp;lt;/hiddenSegments&amp;gt; &amp;lt;/requestFiltering&amp;gt; &amp;lt;/security&amp;gt; &amp;lt;/system.webServer&amp;gt; &amp;lt;appSettings&amp;gt; &amp;lt;/appSettings&amp;gt; &amp;lt;/configuration&amp;gt; 上传完成web.config到Web目录下后，可以再上传*.jpa的扩展名文件达到执行任意代码的目的。</description></item><item><title>xssValidator</title><link>https://payloads.online/archivers/2018-10-19/1/</link><pubDate>Fri, 19 Oct 2018 00:00:44 +0000</pubDate><guid>https://payloads.online/archivers/2018-10-19/1/</guid><description>0x00 前言 xss Validator是一个Burp商店的一个高分插件，该插件依赖于phantomjs项目以及Burp的Intruder模块。
0x01 安装 安装插件 打开Burp，点击“Extender”-&amp;gt;“BApp Store”-&amp;gt;&amp;ldquo;XSS Validator&amp;rdquo;-&amp;gt;“install”
安装phantomjs 下载页面：http://phantomjs.org/download.html
可根据自己的操作系统类型，选择对应的版本，我这里是Mac OSX
然后下载xss.js，将它放入phantomjs的执行目录。
0x02 测试之前的步骤 1 2 3 4 5 rvn0xsy@Rvn0xsy ~/G/p/bin&amp;gt; pwd /Users/rvn0xsy/GitProject/phantomjs-2.1.1-macosx/bin rvn0xsy@Rvn0xsy ~/G/p/bin&amp;gt; ls phantomjs xss.js rvn0xsy@Rvn0xsy ~/G/p/bin&amp;gt; ./phantomjs xss.js # 启动监听 这时回到Burp的xss Validator插件页面：
其中：
Grep Phrase是XSS执行成功后，能够解析出的字符串，支持自定义。 Javascript function是验证函数，会被解析的时候调用。 Javascript event handlers是监听事件。 Payloads是测试XSS的模板，必须包含{JAVASCRIPT}，否则无法判断状态 0x03 测试演示</description></item><item><title>CTF - 美眉的手机号</title><link>https://payloads.online/archivers/2017-11-14/1/</link><pubDate>Tue, 14 Nov 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2017-11-14/1/</guid><description>0x00 前言 十一月十一号，在北科大参加了一场CTF，也是第一次投身真正的比赛
个人感觉，CTF并不是一种学习方式，但是绝对可以考验你的技术深度，这次去北京，确实感受到了那种极客精神，不管题目难或易，都有可圈可点之处，我将他们看作一道道关卡，将自己掌握的知识不断融合，去开辟新的思路，我很享受这个过程，其中，主要做了两道比较深刻的题目，在这里拿出来与大家分享，由于当时场地不允许连接外网，不能查阅资料，更获取不到服务器上的题目源代码，我只能回忆题目中的逻辑，通过PHP将它实现，略有改动。
我自己还原的源代码可以在这里看到：https://github.com/Rvn0xsy/ctf_get_phone
0x01 题目 大概意思是拿到管理员的手机号码，这个手机号码是flag。
你能获得女神的手机号吗？ 就在这里，存在一个高危漏洞，并且使用工具是无法达到目的的，追女神还是要用真心呀！！
0x02 细节分析 我首先使用自己手中的字典进行了一轮爆破，爆破的同时去注册了两个账号。
注册需要提供：
| username | password | phone |
这时，爆破未果，既然是一个高危漏洞，概率不会依附在“弱口令”上 （安慰一下自己）。
注册的两个账号，第一个是用于正常查看，第二个放入一些让SQL语句报错的关键字，例如：“ &amp;rsquo; 、* 、) ”
但是第一个注册成功了，第二个提示phone必须是数字，这个提示信息是由客户端脚本提示的
于是我猜想会不会服务器端没有验证呢？
使用Burp提交后还是失败 :(
先不管这个，第一步就要把所有的信息搜集完毕再说。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 $(&amp;#34;#register&amp;#34;).bind(&amp;#39;click&amp;#39;,function(){ var usernameObj = $(&amp;#34;#username&amp;#34;); var passwordObj = $(&amp;#34;#password&amp;#34;); var phoneObj = $(&amp;#34;#phone&amp;#34;); var usernameVal = usernameObj.</description></item><item><title>Tomcat 开启 https支持</title><link>https://payloads.online/archivers/2017-08-21/1/</link><pubDate>Mon, 21 Aug 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2017-08-21/1/</guid><description>0x00 配置keystore 要使用ssl connector，必须先创建一个keystore。他包含了服务器中被客户端用于验证服务器的数字证书。一旦客户端接受了这个证书，客户端就可以使用public key去加密他们要发送的数据。而服务器，拥有一个private key，作为唯一解密数据的密钥。
进入JDK环境的bin目录，调用keytool来完成我们的证书生成：
keytool -genkey -alias tomcat -keyalg RSA
-genkey:创建一个public-private key pair -alias tomcat：用户别名为tomcat -keyalg RSA： 使用RSA算法。 MD5算法也是被支持的，但是建议使用RSA获得更好的兼容。 生成证书后，此证书会被保存在当前用户主目录下。
0x01 修改配置文件 找到tomcat目录下的conf/server.xml，将原来的Connector 更改一下即可。
1 2 3 4 5 6 7 8 9 &amp;lt;!-- &amp;lt;Connector port=&amp;#34;8443&amp;#34; protocol=&amp;#34;HTTP/1.1&amp;#34; SSLEnabled=&amp;#34;true&amp;#34; maxThreads=&amp;#34;150&amp;#34; scheme=&amp;#34;https&amp;#34; secure=&amp;#34;true&amp;#34; clientAuth=&amp;#34;false&amp;#34; sslProtocol=&amp;#34;TLS&amp;#34; /&amp;gt; --&amp;gt; 改成：
1 2 3 4 5 &amp;lt;Connector port=&amp;#34;端口&amp;#34; protocol=&amp;#34;org.apache.coyote.http11.Http11Protocol&amp;#34; maxThreads=&amp;#34;150&amp;#34; SSLEnabled=&amp;#34;true&amp;#34; scheme=&amp;#34;https&amp;#34; secure=&amp;#34;true&amp;#34; clientAuth=&amp;#34;false&amp;#34; sslProtocol=&amp;#34;TLS&amp;#34; keystoreFile=&amp;#34;keystore文件路径&amp;#34; keystorePass=&amp;#34;口令&amp;#34; /&amp;gt; 重启tomcat后生效~</description></item></channel></rss>