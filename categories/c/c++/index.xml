<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C/C++ on 倾旋的博客</title><link>https://payloads.online/categories/c/c++/</link><description>Recent content in C/C++ on 倾旋的博客</description><generator>Hugo</generator><language>zh-cn</language><copyright>倾旋 All rights reserved</copyright><lastBuildDate>Thu, 20 Dec 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://payloads.online/categories/c/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>Windows - 线程同步</title><link>https://payloads.online/archivers/2018-12-20/Windows-CriticalSection/</link><pubDate>Thu, 20 Dec 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-12-20/Windows-CriticalSection/</guid><description>0x00 线程基础 每个线程的堆栈空间不同，在多线程执行时，可以互不干扰的运行，但是全局变量保存在全局区，当多个线程读写全局变量时，由于读写操作不是原子的，会发生程序错乱。
为什么不是原子？ 当自增、自减时，需要两行汇编指令，而CPU线程调度的最小单位是一行汇编指令，所以当某个值自增时，操作就不是原子的。
为了保证多线程读写全局变量达到同步，可以使用临界区技术，Windows正是实现了这个技术，提供了对应的API。
0x01 令牌线程同步 代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // ConsoleApplication2.cpp : 定义控制台应用程序的入口点。 // #include &amp;#34;stdafx.h&amp;#34; #include &amp;lt;iostream&amp;gt; #include &amp;lt;Windows.h&amp;gt; DWORD num = 100; CRITICAL_SECTION cs; DWORD WINAPI ThreadPro1() { EnterCriticalSection(&amp;amp;cs); while (num &amp;gt; 0) { std::wcout &amp;lt;&amp;lt; &amp;#34;Thread num :&amp;#34; &amp;lt;&amp;lt; num &amp;lt;&amp;lt; &amp;#34; Thread ID :&amp;#34; &amp;lt;&amp;lt; GetCurrentThreadId() &amp;lt;&amp;lt; std::endl; num--; } LeaveCriticalSection(&amp;amp;cs); return 10; } DWORD WINAPI ThreadPro2() { EnterCriticalSection(&amp;amp;cs); while (num &amp;gt; 0) { std::wcout &amp;lt;&amp;lt; &amp;#34;Thread num :&amp;#34; &amp;lt;&amp;lt; num &amp;lt;&amp;lt; &amp;#34; Thread ID :&amp;#34; &amp;lt;&amp;lt; GetCurrentThreadId() &amp;lt;&amp;lt; std::endl; num--; } LeaveCriticalSection(&amp;amp;cs); return 10; } int _tmain() { HANDLE hThread[2]; InitializeCriticalSection(&amp;amp;cs); hThread[0] = CreateThread(NULL, 0,(PTHREAD_START_ROUTINE) ThreadPro1, NULL, 0, NULL); hThread[1] = CreateThread(NULL, 0, (PTHREAD_START_ROUTINE)ThreadPro2, NULL, 0, NULL); WaitForMultipleObjects(2, hThread, TRUE,INFINITE); std::wprintf(TEXT(&amp;#34;Success .</description></item></channel></rss>