<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++/C on 倾旋的博客</title><link>https://payloads.online/categories/c++/c/</link><description>Recent content in C++/C on 倾旋的博客</description><generator>Hugo</generator><language>zh-cn</language><copyright>倾旋 All rights reserved</copyright><lastBuildDate>Fri, 21 Dec 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://payloads.online/categories/c++/c/index.xml" rel="self" type="application/rss+xml"/><item><title>Windows - 内存管理</title><link>https://payloads.online/archivers/2018-12-21/1/</link><pubDate>Fri, 21 Dec 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-12-21/1/</guid><description>&lt;h2 id="0x00-windows-heap"&gt;0x00 Windows Heap&lt;/h2&gt;
&lt;p&gt;每个线程都有自己的堆栈，堆用于在内存中存储未知大小的数据，由堆管理器管理，而栈用于保存函数执行状态，存储局部变量。&lt;/p&gt;
&lt;h2 id="0x01-申请堆空间的步骤---heap-api"&gt;0x01 申请堆空间的步骤 - Heap API&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HeapCreate // 创建堆句柄（内核对象）&lt;/li&gt;
&lt;li&gt;GetProcessHeap // 获取一个堆句柄&lt;/li&gt;
&lt;li&gt;GetProcessHeaps // 获取所有堆句柄&lt;/li&gt;
&lt;li&gt;HeapAlloc // 申请堆空间&lt;/li&gt;
&lt;li&gt;HeapReAlloc // 在HeapAlloc的基础上申请一块堆空间&lt;/li&gt;
&lt;li&gt;HeapFree // 释放堆空间&lt;/li&gt;
&lt;li&gt;HeapDestory // 销毁堆句柄&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="0x02-heapcreate-example"&gt;0x02 HeapCreate Example&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// ConsoleApplication2.cpp : 定义控制台应用程序的入口点。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// 堆管理
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#include&lt;/span&gt; &lt;span style="color:#75715e"&gt;&amp;#34;stdafx.h&amp;#34;&lt;/span&gt;&lt;span style="color:#75715e"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#include&lt;/span&gt; &lt;span style="color:#75715e"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style="color:#75715e"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#include&lt;/span&gt; &lt;span style="color:#75715e"&gt;&amp;lt;Windows.h&amp;gt;&lt;/span&gt;&lt;span style="color:#75715e"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;VOID &lt;span style="color:#a6e22e"&gt;P&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;wchar_t&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; contents) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	std&lt;span style="color:#f92672"&gt;::&lt;/span&gt;&lt;span style="color:#a6e22e"&gt;wprintf&lt;/span&gt;(contents);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#a6e22e"&gt;system&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#a6e22e"&gt;exit&lt;/span&gt;(&lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;_tmain&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#75715e"&gt;// 堆管理
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#75715e"&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	# 创建堆
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	HANDLE HeapCreate(
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	 DWORD flOptions,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	 SIZE_T dwInitialSize,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	 SIZE_T dwMaximumSize
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	flOptions: 1.HEAP_CREATE_ENABLE_EXECUTE 代码允许执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;			 2.HEAP_GENERATE_EXCEPTIONS 如果分配内存失败，会产生异常
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;			 3.HEAP_NO_SERIALIZE 不进行连续存取
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	dwInitialSize: 堆的初始化大小，如果为0，则系统会自动分配一个大小。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	dwMaximumSize: 堆的最大值，如果为0，将是一个可增长的堆，可以达到系统能够分配的最大值。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	HANDLE hHeap &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;HeapCreate&lt;/span&gt;(HEAP_CREATE_ENABLE_EXECUTE, &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (hHeap &lt;span style="color:#f92672"&gt;==&lt;/span&gt; NULL) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;		&lt;span style="color:#a6e22e"&gt;P&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;TEXT&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;Error HeapCreate() ...&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;\n&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#34;&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#75715e"&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	# 获取堆句柄
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	HANDLE GetProcessHeap();
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	函数返回堆句柄，如果返回值为NULL，获取堆失败
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	HANDLE hHeapRand &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;GetProcessHeap&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (hHeapRand &lt;span style="color:#f92672"&gt;==&lt;/span&gt; NULL) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;		&lt;span style="color:#a6e22e"&gt;P&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;TEXT&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;GetProcessHeap() : No Heap ...&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;\n&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#34;&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#75715e"&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	# 获取堆句柄
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	DWORD GetProcessHeaps(
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	 DWORD NumberOfHeaps, // 输入参数，要获取的句柄数量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	 PHANDLE ProcessHeaps // 输出参数，句柄数组，用于保存多个句柄
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	函数返回堆句柄，如果返回值为NULL，获取堆失败
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	CONST DWORD dwHeapMax &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1024&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	HANDLE hHeapsNum[dwHeapMax];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	DWORD dwHeapNum &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;GetProcessHeaps&lt;/span&gt;(dwHeapMax, hHeapsNum);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	std&lt;span style="color:#f92672"&gt;::&lt;/span&gt;wcout &lt;span style="color:#f92672"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style="color:#e6db74"&gt;&amp;#34;Heap number : &amp;#34;&lt;/span&gt; &lt;span style="color:#f92672"&gt;&amp;lt;&amp;lt;&lt;/span&gt; dwHeapNum &lt;span style="color:#f92672"&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style="color:#f92672"&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#75715e"&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	# 为堆分配内存
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	DECLSPEC_ALLOCATOR LPVOID HeapAlloc(
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;		HANDLE hHeap, // 堆句柄
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;		DWORD dwFlags,// 内存分配标志
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;		SIZE_T dwBytes // 分配大小（字节为单位）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	dwFlags: 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;		HEAP_GENERATE_EXCEPTIONS -&amp;gt; 抛出异常
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;		HEAP_NO_SERIALIZE -&amp;gt; 不连续存储
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;		HEAP_ZERO_MEMORY -&amp;gt; 将内存块全部清零
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	LPTSTR tAlloc &lt;span style="color:#f92672"&gt;=&lt;/span&gt; (LPTSTR)&lt;span style="color:#a6e22e"&gt;HeapAlloc&lt;/span&gt;(hHeapRand, HEAP_ZERO_MEMORY, &lt;span style="color:#ae81ff"&gt;1000&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#75715e"&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	# 在已分配的基础上继续分配
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	DECLSPEC_ALLOCATOR LPVOID HeapReAlloc(
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	 HANDLE hHeap, // 堆句柄
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	 DWORD dwFlags, // 内存分配标志
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	 _Frees_ptr_opt_ LPVOID lpMem, // 分配内存后的位置
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	 SIZE_T dwBytes // 分配大小（字节为单位）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;	*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#a6e22e"&gt;HeapReAlloc&lt;/span&gt;(hHeapRand, HEAP_ZERO_MEMORY&lt;span style="color:#f92672"&gt;|&lt;/span&gt; HEAP_REALLOC_IN_PLACE_ONLY, (LPVOID)tAlloc,&lt;span style="color:#ae81ff"&gt;24&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#a6e22e"&gt;lstrcpy&lt;/span&gt;((LPTSTR)tAlloc, &lt;span style="color:#a6e22e"&gt;TEXT&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;HEllo&amp;#34;&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	DWORD dwHeapSize &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;HeapSize&lt;/span&gt;(hHeapRand, HEAP_NO_SERIALIZE, tAlloc);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	std&lt;span style="color:#f92672"&gt;::&lt;/span&gt;wcout &lt;span style="color:#f92672"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style="color:#e6db74"&gt;&amp;#34;HeapSize : &amp;#34;&lt;/span&gt; &lt;span style="color:#f92672"&gt;&amp;lt;&amp;lt;&lt;/span&gt; dwHeapSize &lt;span style="color:#f92672"&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style="color:#f92672"&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#a6e22e"&gt;HeapFree&lt;/span&gt;(hHeapRand, HEAP_NO_SERIALIZE, tAlloc);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#a6e22e"&gt;HeapDestroy&lt;/span&gt;(hHeapRand);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	std&lt;span style="color:#f92672"&gt;::&lt;/span&gt;&lt;span style="color:#a6e22e"&gt;wprintf&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;TEXT&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;Success ... &lt;/span&gt;&lt;span style="color:#ae81ff"&gt;\n&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#34;&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#a6e22e"&gt;system&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="0x03-虚拟内存页管理"&gt;0x03 虚拟内存页管理&lt;/h2&gt;
&lt;h3 id="申请虚拟内存页"&gt;申请虚拟内存页&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;VirtualAlloc&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>Windows 文件映射</title><link>https://payloads.online/archivers/2018-12-20/windows-FileMapping/</link><pubDate>Thu, 20 Dec 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-12-20/windows-FileMapping/</guid><description>&lt;h2 id="0x00-文件映射的原理"&gt;0x00 文件映射的原理&lt;/h2&gt;
&lt;p&gt;文件映射(Mapping)是一种能够将文件内容映射到进程的虚拟地址空间的技术。视图(view)是一个由映射句柄开辟的一块虚拟地址空间，用于存放文件内容，当文件被映射完成后，改写视图虚拟地址空间的内容就相当于更改文件内容。&lt;/p&gt;
&lt;p&gt;一般情况下，当代码运行完毕后，视图将会被自动写入文件中。&lt;/p&gt;
&lt;h2 id="0x01-文件映射的步骤"&gt;0x01 文件映射的步骤&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CreateFile()&amp;hellip;&lt;/li&gt;
&lt;li&gt;CreateFileMapping()&amp;hellip;&lt;/li&gt;
&lt;li&gt;MapViewofFile()&amp;hellip;&lt;/li&gt;
&lt;li&gt;FlushViewofFile()&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先需要创建一个文件句柄，然后再创建一个文件映射的Mapping内核对象，通过映射获得视图。&lt;/p&gt;
&lt;h2 id="0x02-文件映射简单代码"&gt;0x02 文件映射简单代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// ConsoleApplication2.cpp : 定义控制台应用程序的入口点。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;//
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#include&lt;/span&gt; &lt;span style="color:#75715e"&gt;&amp;#34;stdafx.h&amp;#34;&lt;/span&gt;&lt;span style="color:#75715e"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#include&lt;/span&gt; &lt;span style="color:#75715e"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style="color:#75715e"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#include&lt;/span&gt; &lt;span style="color:#75715e"&gt;&amp;lt;Windows.h&amp;gt;&lt;/span&gt;&lt;span style="color:#75715e"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;_tmain&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#75715e"&gt;// 内存映射
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#75715e"&gt;// CreateFile()...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#75715e"&gt;// CreateFileMapping()...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#75715e"&gt;// MapViewofFile()...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#75715e"&gt;// FlushViewofFile...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	HANDLE hFile &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;CreateFile&lt;/span&gt;(&lt;span style="color:#a6e22e"&gt;TEXT&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;C:&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;\\&lt;/span&gt;&lt;span style="color:#e6db74"&gt;Temp&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;\\&lt;/span&gt;&lt;span style="color:#e6db74"&gt;99.txt&amp;#34;&lt;/span&gt;), GENERIC_ALL, &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (hFile &lt;span style="color:#f92672"&gt;==&lt;/span&gt; INVALID_HANDLE_VALUE) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;		std&lt;span style="color:#f92672"&gt;::&lt;/span&gt;wcout &lt;span style="color:#f92672"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;GetLastError&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;		&lt;span style="color:#a6e22e"&gt;MessageBox&lt;/span&gt;(&lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;TEXT&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;CreateFile&amp;#34;&lt;/span&gt;), &lt;span style="color:#a6e22e"&gt;TEXT&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;Error&amp;#34;&lt;/span&gt;), MB_OK);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;		&lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	HANDLE hMap &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;CreateFileMapping&lt;/span&gt;(hFile, NULL, PAGE_READWRITE, &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;1024&lt;/span&gt;, &lt;span style="color:#a6e22e"&gt;TEXT&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;f&amp;#34;&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (hMap &lt;span style="color:#f92672"&gt;==&lt;/span&gt; INVALID_HANDLE_VALUE) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;		&lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	TCHAR szBuff[&lt;span style="color:#ae81ff"&gt;100&lt;/span&gt;] &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;TEXT&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;sssss&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;\n&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	TCHAR &lt;span style="color:#f92672"&gt;*&lt;/span&gt; pFileVoid &lt;span style="color:#f92672"&gt;=&lt;/span&gt; (TCHAR &lt;span style="color:#f92672"&gt;*&lt;/span&gt;)&lt;span style="color:#a6e22e"&gt;MapViewOfFile&lt;/span&gt;(hMap, FILE_MAP_ALL_ACCESS, &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;1024&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#a6e22e"&gt;_tcscpy_s&lt;/span&gt;(pFileVoid, &lt;span style="color:#a6e22e"&gt;_countof&lt;/span&gt;(szBuff), szBuff);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	std&lt;span style="color:#f92672"&gt;::&lt;/span&gt;&lt;span style="color:#a6e22e"&gt;wprintf&lt;/span&gt;(pFileVoid);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#a6e22e"&gt;system&lt;/span&gt;(&lt;span style="color:#e6db74"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#a6e22e"&gt;CloseHandle&lt;/span&gt;(hMap);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	&lt;span style="color:#a6e22e"&gt;CloseHandle&lt;/span&gt;(hFile);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="0x03-api-list"&gt;0x03 API List&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;HANDLE WINAPI &lt;span style="color:#a6e22e"&gt;CreateFile&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _In_ LPCTSTR lpFileName,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _In_ DWORD dwDesiredAccess,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _In_ DWORD dwShareMode,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _In_ DWORD dwCreationDisposition,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _In_ DWORD dwFlagsAndAttributes,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _In_opt_ HANDLE hTemplateFile
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;HANDLE WINAPI &lt;span style="color:#a6e22e"&gt;CreateFileMapping&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _In_ HANDLE hFile,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _In_opt_ LPSECURITY_ATTRIBUTES lpAttributes,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _In_ DWORD flProtect,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _In_ DWORD dwMaximumSizeHigh,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _In_ DWORD dwMaximumSizeLow,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _In_opt_ LPCTSTR lpName
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;LPVOID WINAPI &lt;span style="color:#a6e22e"&gt;MapViewOfFile&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _In_ HANDLE hFileMappingObject,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _In_ DWORD dwDesiredAccess,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _In_ DWORD dwFileOffsetHigh,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _In_ DWORD dwFileOffsetLow,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _In_ SIZE_T dwNumberOfBytesToMap
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;BOOL WINAPI &lt;span style="color:#a6e22e"&gt;FlushViewOfFile&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _In_ LPCVOID lpBaseAddress,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _In_ SIZE_T dwNumberOfBytesToFlush
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;BOOL WINAPI &lt;span style="color:#a6e22e"&gt;UnmapViewOfFile&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _In_ LPCVOID lpBaseAddress
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;BOOL WINAPI &lt;span style="color:#a6e22e"&gt;UnmapViewOfFile&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _In_ LPCVOID lpBaseAddress
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="0x04-创建一个超大文件"&gt;0x04 创建一个超大文件&lt;/h2&gt;
&lt;p&gt;在写Example的过程中，我发现申请映射的内存空间会把每个字节写入文件中。&lt;/p&gt;</description></item><item><title>最近学习Windows编程总结</title><link>https://payloads.online/archivers/2018-12-20/1/</link><pubDate>Thu, 20 Dec 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-12-20/1/</guid><description>&lt;h2 id="0x00-windows-字符编码"&gt;0x00 Windows 字符编码&lt;/h2&gt;
&lt;p&gt;目前Windows最常见的字符集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.ASCII&lt;/li&gt;
&lt;li&gt;2.Unicode&lt;/li&gt;
&lt;li&gt;3.UTF-16&lt;/li&gt;
&lt;li&gt;4.UTF-8&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Unicode是一个字符集，UTF-16是Unicode的存储实现，Windows中的Unicode默认是UTF-16存储方式。&lt;/p&gt;
&lt;p&gt;Unicode：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UTF-16：一个字符占用两个字节&lt;/li&gt;
&lt;li&gt;UTF8-8：一个字符占用两个字节，一般用于网络传输&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="各个字符集的bom头"&gt;各个字符集的BOM头&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;UTF-8：EF BB BF&lt;/li&gt;
&lt;li&gt;UTF-16LE：FF FE&lt;/li&gt;
&lt;li&gt;UTF16BE：FE FF&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="windows字符数据类型"&gt;Windows字符数据类型&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;CHAR &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;char&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;PSTR &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;char&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;WCHAR &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;wchar_t&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;PWSTR &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;wchar_t&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;TCHAR &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt; &lt;span style="color:#960050;background-color:#1e0010"&gt;一个宏，当前是什么字符集，编译出来就是什么字符集&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;PTSTR &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt; TCHAR &lt;span style="color:#f92672"&gt;*&lt;/span&gt; (&lt;span style="color:#960050;background-color:#1e0010"&gt;有利于跨平台&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;开发中推荐使用“TEXT”宏与PTSTR类型的字符串指针。&lt;/p&gt;
&lt;h2 id="0x01-windows进程创建"&gt;0x01 Windows进程创建&lt;/h2&gt;
&lt;p&gt;进程是一个程序正在运行的一个实例，它由一个内核对象和一个地址空间组成。&lt;/p&gt;
&lt;p&gt;内核对象与地址空间都在4GB的虚拟内存中，内核占2GB高地址，低地址的2GB给程序的堆栈使用。&lt;/p&gt;
&lt;p&gt;在Windows中，系统通过句柄管理进程中的资源，句柄存储在内核空间中的一个全局句柄表中，而每个进程也都有一个句柄表，这个句柄表是私有的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PID&lt;/strong&gt; 是指的是全局句柄表的值。&lt;/p&gt;
&lt;h3 id="进程执行的加载过程"&gt;进程执行的加载过程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1.映射EXE&lt;/li&gt;
&lt;li&gt;2.创建内核对象EPROCESS&lt;/li&gt;
&lt;li&gt;3.映射系统DLL（ntdll.dll）&lt;/li&gt;
&lt;li&gt;4.创建线程内核对象ETHREAD&lt;/li&gt;
&lt;li&gt;5.系统启动线程、映射DLL（ntdll.LdrInitalizeThunk）、线程开始执行&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="创建进程"&gt;创建进程&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;BOOL &lt;span style="color:#a6e22e"&gt;CreateProcess&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;LPCTSTR lpApplicationName,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;LPTSTR lpCommandLine,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;LPSECURITY_ATTRIBUTES lpProcessAttributes,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;LPSECURITY_ATTRIBUTES lpThreadAttributes,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;BOOL bInheritHandles,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;DWORD dwCreationFlags,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;LPVOID lpEnvironment,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;LPCTSTR lpCurrentDirectory,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;LPSTARTUPINFO lpStartupInfo,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;LPPROCESS_INFORMATIONlpProcessInformation
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="线程与进程的关系"&gt;线程与进程的关系&lt;/h3&gt;
&lt;p&gt;进程是一个程序正在运行的一个实例，它提供了一块存储代码的空间，在进程被创建时，系统也会给进程创建一个主线程（primary thread），主线程负责执行代码，一个进程没有线程是无法运行的。&lt;/p&gt;
&lt;p&gt;一个进程可以拥有多个线程，但是永远是先拥有主线程，通过主线程创建其他线程。&lt;/p&gt;</description></item><item><title>使用C语言发送伪造源IP的UDP请求及DRDOS拒绝服务攻击原理剖析</title><link>https://payloads.online/archivers/2018-03-04/1/</link><pubDate>Sun, 04 Mar 2018 00:00:00 +0000</pubDate><guid>https://payloads.online/archivers/2018-03-04/1/</guid><description>&lt;h2 id="0x01-什么是drdos"&gt;0x01 什么是DRDOS&lt;/h2&gt;
&lt;p&gt;DRDoS是英文“Distributed Reflection Denial of Service ”的缩写，中文意思是“分布式反射拒绝服务”。与DoS、DDoS不同，该方式靠的是发送大量带有被害者IP地址的数据包给攻击主机，然后攻击主机对IP地址源做出大量回应，形成拒绝服务攻击。&lt;/p&gt;
&lt;h2 id="0x02-drdos的攻击流程"&gt;0x02 DRDOS的攻击流程&lt;/h2&gt;
&lt;p&gt;DRDoS要完成一次反射放大攻击：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 攻击者，必须提前需要把攻击数据存放在所有的在线肉鸡或者反射服务器之上。&lt;/li&gt;
&lt;li&gt;2 攻击者，必须伪造IP源头。发送海量伪造IP来源的请求。当然这里的IP就是受害者的IP地址。&lt;/li&gt;
&lt;li&gt;3 反射服务器，必须可以反射数据，运行良好稳定。最好是请求数据少，返回数据成万倍增加。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="0x03-drdos的特性"&gt;0x03 DRDOS的特性&lt;/h2&gt;
&lt;p&gt;（如果没有理解UDP协议，请不要向下继续阅读……会越来越混乱）&lt;/p&gt;
&lt;p&gt;根据上述概念可以理解为，DRDOS需要一个能够伪造IP头的协议，这个协议最突出的就是UDP协议了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用基于 TCP 协议的通信不可以对源 IP 地址进行伪造&lt;/li&gt;
&lt;li&gt;使用基于 UDP 协议的通信可以对源 IP 地址进行伪造&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;TCP 不能伪造源 IP 地址是因为 TCP 协议中的三次握手的存在，如果源 IP 地址被修改，那么三次握手将无法达成。&lt;/p&gt;
&lt;p&gt;而 UDP 则不同，UDP 中不存在三次握手，那么发送端就只要发送数据即可，而接收端只要接收数据即可。所以，在 TCP 中不能对源 IP 地址进行伪造，而 UDP 中则可以。&lt;/p&gt;
&lt;p&gt;UDP协议不需要握手，直接发送接收，下面我来通过小故事来形象的描述UDP中的伪造IP头攻击：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设有三个用户，Allen、Jerry、Tom.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="jerry与tom一次正常的udp请求"&gt;Jerry与Tom一次正常的UDP请求&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Jerry说：&lt;/code&gt;“我是Jerry，我的源端口是4787，我要向Tom的4478端口发送一个UDP报文”&lt;/p&gt;
&lt;p&gt;此时Tom的4478端口接收到一个UDP报文，需要回复内容，回复给谁呢，接下来需要根据报文中的IP头确定是谁发送的&lt;/p&gt;
&lt;p&gt;通过Jerry的话确定发送方是Jerry，而Jerry的端口是4787，那么Tom就会将数据传送给Jerry&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Tom说：&lt;/code&gt;“我是Tom，我的源端口是4478，根据刚才接收到的一句话中，确认了发送人是Jerry，我把数据传送给Jerry的4787端口”&lt;/p&gt;
&lt;h3 id="allen进行一次rdos攻击"&gt;Allen进行一次RDOS攻击&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Allen说：&lt;/code&gt;“我是Jerry，我的源端口是4787，我要向Tom的4478端口发送一个UDP报文”&lt;/p&gt;
&lt;p&gt;此时Tom接收到报文，根据上面这句话确定了发送人是Jerry，目的端口是4787&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Tom说：&lt;/code&gt;“我是Tom，我的源端口是4478，根据刚才接收到的一句话中，确认了发送人是Jerry，我把数据传送给Jerry的4787端口”&lt;/p&gt;
&lt;p&gt;这个过程当中，Jerry并没有参与通信，但是接到了一个从Tom那里发送过来的UDP数据报文&lt;/p&gt;
&lt;h2 id="0x04-编写一个伪造ip头的c语言程序"&gt;0x04 编写一个伪造IP头的C语言程序&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;/usr/include/netinet/ip.h&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里面定义了IP头&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;struct&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;ip&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#if __BYTE_ORDER == __LITTLE_ENDIAN
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;unsigned&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; ip_hl:&lt;span style="color:#ae81ff"&gt;4&lt;/span&gt;;		&lt;span style="color:#75715e"&gt;/* header length */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;unsigned&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; ip_v:&lt;span style="color:#ae81ff"&gt;4&lt;/span&gt;;		&lt;span style="color:#75715e"&gt;/* version */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#endif
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#if __BYTE_ORDER == __BIG_ENDIAN
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;unsigned&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; ip_v:&lt;span style="color:#ae81ff"&gt;4&lt;/span&gt;;		&lt;span style="color:#75715e"&gt;/* version */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;unsigned&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; ip_hl:&lt;span style="color:#ae81ff"&gt;4&lt;/span&gt;;		&lt;span style="color:#75715e"&gt;/* header length */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#endif
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;uint8_t&lt;/span&gt; ip_tos;			&lt;span style="color:#75715e"&gt;/* type of service */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;unsigned&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;short&lt;/span&gt; ip_len;		&lt;span style="color:#75715e"&gt;/* total length */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;unsigned&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;short&lt;/span&gt; ip_id;		&lt;span style="color:#75715e"&gt;/* identification */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;unsigned&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;short&lt;/span&gt; ip_off;		&lt;span style="color:#75715e"&gt;/* fragment offset field */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#define	IP_RF 0x8000			&lt;/span&gt;&lt;span style="color:#75715e"&gt;/* reserved fragment flag */&lt;/span&gt;&lt;span style="color:#75715e"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#define	IP_DF 0x4000			&lt;/span&gt;&lt;span style="color:#75715e"&gt;/* dont fragment flag */&lt;/span&gt;&lt;span style="color:#75715e"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#define	IP_MF 0x2000			&lt;/span&gt;&lt;span style="color:#75715e"&gt;/* more fragments flag */&lt;/span&gt;&lt;span style="color:#75715e"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;#define	IP_OFFMASK 0x1fff		&lt;/span&gt;&lt;span style="color:#75715e"&gt;/* mask for fragmenting bits */&lt;/span&gt;&lt;span style="color:#75715e"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;uint8_t&lt;/span&gt; ip_ttl;			&lt;span style="color:#75715e"&gt;/* time to live */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;uint8_t&lt;/span&gt; ip_p;			&lt;span style="color:#75715e"&gt;/* protocol */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;unsigned&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;short&lt;/span&gt; ip_sum;		&lt;span style="color:#75715e"&gt;/* checksum */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;struct&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;in_addr&lt;/span&gt; ip_src, ip_dst;	&lt;span style="color:#75715e"&gt;/* source and dest address */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;/usr/include/netinet/udp.h&lt;/p&gt;</description></item></channel></rss>