<!DOCTYPE html>
<html lang=""><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>socat 使用手册</title>
    <meta name="description" content="倾旋的博客">
    <meta name="author" content='倾旋'>

    <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous">

    
    <link rel="stylesheet" href="/sass/researcher.min.css">

    
        <link rel="icon" type="image/ico" href="https://payloads.online/favicon.ico">
    

    
        
    
</head>

    <body><div class="container mt-5">
    <nav class="navbar navbar-expand-sm flex-column flex-sm-row text-nowrap p-0">
        <a class="navbar-brand mx-0 mr-sm-auto" style="color: #dc3545;" href="https://payloads.online" title="倾旋的博客">
          
          倾旋的博客
        </a>
        <div class="navbar-nav flex-row flex-wrap justify-content-center">
            
                
                
                    <a class="nav-item nav-link" href="/about" title="About">
                        About
                    </a>
                    
                        <span class="nav-item navbar-text mx-1">/</span>
                    
                
                    <a class="nav-item nav-link" href="/projects/" title="Projects">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-terminal-fill" viewBox="0 0 16 16"><path d="M0 3a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V3zm9.5 5.5h-3a.5.5 0 0 0 0 1h3a.5.5 0 0 0 0-1zm-6.354-.354a.5.5 0 1 0 .708.708l2-2a.5.5 0 0 0 0-.708l-2-2a.5.5 0 1 0-.708.708L4.793 6.5 3.146 8.146z"/></svg> Projects
                    </a>
                    
                        <span class="nav-item navbar-text mx-1">/</span>
                    
                
                    <a class="nav-item nav-link" href="/links/" title="Links">
                        Links
                    </a>
                    
                        <span class="nav-item navbar-text mx-1">/</span>
                    
                
                    <a class="nav-item nav-link" href="/post/" title="Posts">
                        Posts
                    </a>
                    
                        <span class="nav-item navbar-text mx-1">/</span>
                    
                
                    <a class="nav-item nav-link" href="/index.xml" title="Rss">
                        Rss
                    </a>
                    
                        <span class="nav-item navbar-text mx-1">/</span>
                    
                
                    <a class="nav-item nav-link" href="/tools/" title="Tools">
                        Tools
                    </a>
                    
                
            
        </div>
    </nav>
</div>
<hr>
<div id="content">
<div class="container">
    <h2 id="socat简介">socat简介</h2>
<p>socat是一个多功能的网络工具，名字来由是” Socket CAT”，可以看作是netcat的N倍加强版，socat的官方网站：http://www.dest-unreach.org/socat/ 。</p>
<p>Socat是一个两个独立数据通道之间的双向数据传输的继电器。这些数据通道包含文件、管道、设备（终端或调制解调器等）、socket（Unix，IP4，IP6 - raw，UDP，TCP）、SSL、SOCKS4客户端或代理CONNECT。</p>
<p>Socat支持广播和多播、抽象Unix sockets、Linux tun/tap、GNU readline 和 PTY。它提供了分叉、记录和进程间通信的不同模式。多个选项可用于调整socat和其渠道，Socat可以作为TCP中继（一次性或守护进程），作为一个守护进程基于socksifier，作为一个shell Unix套接字接口，作为IP6的继电器，或面向TCP的程序重定向到一个串行线。</p>
<p>socat的主要特点就是在两个数据流之间建立通道；且支持众多协议和链接方式：<code>ip, tcp, udp, ipv6, pipe,exec,system,open,proxy,openssl,socket</code>等。</p>
<h2 id="socat的安装">socat的安装</h2>
<h3 id="网络安装">网络安装：</h3>
<ul>
<li>
<p>Debian/Ubuntu:<code>apt-get install socat</code></p>
</li>
<li>
<p>Mac OSX:<code>brew install socat</code></p>
</li>
</ul>
<p>ps:Kali linux 里已经集成了此工具</p>
<h3 id="下载软件包">下载软件包</h3>
<p>下载socat源代码包：http://www.dest-unreach.org/socat/download/</p>
<h3 id="编译安装">编译安装</h3>
<p>把下载的软件包解压后按照传统的方式编译安装：</p>
<pre><code>./configure
make
make install
</code></pre><p>具体的细节可以参考安装文档 README 。</p>
<h3 id="安装错误解决">安装错误解决</h3>
<p>在编译的过程中可能遇到如下错误：</p>
<p>解决方法有两种：</p>
<ul>
<li>第一种是禁用fips，使用如下命令配置：</li>
</ul>
<p><code>./configure --disable-fips</code></p>
<ul>
<li>第二种是安装fips</li>
</ul>
<p>首先到网站http://www.openssl.org/source/ 下载openssl-fips安装包，然后解压安装：</p>
<pre><code>./config
make
make install
</code></pre><h2 id="socat的使用">socat的使用</h2>
<p>socat的具体文档参见网站：http://www.dest-unreach.org/socat/doc/socat.html 。</p>
<h3 id="工作机理">工作机理</h3>
<p>socat的运行有4个阶段:</p>
<ul>
<li>
<p>初始化
解析命令行以及初始化日志系统。</p>
</li>
<li>
<p>打开连接
先打开第一个连接，再打开第二个连接。这个单步执行的。 如果第一个连接失败，则会直接退出。</p>
</li>
<li>
<p>数据转发
谁有数据就转发到另外一个连接上, read/write互换。</p>
</li>
<li>
<p>关闭
其中一个连接掉开，执行处理另外一个连接。</p>
</li>
<li>
<p>地址类型
参数由2部分组成，第一个连接和第二个连接，最简单的用法就是 socat - - 其效果就是输入什么，回显什么其用法主要在于地址如何描述, 下面介绍几个常用的。</p>
</li>
<li>
<p>TCP</p>
</li>
</ul>
<pre><code>TCP:&lt;host&gt;:&lt;port&gt; 目标机器IP对应端口port
TCP-LISTEN:&lt;port&gt; 本机监听端口。
</code></pre><ul>
<li>UDP</li>
</ul>
<pre><code>UDP:&lt;host&gt;:&lt;port&gt; 目标机器host对应端口port
UDP-LISTEN:&lt;port&gt; 本机监听端口。
</code></pre><ul>
<li>OPENSSL</li>
</ul>
<p>需要一个证书,否则会失败提示: 2012/04/06 11:29:11 socat[1614] E SSL_connect(): error:14077410:SSL routines:SSL23_GET_SERVER_HELLO:sslv3 alert handshake failure</p>
<pre><code>OPENSSL:&lt;host&gt;:&lt;port&gt; 目标机器host对应端口port
OPENSSL-LISTEN:&lt;port&gt; 本机监听端口。
</code></pre><ul>
<li>TUN</li>
</ul>
<p><code>TUN[:&lt;if-addr&gt;/&lt;bits&gt;] 建立vpn，双方都需要root权限。</code></p>
<h2 id="典型使用">典型使用</h2>
<h3 id="连接目标">连接目标</h3>
<p><code>socat - tcp:192.168.1.18:80</code></p>
<p>这个命令等同于 nc 192.168.1.18 80。</p>
<p>socat里面，必须有两个流，所以第一个参数-代表标准的输入输出，第二个流连接到192.168.1.18的80端口。</p>
<p><code>socat -d -d READLINE,history=$HOME/.http_history TCP4:www.qq.com:80</code></p>
<p>这个例子支持历史记录查询，类似于bash的历史记录。</p>
<h3 id="反向连接">反向连接</h3>
<p>再看一个反向telnet的例子：
on server:</p>
<p><code>socat tcp-listen:23 exec:cmd,pty,stderr</code></p>
<p>这个命名把cmd绑定到端口23，同时把cmd的Stderr复位向到stdout。</p>
<p>on client:</p>
<p><code>socat readline tcp:server:23</code></p>
<p>连接到服务器的23端口，即可获得一个cmd shell。readline是gnu的命令行编辑器，具有历史功能。</p>
<h3 id="向远程端口发数据">向远程端口发数据</h3>
<p><code>echo “test” | socat – tcp-connect:127.0.0.1:12345</code></p>
<h3 id="本地开启端口">本地开启端口</h3>
<p><code>socat tcp-l:7777,reuseaddr,fork system:bash</code></p>
<p>同nc -l -p 7777 -e bash。</p>
<h3 id="执行bash的完美用法">执行bash的完美用法</h3>
<p>| 服务端 | <code>socat tcp-l:8888 system:bash,pty,stderr</code>|
| 本地   | <code>socat readline tcp:$target:8888</code>       |</p>
<p>用readline替代-，就能支持历史功能了。在这个模式下的客户端有本地一样的效果</p>
<h3 id="文件传递">文件传递</h3>
<p>再看文件传递的例子。nc也经常用来传递文件，但是nc有一个缺点，就是不知道文件什么时候传完了，一般要用Ctrl+c来终止，或者估计一个时间，用-w参数来让他自动终止。用socat就不用这么麻烦了：</p>
<p>| on host 1 | socat -u open:myfile.exe,binary tcp-listen:999 |
| on host 2 | socat -u tcp:host1:999 open:myfile.exe,create,binary</p>
<p>这个命令把文件myfile.exe用二进制的方式，从host 1 传到host 2。-u 表示数据单向流动，从第一个参数到第二个参数，-U表示从第二个到第一个。文件传完了，自动退出。</p>
<h3 id="转发">转发</h3>
<p>| 本地端口转向远程主机 | socat TCP4-LISTEN:8888 TCP4:www.qq.com:80 |</p>
<p>如果需要使用并发连接，则加一个fork,如下:</p>
<p><code>socat TCP4-LISTEN:8888,fork TCP4:www.qq.com:80</code></p>
<p>本地监听8888端口，来自8888的连接重定向到目标www.qq.com:80</p>
<h3 id="端口映射">端口映射</h3>
<p>再来一个大家喜欢用的例子。在一个NAT环境，如何从外部连接到内部的一个端口呢？只要能够在内部运行socat就可以了。</p>
<p>| 外部 | socat tcp-listen:1234 tcp-listen:3389 |
| 内部 | socat tcp:outerhost:1234 tcp:192.168.12.34:3389 |</p>
<p>这样，你外部机器上的3389就映射在内部网192.168.12.34的3389端口上。</p>
<h3 id="vpn">VPN</h3>
<p>| 服务端 | socat -d -d TCP-LISTEN:11443,reuseaddr TUN:192.168.255.1/24,up |
| 客户端 | socat TCP:1.2.3.4:11443 TUN:192.168.255.2/24,up |</p>
<h3 id="重定向">重定向</h3>
<p><code>socat TCP4-LISTEN:80,reuseaddr,fork TCP4:192.168.123.12:8080</code></p>
<p>|TCP4-LISTEN | 在本地建立的是一个TCP ipv4协议的监听端口|
| reuseaddr  | 绑定本地一个端口；
|fork|设定多链接模式，即当一个链接被建立后，自动复制一个同样的端口再进行监听|</p>
<p>socat启动监听模式会在前端占用一个shell，因此需使其在后台执行。</p>
<p><code>socat -d -d tcp4-listen:8900,reuseaddr,fork tcp4:10.5.5.10:3389</code></p>
<p>或者</p>
<p><code>socat -d -d -lf /var/log/socat.log TCP4-LISTEN:15000,reuseaddr,fork,su=nobody TCP4:static.5iops.com:15000</code></p>
<p><code>-d -d -lf /var/log/socat.log</code>是参数，前面两个连续的<code>-d -d</code>代表调试信息的输出级别，<code>-lf</code>则指定输出信息的保存文件。</p>
<p><code>TCP4-LISTEN:15000,reuseaddr,fork,su=nobody</code>是一号地址，代表在15000端口上进行TCP4协议的监听，复用绑定的IP，每次有连接到来就fork复制一个进程进行处理，同时将执行用户设置为nobody用户。</p>
<p><code>TCP4:static.5iops.com:15000</code>是二号地址，代表将socat监听到的任何请求，转发到<code>static.5iops.com:15000</code>上去。</p>
<h3 id="读写分流">读写分流</h3>
<p>socat还具有一个独特的读写分流功能，比如：</p>
<p><code>socat open:read.txt!!open:write.txt,create,append tcp-listen:80,reuseaddr,fork</code></p>
<p>这个命令实现一个假的web server，客户端连过来之后，就把read.txt里面的内容发过去，同时把客户的数据保存到write.txt里面。”！！”符号用户合并读写流，前面的用于读，后面的用于写。</p>
<h3 id="通过openssl来加密传输过程">通过openssl来加密传输过程</h3>
<p>证书生成</p>
<pre><code>FILENAME=60.*.*.*
openssl genrsa -out $FILENAME.key 1024
openssl req -new -key $FILENAME.key -x509 -days 3653 -out $FILENAME.crtcat $FILENAME.key $FILENAME.crt &gt;$FILENAME.pem
</code></pre><p>在当前目录下生成 <code>server.pem 、server.crt</code></p>
<p>使用</p>
<p>|服务端 |socat openssl-listen:4433,reuseaddr,cert=srv.pem,cafile=srv.crt system:bash,pty,stderr |
|本地 | socat readline openssl:localhost:4433,cert=srv.pem,cafile=srv.crt |</p>

</div>

        </div><div id="footer" class="mb-5">
    <hr>
    <div class="container text-center">
        
            <a href="https://twitter.com/Rvn0xsy" class="fab fa-twitter fa-1x" title="Twitter"></a>
        
            <a href="mailto:rvn0xsy@gmail.com" class="fas fa-envelope fa-1x" title="E-mail"></a>
        
    </div>
    
        <div class="container text-center">
            <a href="https://payloads.online" title="- PAYLOADS.ONLINE -"><small>- PAYLOADS.ONLINE -</small></a>
        </div>
    
</div>



<script src="https://cdn.jsdelivr.net/gh/jmnote/plantuml-encoder@1.2.4/dist/plantuml-encoder.min.js" integrity="sha256-Qsk2KRBCN5qVZX7B+8+2IvQl1Aqc723qV1tBCQaVoqo=" crossorigin="anonymous"></script>
<script>
(function(){
  let plantumlPrefix = "language-plantuml";
  Array.prototype.forEach.call(document.querySelectorAll("[class^=" + plantumlPrefix + "]"), function(code){
    let image = document.createElement("IMG");
    image.loading = 'lazy'; 
    image.src = 'http://www.plantuml.com/plantuml/svg/~1' + plantumlEncoder.encode(code.innerText);
    code.parentNode.insertBefore(image, code);
    code.style.display = 'none';
  });
})();
</script>

</body>
</html>
