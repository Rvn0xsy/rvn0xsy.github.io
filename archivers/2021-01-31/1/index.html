<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Windows权限控制相关的防御与攻击技术 - 倾旋的博客</title><meta name=viewport content="width=device-width,initial-scale=1">
<link rel=stylesheet type=text/css media=screen href=https://payloads.online/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://payloads.online/css/main.css><link rel=stylesheet type=text/css media=screen href=https://payloads.online/css/extra.css><link id=dark-scheme rel=stylesheet type=text/css href=https://payloads.online/css/dark.css><script src=https://payloads.online/js/feather.min.js></script><script src=https://payloads.online/js/main.js></script><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&family=Inter:wght@400;500;600;700&display=swap"><link rel=stylesheet href=/css/fontawesome.css></head><body><div class="container-wide wrapper"><div class=header><div class=avatar><a href=https://payloads.online/><img src=/avatar.jpeg alt=倾旋的博客></a></div><h1 class=site-title><a href=https://payloads.online/>倾旋的博客</a></h1><div class=site-description><p>现阶段在进行有效性验证/攻击模拟相关的安全研究工作，我的博客会记录一些我的学习过程和部分安全技术研究成果。</p><nav class="nav social"><ul class=flat><li><a href=https://github.com/rvn0xsy/ title=Github><i data-feather=github></i></a></li><li><a href=/index.xml title=RSS><i data-feather=rss></i></a></li><li><a href=/ title=Wechat><i data-feather=message-circle></i></a></li><span class=scheme-toggle><a href=# id=scheme-toggle></a></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>首页</a></li><li><a href=/posts/>文章列表</a></li><li><a href=/tags>标签</a></li><li><a href=/projects>开源项目</a></li><li><a href=/about>关于我</a></li><li><a href=/links/>友情链接</a></li><li><a href=/message>留言</a></li><li><a href=/sponsor>赞助</a></li></ul></nav></div><div class=article-nav id=article-nav-id><div class=post><div class=post-header><div class=meta><div class=date><span class=day>31</span>
<span class=rest>Jan 2021</span></div></div><div class=matter><h1 class=title>Windows权限控制相关的防御与攻击技术</h1></div></div><aside class="show-on-mobile toc" id=static-toc><header><h3>Contents</h3></header><nav id=TableOfContents><ol><li><a href=#0x00-前言>0x00 前言</a></li><li><a href=#0x01-安全描述符security-descriptorssd>0X01 安全描述符(Security Descriptors，SD)</a><ol><li><a href=#windows具体有哪些安全对象>Windows具体有哪些安全对象？</a></li></ol></li><li><a href=#0x02-安全描述符的组成>0x02 安全描述符的组成</a><ol><li><a href=#什么是sidsecurity-identifiersid>什么是SID（Security Identifier，SID）</a></li><li><a href=#相对标识符relative-identifer-rid>相对标识符(Relative Identifer, RID)</a></li></ol></li><li><a href=#0x03-自主访问控制列表discretionary-access-control-listdacl>0x03 自主访问控制列表（Discretionary access control list，DACL）</a></li><li><a href=#0x04-系统访问控制列表system-access-control-listsacl>0x04 系统访问控制列表（System access control list，SACL）</a></li><li><a href=#0x05-修改访问控制列表access-control-listacl>0x05 修改访问控制列表（Access control list，ACL）</a><ol><li><a href=#null-dacl和空dacl>NULL DACL和空DACL</a></li></ol></li><li><a href=#0x06-土豆potato提权的本质与进程访问控制>0x06 土豆（Potato）提权的本质与进程访问控制</a></li><li><a href=#0x07-访问令牌模拟access-token-impersonation>0x07 访问令牌模拟（Access Token Impersonation）</a><ol><li><a href=#正常情况下什么时候需要用到令牌模拟>正常情况下什么时候需要用到令牌模拟？</a></li></ol></li><li><a href=#0x08-进程注入process-inject>0x08 进程注入（Process Inject）</a></li><li><a href=#0x09-文件的权限修改>0x09 文件的权限修改</a><ol><li><a href=#创建匿名共享>创建匿名共享</a></li></ol></li><li><a href=#0x10-创造提权漏洞服务后门>0x10 创造提权漏洞——服务后门</a><ol><li><a href=#powershell更改服务权限>Powershell更改服务权限</a></li><li><a href=#cmd修改服务权限>CMD修改服务权限</a></li></ol></li><li><a href=#0x11-windows域下的dcsync攻击及后门实现>0x11 Windows域下的DCSync攻击及后门实现</a><ol><li><a href=#哪些用户拥有域复制权限>哪些用户拥有域复制权限？</a></li><li><a href=#什么是域复制权限--域扩展权限>什么是域复制权限 — 域扩展权限</a></li><li><a href=#ds-replication-get-changes>DS-Replication-Get-Changes</a></li><li><a href=#dcsync后门实现>DcSync后门实现</a></li><li><a href=#dcsync权限检测>DCSync权限检测</a></li></ol></li><li><a href=#参考>参考</a></li></ol></nav></aside><h2 id=0x00-前言>0x00 前言</h2><p>近年来终端安全检测与响应的产品发展迅速，我们不得不意识到，安全是在一个循环中发展的，从人们意识到安全开始，大部分了解到层面都是病毒、木马，然后接着是浏览器相关的Web安全领域，最后又开始回到终端。这个议题我们通过了解Windows操作系统下的访问控制技术，站在攻防的不同角度去进行对抗，提升自身的知识储备，个人觉得这些知识适用于许多使用Windows操作系统的用户。</p><h2 id=0x01-安全描述符security-descriptorssd>0X01 安全描述符(Security Descriptors，SD)</h2><p>在Windows中，每一个安全对象实体都拥有一个安全描述符，安全描述符包含了被保护对象相关联的安全信息的数据结构，它的作用主要是为了给操作系统提供判断来访对象的权限。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>0:000&gt; dt nt!_security_descriptor
</span></span><span style=display:flex><span>ntdll!_SECURITY_DESCRIPTOR
</span></span><span style=display:flex><span>   +0x000 Revision         : UChar  # 版本
</span></span><span style=display:flex><span>   +0x001 Sbz1             : UChar  # 大小
</span></span><span style=display:flex><span>   +0x002 Control          : Uint2B # 一组标志，用于限定安全描述符或安全描述符的各个字段的含义
</span></span><span style=display:flex><span>   +0x008 Owner            : Ptr64 Void # 指定对象的所有者（SID）
</span></span><span style=display:flex><span>   +0x010 Group            : Ptr64 Void # 指定对象的主组（SID）
</span></span><span style=display:flex><span>   +0x018 Sacl             : Ptr64 _ACL # 系统访问控制列表
</span></span><span style=display:flex><span>   +0x020 Dacl             : Ptr64 _ACL # 自主访问控制列表
</span></span></code></pre></td></tr></table></div></div><h3 id=windows具体有哪些安全对象>Windows具体有哪些安全对象？</h3><ul><li>进程</li><li>线程</li><li>文件</li><li>服务</li><li>计划任务</li><li>互斥体</li><li>管道</li><li>油槽</li><li>文件共享</li><li>访问令牌</li><li>注册表</li><li>打印机</li><li>作业</li><li>&mldr;</li></ul><p>一般情况下，大部分用户接触更多的可能就是文件了，我们就以文件开始，文件对于我们去学习访问控制是最直观的。</p><p>一个文件的权限描述符主要表现为：</p><p><img src=https://images.payloads.online/a87eb66c-4f5f-11ec-adb7-00d861bf4abb.png alt=2021-01-31-21-43-05></p><p>上图中的安全选项卡主要是表述了sethc.exe这个文件能够被哪些用户访问，并且这些用户拥有sethc.exe的哪些权限，如：读取、读取和执行、写入、完全控制等。</p><p><img src=https://images.payloads.online/a8c5e5a0-4f5f-11ec-b9be-00d861bf4abb.png alt=2021-01-31-21-44-40></p><h2 id=0x02-安全描述符的组成>0x02 安全描述符的组成</h2><p>DACL通过一系列ACE定义了所有被允许或者禁止的安全对象的访问者，SACL描述了系统应该审核的内容，系统会根据审核项产生对应的系统日志。</p><p><img src=https://images.payloads.online/a90af0be-4f5f-11ec-94bd-00d861bf4abb.png alt=2021-01-31-21-45-22></p><blockquote><p>权限选项卡代表了 DACL，审核选项卡代表了 SACL。</p></blockquote><h3 id=什么是sidsecurity-identifiersid>什么是SID（Security Identifier，SID）</h3><p><img src=https://images.payloads.online/a95f5988-4f5f-11ec-8610-00d861bf4abb.png alt=2021-01-31-21-49-18></p><p>每个参与权限决策的角色都拥有一个SID，这个SID为了保证角色的唯一性。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>S-[修订级别]-[权值]-[标识符]
</span></span></code></pre></td></tr></table></div></div><p>SID分为两种：</p><ul><li>内置SID</li><li>自动分配SID</li></ul><p>内置SID有：</p><ul><li>S-1-5-18 (LocalSystem)</li><li>S-1-5-19 (LocalService)</li><li>S-1-5-20 (NetworkService)</li><li>S-1-5-32-544 (Administrators)</li><li>S-1-5-32-545 (Users)</li><li>S-1-5-32-550 (PrintOperators)</li><li>&mldr;</li></ul><h3 id=相对标识符relative-identifer-rid>相对标识符(Relative Identifer, RID)</h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>S-[修订级别]-[权值]-[标识符]-[相对标识符]
</span></span></code></pre></td></tr></table></div></div><p>例如：</p><ul><li>S-1-5-21-xxxx-xxx-500 (Administrator) 本地管理员</li><li>S-1-5-21-xxxx-xxx-501 (Guest) 本地来宾用户</li><li>S-1-5-21-xxxx-xxx-1004 (Workstaion) 本地工作站</li></ul><p>其中RID为<code>500</code>的用户代表管理员用户，账户个RID值是固定的，通常渗透中常说的RID劫持、克隆用户就是修改其他用户的RID值来实现让系统认为当前用户是管理员。</p><h2 id=0x03-自主访问控制列表discretionary-access-control-listdacl>0x03 自主访问控制列表（Discretionary access control list，DACL）</h2><p><img src=https://images.payloads.online/a99be9c0-4f5f-11ec-93a4-00d861bf4abb.png alt=2021-01-31-21-51-33></p><p>解读：每一个Windows进程都拥有一个线程，当程序想要访问某个安全对象时，系统会提取当前线程的访问令牌，然后将访问令牌的权限和被访问的安全对象DACL进行比较。</p><ul><li><p>Thread A拥有Adrew的访问令牌，当它访问对象Object的时候，系统会从DACL第一个条目开始向下比对，由于第一个ACE是Access denied，并且用户名恰巧是Adrew，因此系统会拒绝访问，返回错误代码5。</p></li><li><p>Thread B拥有Jane的访问令牌，当它访问对象Object的时候，系统会从DACL第一个条目开始向下比对，由于第一个ACE不是针对Jane设置的，因此会继续向下比对，当到达第二个ACE时，Jane属于Group A，满足比对条件，因此拥有Write的权限。到达第三个时，如果Jane想要的是读取，那么也会在到达第三个ACE后，获得读取的权限。</p></li></ul><p>这张图很清晰的描述了一个线程访问系统安全对象的过程，也能够帮我们更清楚的理解令牌窃取、假冒的原理。</p><blockquote><p><a href=https://docs.microsoft.com/en-us/windows/win32/secauthz/how-dacls-control-access-to-an-object>https://docs.microsoft.com/en-us/windows/win32/secauthz/how-dacls-control-access-to-an-object</a></p></blockquote><p>当一个线程访问安全对象时，操作系统会将访问令牌的属性与被访问对象安全描述符中的DACL进行检查，检查的条目就是访问控制条目（Access control entries，ACE），最先检查的ACE优先级越高。</p><h2 id=0x04-系统访问控制列表system-access-control-listsacl>0x04 系统访问控制列表（System access control list，SACL）</h2><p><img src=https://images.payloads.online/a9d46df4-4f5f-11ec-98aa-00d861bf4abb.png alt=2021-01-31-22-00-15></p><p>系统访问控制列表主要是配置审核对象的ACE，当这些ACE被允许或拒绝的时候，系统将自动产生“安全”日志。</p><p>图中设置了Service.log的SACL，当它的DACL被改变成功后，操作系统会自动帮助我们产生一条安全日志，我们可以提取其中的关键信息，如：</p><ul><li>时间</li><li>访问的进程</li><li>访问的线程ID</li><li>访问的计算机</li><li>访问的用户名等</li><li>&mldr;</li></ul><p><img src=https://images.payloads.online/aa196238-4f5f-11ec-9987-00d861bf4abb.png alt=2021-01-31-22-03-10></p><h2 id=0x05-修改访问控制列表access-control-listacl>0x05 修改访问控制列表（Access control list，ACL）</h2><p>在Windows中，修改内核对象的方法只有调用API，因此，可以将安全描述符也理解为一个内核对象的属性。</p><p>以下是修改ACL的简要过程：</p><ol><li>使用 <strong><a href=https://docs.microsoft.com/en-us/windows/desktop/api/Aclapi/nf-aclapi-getsecurityinfo>GetSecurityInfo</a></strong> 或者 <strong><a href=https://docs.microsoft.com/en-us/windows/desktop/api/Aclapi/nf-aclapi-getnamedsecurityinfoa>GetNamedSecurityInfo</a></strong> 函数从对象的<a href=https://docs.microsoft.com/en-us/windows/desktop/SecGloss/s-gly>安全描述符</a>中获取DACL。</li><li>对于每个新的ACE，请调用<a href=https://docs.microsoft.com/en-us/windows/desktop/api/Aclapi/nf-aclapi-buildexplicitaccesswithnamea>BuildExplicitAccessWithName</a>函数以使用描述ACE的信息填充<a href=https://docs.microsoft.com/en-us/windows/desktop/api/AccCtrl/ns-accctrl-explicit_access_a>EXPLICIT_ACCESS</a>结构。</li><li>调用<a href=https://docs.microsoft.com/en-us/windows/desktop/api/Aclapi/nf-aclapi-setentriesinacla>SetEntriesInAcl</a>，为新ACE指定现有的ACL和<a href=https://docs.microsoft.com/en-us/windows/desktop/api/AccCtrl/ns-accctrl-explicit_access_a>EXPLICIT_ACCESS</a>结构的数组。SetEntriesInAcl函数分配和初始化的ACL和的ACE。</li><li>调用<a href=https://docs.microsoft.com/en-us/windows/desktop/api/Aclapi/nf-aclapi-setsecurityinfo>SetSecurityInfo</a>或<a href=https://docs.microsoft.com/en-us/windows/desktop/api/Aclapi/nf-aclapi-setnamedsecurityinfoa>SetNamedSecurityInfo</a>函数，将新的ACL附加到对象的安全描述符。</li></ol><p>下方的链接提供了一个简单的例子：</p><blockquote><p><a href=https://docs.microsoft.com/en-us/windows/win32/secauthz/creating-or-modifying-an-acl>https://docs.microsoft.com/en-us/windows/win32/secauthz/creating-or-modifying-an-acl</a></p></blockquote><h3 id=null-dacl和空dacl>NULL DACL和空DACL</h3><p>如果属于对象的安全描述符的自由访问控制列表（Discretionary access control list，DACL）设置为NULL，则会创建一个NULL DACL。NULL DACL授予对请求它的任何用户的完全访问权限，不对该对象执行正常的安全检查。</p><p>NULL的DACL与空的DACL是有区别的，空DACL是正确分配和初始化的DACL，其中不包含访问控制项（Access control entries，ACE），任何对象都不允许访问。</p><p>我发现两个有趣的事情：</p><ol><li>如果我将lsass.exe进程的DACL设置为NULL，我发现在系统重启后，再也启动不起来了，一直循环蓝屏。</li><li>如果我将lsass.exe进程的DACL设置为空，我发现即便是以Guest用户登录，也不能轻易的转储lsass.exe的内存。应该是有某些保护机制。</li></ol><h2 id=0x06-土豆potato提权的本质与进程访问控制>0x06 土豆（Potato）提权的本质与进程访问控制</h2><p>土豆系列的提权原理主要是诱导高权限访问低权限的系统对象，导致低权限的对象可以模拟高权限对象的访问令牌（Access Token），进而可以用访问令牌创建进程，达到代码执行。</p><p><a href=https://payloads.online/archivers/2020-03-21/1>《Windows特权提升漏洞-符号》</a> 提到过：访问控制模型有两个主要的组成部分，访问令牌（Access Token）和安全描述符（Security Descriptor），它们分别是访问者和被访问者拥有的东西。通过访问令牌和安全描述符的内容，Windows可以确定持有令牌的访问者能否访问持有安全描述符的对象。</p><ul><li>烂土豆(Rotten Potato)提权MS16-075</li></ul><p><a href=https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2016/ms16-075>https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2016/ms16-075</a></p><ul><li><a href=https://itm4n.github.io/cve-2020-0668-windows-service-tracing-eop/>CVE-2020-0668</a></li><li><a href="https://www.youtube.com/watch?v=1axTbxPz2_8">CVE-2020-0683 MSI Packages Symbolic Links Processing - Windows 10 Privilege Escalation</a></li><li><a href=https://github.com/nomi-sec/PoC-in-GitHub#cve-2020-8950>CVE-2020-8950</a></li><li><a href=https://github.com/nomi-sec/PoC-in-GitHub#cve-2020-0686>CVE-2020-0683</a></li><li><a href=https://github.com/nomi-sec/PoC-in-GitHub#cve-2019-1002101>CVE-2019-1002101</a></li><li><a href=https://github.com/nomi-sec/PoC-in-GitHub#cve-2019-0986>CVE-2019-0986</a></li><li><a href=https://github.com/nomi-sec/PoC-in-GitHub#cve-2018-1088>CVE-2018-1088</a></li><li>&mldr;.</li></ul><p>这些漏洞要么是利用巧妙的手法获取令牌、要么是用高权限移动文件，因此用户层的提权漏洞大多都需要系统“主动”起来。</p><h2 id=0x07-访问令牌模拟access-token-impersonation>0x07 访问令牌模拟（Access Token Impersonation）</h2><p>Windows 的令牌类型：</p><ol><li>主令牌（Primary Token）</li><li>模拟令牌（Impersonation Token）</li></ol><p>渗透中常说的令牌假冒、令牌窃取都是利用Windows的令牌模拟功能获取其他用户的令牌来创建进程。</p><p>这两类访问令牌只有在系统重启后才会清除，而授权令牌在用户注销后该令牌会变为模拟令牌，依旧有效。</p><p>因此在域渗透的过程中，我们常常发现域管理员登录了某些不安全的机器，会针对这些机器进行定向的攻击，获取机器权限后，寻找域管理员创建的进程，窃取访问令牌进而获取整个域的权限。</p><h3 id=正常情况下什么时候需要用到令牌模拟>正常情况下什么时候需要用到令牌模拟？</h3><p>例如，服务器应用程序为客户端提供某些服务，服务器需要以客户端的权限访问其他资源，这个时候就需要利用令牌模拟的功能。</p><p>进程令牌模拟的流程：</p><ol><li>调用OpenProcess获取进程句柄</li><li>调用OpenProcessToken，传入进程句柄获取访问令牌句柄</li><li>调用DuplicateTokenEx，设置访问令牌模拟级别并复制一个令牌句柄</li><li>调用CreateProcessWithToken，传入模拟令牌，创建一个新的进程达到代码执行的目的</li></ol><p>注意，要达到令牌窃取创建进程的效果需要有一些前提：</p><ul><li>当前用户必须拥有SeImpersonatePrivilege或SeAssignPrimaryTokenPrivilege特权</li><li>拥有目标进程的PROCESS_QUERY_INFORMATION权限</li><li>拥有目标进程访问令牌的<code>TOKEN_DUPLICATE | TOKEN_IMPERSONATE</code>权限</li></ul><p>Windows将每一个权限都以二进制位标示，但在C语言头文件中是以16禁止标示的。</p><p><img src=https://images.payloads.online/aa5f8a9c-4f5f-11ec-9212-00d861bf4abb.png alt=2021-01-31-22-10-47></p><p>两个权限的组合就是两个二进制数的与运算结果，由此可以看出Windows进程权限最大可以表示0xFFFF个，也就是2个字节，当然一般情况下用不到那么多。同时，我们也可以推断，任何可以设置权限的安全对象，想要设置全部权限<code>ALL_ACCESS</code>，可以全部用0xFFFFFFFF填充。</p><h2 id=0x08-进程注入process-inject>0x08 进程注入（Process Inject）</h2><p>进程注入是为了解决A进程想要在B进程的安全上下文中执行代码的技术手段。要完成一个进程注入需要A进程的访问令牌拥有B进程的权限。</p><p>进程注入的流程：</p><ol><li>调用OpenProcess获取进程句柄</li><li>调用WriteProcessMemory，传入进程句柄，向进程的虚拟内存空间写入Shellcode</li><li>调用CreateRemoteThread，传入进程句柄，创建远程线程</li></ol><p>场景：某些终端安全软件禁止用户转储lsass.exe进程内存，但我们可以先进程注入到lsass.exe，然后再转储内存。</p><p><img src=https://images.payloads.online/aa9a27d8-4f5f-11ec-b281-00d861bf4abb.png alt=2021-01-31-22-16-26></p><p>小技巧：有些软件在失败后返回一些数字，其实是Windows错误代码，我们可以通过<code>net helpmsg</code>命令来查看详情。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>net helpmsg &lt;错误代码&gt;
</span></span></code></pre></td></tr></table></div></div><p><img src=https://images.payloads.online/aace09a4-4f5f-11ec-a006-00d861bf4abb.png alt=2021-01-31-22-17-03></p><h2 id=0x09-文件的权限修改>0x09 文件的权限修改</h2><p>在Windows系统中，除了用户交互的窗口以外，还可以通过icacls命令修改文件的权限。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>icacls c:\windows\* /save AclFile /T
</span></span><span style=display:flex><span>  - 将 c:\windows 及其子目录下所有文件的ACL 保存到 AclFile。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  icacls c:\windows\ /restore AclFile
</span></span><span style=display:flex><span>  - 将还原 c:\windows 及其子目录下存在的 AclFile 内所有文件的 ACL。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  icacls file /grant Administrator:(D,WDAC)
</span></span><span style=display:flex><span>  - 将授予用户对文件删除和写入 DAC 的管理员权限。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  icacls file /grant *S-1-1-0:(D,WDAC)
</span></span><span style=display:flex><span>  - 将授予由 sid S-1-1-0 定义的用户对文件删除和写入 DAC 的权限。
</span></span></code></pre></td></tr></table></div></div><p>还可以查看文件的权限，例如常见的Shift后门：</p><p><img src=https://images.payloads.online/ab070f92-4f5f-11ec-a1c5-00d861bf4abb.png alt=2021-01-31-22-17-42></p><p>现如今普通用户，包括管理员、系统账户都不能随意更改这个文件了，能够看出Windows对这块有做加强。</p><h3 id=创建匿名共享>创建匿名共享</h3><p>在内网渗透中，经常会需要一个机器的共享作为中转，因此可以使用net share命令快速开启一个任意用户可读可写的共享。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>net share everyone=C:\Windows /grant:everyone,full
</span></span></code></pre></td></tr></table></div></div><p><img src=https://images.payloads.online/ab3ec108-4f5f-11ec-82f4-00d861bf4abb.png alt=2021-01-31-22-18-14></p><h2 id=0x10-创造提权漏洞服务后门>0x10 创造提权漏洞——服务后门</h2><p>前面提到可以通过API修改内核对象的ACL，那么是否可以通过代码帮助我们完成一些窗口无法做到的操作，例如：任意用户可以读写的内核对象。</p><p>我尝试过以下几种方案用作后门：</p><ol><li>注册表 成功</li><li>任务计划 失败</li><li>服务 成功</li><li>进程 失败</li></ol><p>服务是最容易被利用的，通常情况下，Guest用户是无法启动、创建服务的，通过修改某个服务的ACL，让Guest轻松创建以SYSTEM权限运行的进程。</p><p><img src=https://images.payloads.online/ab84c306-4f5f-11ec-ae41-00d861bf4abb.png alt=2021-01-31-22-19-00></p><p>由于Windows没有提供修改服务的窗口操作接口，所以按常规情况来看，上机查看的管理员不容易发现这类后门。</p><blockquote><p><a href=https://docs.microsoft.com/en-us/windows/win32/services/modifying-the-dacl-for-a-service>https://docs.microsoft.com/en-us/windows/win32/services/modifying-the-dacl-for-a-service</a></p></blockquote><p><img src=https://images.payloads.online/abc10a82-4f5f-11ec-8408-00d861bf4abb.png alt=2021-01-31-22-19-23></p><h3 id=powershell更改服务权限>Powershell更改服务权限</h3><p><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/set-service?view=powershell-7.1">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/set-service?view=powershell-7.1</a></p><p>使用Powershell修改服务的权限可以使用Set-Service：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>$SDDL = &#34;D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCLCSWLOCRRC;;;SU)&#34;
</span></span><span style=display:flex><span>Set-Service -Name &#34;BITS&#34; -SecurityDescriptorSddl $SDDL
</span></span></code></pre></td></tr></table></div></div><h3 id=cmd修改服务权限>CMD修改服务权限</h3><p>想象一个场景，如果随时都拥有一个服务器的权限，但是不能长时间登录某个特权账户，那么可以留置一个任意用户可以修改的系统服务，方便随时提权。</p><p><img src=https://images.payloads.online/ac1169be-4f5f-11ec-98c9-00d861bf4abb.png alt=2021-01-31-22-27-28></p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>sc setsd &lt;Service Name&gt; &lt;SDDL String&gt;
</span></span><span style=display:flex><span>sc sdset defragsvc &#34;D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)&#34;
</span></span></code></pre></td></tr></table></div></div><h2 id=0x11-windows域下的dcsync攻击及后门实现>0x11 Windows域下的DCSync攻击及后门实现</h2><p>DCSync是域控之间同步域数据的一个传递方式，一旦攻击者获取了具有域复制权限的特权帐户，攻击者就可以利用复制协议来模仿域控制器，诱使域控制器将域用户相关的数据发送出来。</p><p><img src=https://images.payloads.online/ac48005a-4f5f-11ec-be47-00d861bf4abb.png alt=2021-01-31-22-28-23></p><p>其中最核心的一步就是调用 <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-drsr/b63730ac-614c-431c-9501-28d6aca91894?redirectedfrom=MSDN">GetNCChanges</a> 复制用户凭据。</p><p>这篇文章中展示了更加详细的原理：<a href="https://adsecurity.org/?p=1729">《Mimikatz DCSync Usage, Exploitation, and Detection》</a></p><h3 id=哪些用户拥有域复制权限>哪些用户拥有域复制权限？</h3><ul><li>Administrators</li><li>Domain Admins</li><li>Enterprise Admins</li><li>&mldr;</li></ul><p>使用DcSync技术攻击的前提是获取域管理员权限。</p><h3 id=什么是域复制权限--域扩展权限>什么是域复制权限 — 域扩展权限</h3><p>Windows活动目录除了支持常规权限以外，还拥有自身对扩展权限，这些扩展权限与常规权限等效，主要是为了限定某些特殊的行为而制定的。</p><p>常规权限：</p><ul><li>读取</li><li>写入</li><li>执行</li></ul><p><a href=https://docs.microsoft.com/en-us/windows/win32/adschema/extended-rights>扩展权限（Extended Rights）</a>：</p><ol><li><strong><a href=https://docs.microsoft.com/en-us/windows/win32/adschema/r-allowed-to-authenticate>Allowed-To-Authenticate</a></strong></li><li><strong><a href=https://docs.microsoft.com/en-us/windows/win32/adschema/r-apply-group-policy>Apply-Group-Policy</a></strong></li><li><strong><a href=https://docs.microsoft.com/en-us/windows/win32/adschema/r-certificate-enrollment>Certificate-Enrollment</a></strong></li><li><strong><a href=https://docs.microsoft.com/en-us/windows/win32/adschema/r-change-domain-master>Change-Domain-Master</a></strong></li><li><strong><a href=https://docs.microsoft.com/en-us/windows/win32/adschema/r-change-infrastructure-master>Change-Infrastructure-Master</a></strong></li><li><strong><a href=https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes>DS-Replication-Get-Changes</a></strong></li><li><strong><a href=https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes-all>DS-Replication-Get-Changes-All</a></strong></li><li><a href=https://docs.microsoft.com/en-us/windows/win32/adschema/extended-rights>&mldr;</a></li></ol><h3 id=ds-replication-get-changes>DS-Replication-Get-Changes</h3><p>从指定NC复制更改所需的扩展权限。</p><p><img src=https://images.payloads.online/acb2c0c0-4f5f-11ec-be1f-00d861bf4abb.png alt=2021-01-31-22-29-40></p><p>为了方便未来扩展新的特性，每一个扩展权限都具有一个GUID值，如果要对域对象赋予这个权限，可以传入这个GUID值。GUID等效于权限常量。</p><p>DS-Replication-Get-Changes扩展权限支持的系统版本：</p><ul><li><strong><a href=https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes#windows-2000-server>Windows 2000 Server</a></strong></li><li><strong><a href=https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes#windows-server-2003>Windows Server 2003</a></strong></li><li><strong><a href=https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes#adam>ADAM</a></strong></li><li><strong><a href=https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes#windows-server-2003-r2>Windows Server 2003 R2</a></strong></li><li><strong><a href=https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes#windows-server-2008>Windows Server 2008</a></strong></li><li><strong><a href=https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes#windows-server-2008-r2>Windows Server 2008 R2</a></strong></li><li><strong><a href=https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes#windows-server-2012>Windows Server 2012</a></strong></li></ul><h3 id=dcsync后门实现>DcSync后门实现</h3><p>通过调用活动目录自身独有的COM组件接口，可以获取域对象的安全描述符，修改方式与本地修改ACL没有太多差别。</p><p><a href=https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1#L8270>Powerview</a>实现了Powershell版本的DCSync后门植入：</p><p><img src=https://images.payloads.online/acece174-4f5f-11ec-991c-00d861bf4abb.png alt=2021-01-31-22-30-43></p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Add<span style=color:#f92672>-</span>DomainObjectAcl <span style=color:#f92672>-</span>TargetIdentity <span style=color:#e6db74>&#34;DC=Domain,DC=com&#34;</span> <span style=color:#f92672>-</span>PrincipalIdentity <span style=color:#f92672>&lt;</span>UserName<span style=color:#f92672>&gt;</span> <span style=color:#f92672>-</span>Rights DCSync <span style=color:#f92672>-</span>Verbose
</span></span></code></pre></td></tr></table></div></div><p>我这里实现了一个C++版本的：<a href=https://github.com/Rvn0xsy/PDacl>https://github.com/Rvn0xsy/PDacl</a></p><p><img src=https://images.payloads.online/ad26d0be-4f5f-11ec-aa64-00d861bf4abb.png alt=2021-01-31-22-33-32></p><p><img src=https://images.payloads.online/ad79864c-4f5f-11ec-90cc-00d861bf4abb.png alt=2021-01-31-22-33-58></p><p>在Cobalt Strike中以普通用户权限转储NTLM验证成功：</p><p><img src=https://images.payloads.online/adbf79e0-4f5f-11ec-8d7f-00d861bf4abb.png alt=2021-01-31-22-34-59></p><p>C++实现过程：</p><ul><li>获取IADsSecurityDescriptor接口指针</li><li>获取IADsAccessControlList接口指针</li><li>获取IADsAccessControlEntry接口指针</li><li>调用IADsAccessControlList::AddAce添加ACE</li><li>调用IADs::put更新</li></ul><p>由于涉及到COM组件对象，所以过程比较繁琐。</p><h3 id=dcsync权限检测>DCSync权限检测</h3><p><a href=https://github.com/cyberark/ACLight>https://github.com/cyberark/ACLight</a> 能够列出所有用户的ACL，可以根据结果进行匹配DS-Replication-Get-Changes权限。</p><h2 id=参考>参考</h2><ul><li><a href=https://docs.microsoft.com/en-us/windows/win32/api/iads/ne-iads-ads_rights_enum>https://docs.microsoft.com/en-us/windows/win32/api/iads/ne-iads-ads_rights_enum</a></li><li><a href=https://docs.microsoft.com/en-us/windows/win32/ad/example-code-for-setting-a-control-access-right-ace>https://docs.microsoft.com/en-us/windows/win32/ad/example-code-for-setting-a-control-access-right-ace</a></li><li><a href=https://stealthbits.com/blog/what-is-dcsync-an-introduction/>https://stealthbits.com/blog/what-is-dcsync-an-introduction/</a></li><li><a href=https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1#L8270>https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1#L8270</a></li><li><a href=https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes>https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes</a></li><li><a href=https://3gstudent.github.io/3gstudent.github.io/>https://3gstudent.github.io/3gstudent.github.io/</a>域渗透-DCSync/</li><li><a href=https://docs.microsoft.com/en-us/windows/win32/ad/how-security-descriptors-are-set-on-new-directory-objects>https://docs.microsoft.com/en-us/windows/win32/ad/how-security-descriptors-are-set-on-new-directory-objects</a></li><li><a href=https://docs.microsoft.com/en-us/windows/win32/api/iads/nf-iads-iadssecuritydescriptor-copysecuritydescriptor>https://docs.microsoft.com/en-us/windows/win32/api/iads/nf-iads-iadssecuritydescriptor-copysecuritydescriptor</a></li><li><a href=https://docs.microsoft.com/en-us/windows/win32/api/_adsi/>https://docs.microsoft.com/en-us/windows/win32/api/_adsi/</a></li><li><a href=http://systemmanager.ru/adam-sdk.en/ad/setting_access_rights_on_an_object.htm>http://systemmanager.ru/adam-sdk.en/ad/setting_access_rights_on_an_object.htm</a></li><li><a href=https://docs.microsoft.com/en-us/windows/win32/secauthz/order-of-aces-in-a-dacl>https://docs.microsoft.com/en-us/windows/win32/secauthz/order-of-aces-in-a-dacl</a></li><li><a href=https://www.installsetupconfig.com/win32programming/accesscontrollistacl1_1.html>https://www.installsetupconfig.com/win32programming/accesscontrollistacl1_1.html</a></li><li><a href=https://docs.microsoft.com/en-us/windows/win32/secbp/creating-a-dacl>https://docs.microsoft.com/en-us/windows/win32/secbp/creating-a-dacl</a></li><li><a href=https://docs.microsoft.com/en-us/windows/win32/secauthz/security-descriptor-string-format>https://docs.microsoft.com/en-us/windows/win32/secauthz/security-descriptor-string-format</a></li><li><a href=https://docs.microsoft.com/en-us/windows/win32/api/iads/nf-iads-iadsaccesscontrollist-addace>https://docs.microsoft.com/en-us/windows/win32/api/iads/nf-iads-iadsaccesscontrollist-addace</a></li><li><a href=https://docs.microsoft.com/en-us/windows/win32/secauthz/modifying-the-acls-of-an-object-in-c-->https://docs.microsoft.com/en-us/windows/win32/secauthz/modifying-the-acls-of-an-object-in-c--</a></li></ul></div><nav class="hide-on-mobile section-nav"><nav id=TableOfContents><ol><li><a href=#0x00-前言>0x00 前言</a></li><li><a href=#0x01-安全描述符security-descriptorssd>0X01 安全描述符(Security Descriptors，SD)</a><ol><li><a href=#windows具体有哪些安全对象>Windows具体有哪些安全对象？</a></li></ol></li><li><a href=#0x02-安全描述符的组成>0x02 安全描述符的组成</a><ol><li><a href=#什么是sidsecurity-identifiersid>什么是SID（Security Identifier，SID）</a></li><li><a href=#相对标识符relative-identifer-rid>相对标识符(Relative Identifer, RID)</a></li></ol></li><li><a href=#0x03-自主访问控制列表discretionary-access-control-listdacl>0x03 自主访问控制列表（Discretionary access control list，DACL）</a></li><li><a href=#0x04-系统访问控制列表system-access-control-listsacl>0x04 系统访问控制列表（System access control list，SACL）</a></li><li><a href=#0x05-修改访问控制列表access-control-listacl>0x05 修改访问控制列表（Access control list，ACL）</a><ol><li><a href=#null-dacl和空dacl>NULL DACL和空DACL</a></li></ol></li><li><a href=#0x06-土豆potato提权的本质与进程访问控制>0x06 土豆（Potato）提权的本质与进程访问控制</a></li><li><a href=#0x07-访问令牌模拟access-token-impersonation>0x07 访问令牌模拟（Access Token Impersonation）</a><ol><li><a href=#正常情况下什么时候需要用到令牌模拟>正常情况下什么时候需要用到令牌模拟？</a></li></ol></li><li><a href=#0x08-进程注入process-inject>0x08 进程注入（Process Inject）</a></li><li><a href=#0x09-文件的权限修改>0x09 文件的权限修改</a><ol><li><a href=#创建匿名共享>创建匿名共享</a></li></ol></li><li><a href=#0x10-创造提权漏洞服务后门>0x10 创造提权漏洞——服务后门</a><ol><li><a href=#powershell更改服务权限>Powershell更改服务权限</a></li><li><a href=#cmd修改服务权限>CMD修改服务权限</a></li></ol></li><li><a href=#0x11-windows域下的dcsync攻击及后门实现>0x11 Windows域下的DCSync攻击及后门实现</a><ol><li><a href=#哪些用户拥有域复制权限>哪些用户拥有域复制权限？</a></li><li><a href=#什么是域复制权限--域扩展权限>什么是域复制权限 — 域扩展权限</a></li><li><a href=#ds-replication-get-changes>DS-Replication-Get-Changes</a></li><li><a href=#dcsync后门实现>DcSync后门实现</a></li><li><a href=#dcsync权限检测>DCSync权限检测</a></li></ol></li><li><a href=#参考>参考</a></li></ol></nav></nav></div><div class=post><hr class=footer-separator><div class=tags></div><div class=back><a href=https://payloads.online/><span aria-hidden=true>← Back</span></a></div><div class=back></div></div><div class=post></div></div><div class="footer wrapper"><nav class=nav><div>2024 倾旋 All rights reserved</div></nav></div><script>feather.replace()</script><script>var enableTruncate=!0,filterDepth=!1;const MAX_DEPTH=9;window.addEventListener("DOMContentLoaded",()=>{const e=new IntersectionObserver(e=>{e.reverse().forEach(e=>{const n=e.target.getAttribute("id");if(e.intersectionRatio>0){var t=document.querySelectorAll(`nav li a[href="#${n}"]`);t!=null&&t.forEach(e=>{if(e!=null){var t=getDepth(e.parentElement);filterDepth&&t<=MAX_DEPTH&&(clearActiveStatesInTableOfContents(),e.parentElement.classList.add("active"))}else filterDepth||(clearActiveStatesInTableOfContents(),e.parentElement.classList.add("active"))})}})});document.querySelectorAll("h1[id],h2[id],h3[id],h4[id]").forEach(t=>{e.observe(t)})});function isVisible(e){if(!(e instanceof Element))return!1;const n=getComputedStyle(e);if(n.display==="none")return!1;if(n.visibility!=="visible")return!1;if(n.opacity<.1)return!1;if(e.offsetWidth+e.offsetHeight+e.getBoundingClientRect().height+e.getBoundingClientRect().width===0)return!1;const t={x:e.getBoundingClientRect().left+e.offsetWidth/2,y:e.getBoundingClientRect().top+e.offsetHeight/2};if(t.x<0)return!1;if(t.x>(document.documentElement.clientWidth||window.innerWidth))return!1;if(t.y<0)return!1;if(t.y>(document.documentElement.clientHeight||window.innerHeight))return!1;let s=document.elementFromPoint(t.x,t.y);do if(s===e)return!0;while(s=s.parentNode)return!1}function clearActiveStatesInTableOfContents(){document.querySelectorAll("nav li").forEach(e=>{e.classList.remove("active")})}function getDepth(e){for(var t=0;e!==null&&e.tagName.toLowerCase()!=="ul";)t++,e=e.parentElement;return t}function navItems(){var e=document.querySelectorAll("nav nav li a");return Array.from(e).filter(e=>e.href!=null&&e.hash.startsWith("#"))}function lasItemInNavBarVisible(){var e=navItems().slice(-1)[0];return isVisible(e)}document.addEventListener("DOMContentLoaded",function(){if(!enableTruncate)return;var e=navItems();console.log(e),lasItemInNavBarVisible()||(filterDepth=!0,e.forEach(function(e){var t=getDepth(e.parentElement);t>MAX_DEPTH&&e.parentElement.classList.add("depth-nested")}))})</script></body></html>