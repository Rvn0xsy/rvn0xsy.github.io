<!DOCTYPE html>
<html lang=""><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>Windows权限控制相关的防御与攻击技术</title>
    <meta name="description" content="倾旋的博客">
    <meta name="author" content='倾旋'>

    <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous">

    
    <link rel="stylesheet" href="/sass/researcher.min.css">

    
        <link rel="icon" type="image/ico" href="https://payloads.online/favicon.ico">
    

    
        
    
</head>

    <body><div class="container mt-5">
    <nav class="navbar navbar-expand-sm flex-column flex-sm-row text-nowrap p-0">
        <a class="navbar-brand mx-0 mr-sm-auto" style="color: #dc3545;" href="https://payloads.online" title="倾旋的博客">
          
          倾旋的博客
        </a>
        <div class="navbar-nav flex-row flex-wrap justify-content-center">
            
                
                
                    <a class="nav-item nav-link" href="/about" title="About">
                        About
                    </a>
                    
                        <span class="nav-item navbar-text mx-1">/</span>
                    
                
                    <a class="nav-item nav-link" href="/links/" title="Links">
                        Links
                    </a>
                    
                        <span class="nav-item navbar-text mx-1">/</span>
                    
                
                    <a class="nav-item nav-link" href="/post/" title="Posts">
                        Posts
                    </a>
                    
                        <span class="nav-item navbar-text mx-1">/</span>
                    
                
                    <a class="nav-item nav-link" href="/index.xml" title="Rss">
                        Rss
                    </a>
                    
                
            
        </div>
    </nav>
</div>
<hr>
<div id="content">
<div class="container">
    <h2 id="0x00-前言">0x00 前言</h2>
<p>近年来终端安全检测与响应的产品发展迅速，我们不得不意识到，安全是在一个循环中发展的，从人们意识到安全开始，大部分了解到层面都是病毒、木马，然后接着是浏览器相关的Web安全领域，最后又开始回到终端。这个议题我们通过了解Windows操作系统下的访问控制技术，站在攻防的不同角度去进行对抗，提升自身的知识储备，个人觉得这些知识适用于许多使用Windows操作系统的用户。</p>
<h2 id="0x01-安全描述符security-descriptorssd">0X01 安全描述符(Security Descriptors，SD)</h2>
<p>在Windows中，每一个安全对象实体都拥有一个安全描述符，安全描述符包含了被保护对象相关联的安全信息的数据结构，它的作用主要是为了给操作系统提供判断来访对象的权限。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#ae81ff">0</span><span style="color:#f92672">:</span><span style="color:#ae81ff">000</span><span style="color:#f92672">&gt;</span> dt nt<span style="color:#f92672">!</span>_security_descriptor
ntdll<span style="color:#f92672">!</span>_SECURITY_DESCRIPTOR
   <span style="color:#f92672">+</span><span style="color:#ae81ff">0x000</span> Revision         : UChar  <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#960050;background-color:#1e0010">版本</span>
   <span style="color:#f92672">+</span><span style="color:#ae81ff">0x001</span> Sbz1             : UChar  <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#960050;background-color:#1e0010">大小</span>
   <span style="color:#f92672">+</span><span style="color:#ae81ff">0x002</span> Control          : Uint2B <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#960050;background-color:#1e0010">一组标志，用于限定安全描述符或安全描述符的各个字段的含义</span>
   <span style="color:#f92672">+</span><span style="color:#ae81ff">0x008</span> Owner            : Ptr64 Void <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#960050;background-color:#1e0010">指定对象的所有者（</span>SID<span style="color:#960050;background-color:#1e0010">）</span>
   <span style="color:#f92672">+</span><span style="color:#ae81ff">0x010</span> Group            : Ptr64 Void <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#960050;background-color:#1e0010">指定对象的主组（</span>SID<span style="color:#960050;background-color:#1e0010">）</span>
   <span style="color:#f92672">+</span><span style="color:#ae81ff">0x018</span> Sacl             : Ptr64 _ACL <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#960050;background-color:#1e0010">系统访问控制列表</span>
   <span style="color:#f92672">+</span><span style="color:#ae81ff">0x020</span> Dacl             : Ptr64 _ACL <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#960050;background-color:#1e0010">自主访问控制列表</span>
</code></pre></div><h3 id="windows具体有哪些安全对象">Windows具体有哪些安全对象？</h3>
<ul>
<li>进程</li>
<li>线程</li>
<li>文件</li>
<li>服务</li>
<li>计划任务</li>
<li>互斥体</li>
<li>管道</li>
<li>油槽</li>
<li>文件共享</li>
<li>访问令牌</li>
<li>注册表</li>
<li>打印机</li>
<li>作业</li>
<li>&hellip;</li>
</ul>
<p>一般情况下，大部分用户接触更多的可能就是文件了，我们就以文件开始，文件对于我们去学习访问控制是最直观的。</p>
<p>一个文件的权限描述符主要表现为：</p>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/3323c6ebb98e236818e517c6f12cc6ad.png" alt="2021-01-31-21-43-05"></p>
<p>上图中的安全选项卡主要是表述了sethc.exe这个文件能够被哪些用户访问，并且这些用户拥有sethc.exe的哪些权限，如：读取、读取和执行、写入、完全控制等。</p>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/745e9f6efd7a9f9598d3f8648355b846.png" alt="2021-01-31-21-44-40"></p>
<h2 id="0x02-安全描述符的组成">0x02 安全描述符的组成</h2>
<p>DACL通过一系列ACE定义了所有被允许或者禁止的安全对象的访问者，SACL描述了系统应该审核的内容，系统会根据审核项产生对应的系统日志。</p>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/17139925a0e99f7f36e652bb5edb680d.png" alt="2021-01-31-21-45-22"></p>
<blockquote>
<p>权限选项卡代表了 DACL，审核选项卡代表了 SACL。</p>
</blockquote>
<h3 id="什么是sidsecurity-identifiersid">什么是SID（Security Identifier，SID）</h3>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/3689a630b8ae676d5f75b65e4bd985f1.png" alt="2021-01-31-21-49-18"></p>
<p>每个参与权限决策的角色都拥有一个SID，这个SID为了保证角色的唯一性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">S<span style="color:#f92672">-</span>[<span style="color:#960050;background-color:#1e0010">修订级别</span>]<span style="color:#f92672">-</span>[<span style="color:#960050;background-color:#1e0010">权值</span>]<span style="color:#f92672">-</span>[<span style="color:#960050;background-color:#1e0010">标识符</span>]
</code></pre></div><p>SID分为两种：</p>
<ul>
<li>内置SID</li>
<li>自动分配SID</li>
</ul>
<p>内置SID有：</p>
<ul>
<li>S-1-5-18 (LocalSystem)</li>
<li>S-1-5-19 (LocalService)</li>
<li>S-1-5-20 (NetworkService)</li>
<li>S-1-5-32-544 (Administrators)</li>
<li>S-1-5-32-545 (Users)</li>
<li>S-1-5-32-550 (PrintOperators)</li>
<li>&hellip;</li>
</ul>
<h3 id="相对标识符relative-identifer-rid">相对标识符(Relative Identifer, RID)</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">S<span style="color:#f92672">-</span>[<span style="color:#960050;background-color:#1e0010">修订级别</span>]<span style="color:#f92672">-</span>[<span style="color:#960050;background-color:#1e0010">权值</span>]<span style="color:#f92672">-</span>[<span style="color:#960050;background-color:#1e0010">标识符</span>]<span style="color:#f92672">-</span>[<span style="color:#960050;background-color:#1e0010">相对标识符</span>]
</code></pre></div><p>例如：</p>
<ul>
<li>S-1-5-21-xxxx-xxx-500 (Administrator) 本地管理员</li>
<li>S-1-5-21-xxxx-xxx-501 (Guest) 本地来宾用户</li>
<li>S-1-5-21-xxxx-xxx-1004 (Workstaion) 本地工作站</li>
</ul>
<p>其中RID为<code>500</code>的用户代表管理员用户，账户个RID值是固定的，通常渗透中常说的RID劫持、克隆用户就是修改其他用户的RID值来实现让系统认为当前用户是管理员。</p>
<h2 id="0x03-自主访问控制列表discretionary-access-control-listdacl">0x03 自主访问控制列表（Discretionary access control list，DACL）</h2>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/8db54a1d87fe185b5d14e0146c79f426.png" alt="2021-01-31-21-51-33"></p>
<p>解读：每一个Windows进程都拥有一个线程，当程序想要访问某个安全对象时，系统会提取当前线程的访问令牌，然后将访问令牌的权限和被访问的安全对象DACL进行比较。</p>
<ul>
<li>
<p>Thread A拥有Adrew的访问令牌，当它访问对象Object的时候，系统会从DACL第一个条目开始向下比对，由于第一个ACE是Access denied，并且用户名恰巧是Adrew，因此系统会拒绝访问，返回错误代码5。</p>
</li>
<li>
<p>Thread B拥有Jane的访问令牌，当它访问对象Object的时候，系统会从DACL第一个条目开始向下比对，由于第一个ACE不是针对Jane设置的，因此会继续向下比对，当到达第二个ACE时，Jane属于Group A，满足比对条件，因此拥有Write的权限。到达第三个时，如果Jane想要的是读取，那么也会在到达第三个ACE后，获得读取的权限。</p>
</li>
</ul>
<p>这张图很清晰的描述了一个线程访问系统安全对象的过程，也能够帮我们更清楚的理解令牌窃取、假冒的原理。</p>
<blockquote>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/how-dacls-control-access-to-an-object">https://docs.microsoft.com/en-us/windows/win32/secauthz/how-dacls-control-access-to-an-object</a></p>
</blockquote>
<p>当一个线程访问安全对象时，操作系统会将访问令牌的属性与被访问对象安全描述符中的DACL进行检查，检查的条目就是访问控制条目（Access control entries，ACE），最先检查的ACE优先级越高。</p>
<h2 id="0x04-系统访问控制列表system-access-control-listsacl">0x04 系统访问控制列表（System access control list，SACL）</h2>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/c4e7d07554bcd96d6aef3489929148f0.png" alt="2021-01-31-22-00-15"></p>
<p>系统访问控制列表主要是配置审核对象的ACE，当这些ACE被允许或拒绝的时候，系统将自动产生“安全”日志。</p>
<p>图中设置了Service.log的SACL，当它的DACL被改变成功后，操作系统会自动帮助我们产生一条安全日志，我们可以提取其中的关键信息，如：</p>
<ul>
<li>时间</li>
<li>访问的进程</li>
<li>访问的线程ID</li>
<li>访问的计算机</li>
<li>访问的用户名等</li>
<li>&hellip;</li>
</ul>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/e41d8ccd2e17b4e593b8c2afadd55b59.png" alt="2021-01-31-22-03-10"></p>
<h2 id="0x05-修改访问控制列表access-control-listacl">0x05 修改访问控制列表（Access control list，ACL）</h2>
<p>在Windows中，修改内核对象的方法只有调用API，因此，可以将安全描述符也理解为一个内核对象的属性。</p>
<p>以下是修改ACL的简要过程：</p>
<ol>
<li>使用 <strong><a href="https://docs.microsoft.com/en-us/windows/desktop/api/Aclapi/nf-aclapi-getsecurityinfo">GetSecurityInfo</a></strong> 或者 <strong><a href="https://docs.microsoft.com/en-us/windows/desktop/api/Aclapi/nf-aclapi-getnamedsecurityinfoa">GetNamedSecurityInfo</a></strong> 函数从对象的<a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/s-gly">安全描述符</a>中获取DACL。</li>
<li>对于每个新的ACE，请调用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/Aclapi/nf-aclapi-buildexplicitaccesswithnamea">BuildExplicitAccessWithName</a>函数以使用描述ACE的信息填充<a href="https://docs.microsoft.com/en-us/windows/desktop/api/AccCtrl/ns-accctrl-explicit_access_a">EXPLICIT_ACCESS</a>结构。</li>
<li>调用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/Aclapi/nf-aclapi-setentriesinacla">SetEntriesInAcl</a>，为新ACE指定现有的ACL和<a href="https://docs.microsoft.com/en-us/windows/desktop/api/AccCtrl/ns-accctrl-explicit_access_a">EXPLICIT_ACCESS</a>结构的数组。SetEntriesInAcl函数分配和初始化的ACL和的ACE。</li>
<li>调用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/Aclapi/nf-aclapi-setsecurityinfo">SetSecurityInfo</a>或<a href="https://docs.microsoft.com/en-us/windows/desktop/api/Aclapi/nf-aclapi-setnamedsecurityinfoa">SetNamedSecurityInfo</a>函数，将新的ACL附加到对象的安全描述符。</li>
</ol>
<p>下方的链接提供了一个简单的例子：</p>
<blockquote>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/creating-or-modifying-an-acl">https://docs.microsoft.com/en-us/windows/win32/secauthz/creating-or-modifying-an-acl</a></p>
</blockquote>
<h3 id="null-dacl和空dacl">NULL DACL和空DACL</h3>
<p>如果属于对象的安全描述符的自由访问控制列表（Discretionary access control list，DACL）设置为NULL，则会创建一个NULL DACL。NULL DACL授予对请求它的任何用户的完全访问权限，不对该对象执行正常的安全检查。</p>
<p>NULL的DACL与空的DACL是有区别的，空DACL是正确分配和初始化的DACL，其中不包含访问控制项（Access control entries，ACE），任何对象都不允许访问。</p>
<p>我发现两个有趣的事情：</p>
<ol>
<li>如果我将lsass.exe进程的DACL设置为NULL，我发现在系统重启后，再也启动不起来了，一直循环蓝屏。</li>
<li>如果我将lsass.exe进程的DACL设置为空，我发现即便是以Guest用户登录，也不能轻易的转储lsass.exe的内存。应该是有某些保护机制。</li>
</ol>
<h2 id="0x06-土豆potato提权的本质与进程访问控制">0x06 土豆（Potato）提权的本质与进程访问控制</h2>
<p>土豆系列的提权原理主要是诱导高权限访问低权限的系统对象，导致低权限的对象可以模拟高权限对象的访问令牌（Access Token），进而可以用访问令牌创建进程，达到代码执行。</p>
<p><a href="https://payloads.online/archivers/2020-03-21/1">《Windows特权提升漏洞-符号》</a> 提到过：访问控制模型有两个主要的组成部分，访问令牌（Access Token）和安全描述符（Security Descriptor），它们分别是访问者和被访问者拥有的东西。通过访问令牌和安全描述符的内容，Windows可以确定持有令牌的访问者能否访问持有安全描述符的对象。</p>
<ul>
<li>烂土豆(Rotten Potato)提权MS16-075</li>
</ul>
<p><a href="https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2016/ms16-075">https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2016/ms16-075</a></p>
<ul>
<li><a href="https://itm4n.github.io/cve-2020-0668-windows-service-tracing-eop/">CVE-2020-0668</a></li>
<li><a href="https://www.youtube.com/watch?v=1axTbxPz2_8">CVE-2020-0683 MSI Packages Symbolic Links Processing - Windows 10 Privilege Escalation</a></li>
<li><a href="https://github.com/nomi-sec/PoC-in-GitHub#cve-2020-8950">CVE-2020-8950</a></li>
<li><a href="https://github.com/nomi-sec/PoC-in-GitHub#cve-2020-0686">CVE-2020-0683</a></li>
<li><a href="https://github.com/nomi-sec/PoC-in-GitHub#cve-2019-1002101">CVE-2019-1002101</a></li>
<li><a href="https://github.com/nomi-sec/PoC-in-GitHub#cve-2019-0986">CVE-2019-0986</a></li>
<li><a href="https://github.com/nomi-sec/PoC-in-GitHub#cve-2018-1088">CVE-2018-1088</a></li>
<li>&hellip;.</li>
</ul>
<p>这些漏洞要么是利用巧妙的手法获取令牌、要么是用高权限移动文件，因此用户层的提权漏洞大多都需要系统“主动”起来。</p>
<h2 id="0x07-访问令牌模拟access-token-impersonation">0x07 访问令牌模拟（Access Token Impersonation）</h2>
<p>Windows 的令牌类型：</p>
<ol>
<li>主令牌（Primary Token）</li>
<li>模拟令牌（Impersonation Token）</li>
</ol>
<p>渗透中常说的令牌假冒、令牌窃取都是利用Windows的令牌模拟功能获取其他用户的令牌来创建进程。</p>
<p>这两类访问令牌只有在系统重启后才会清除，而授权令牌在用户注销后该令牌会变为模拟令牌，依旧有效。</p>
<p>因此在域渗透的过程中，我们常常发现域管理员登录了某些不安全的机器，会针对这些机器进行定向的攻击，获取机器权限后，寻找域管理员创建的进程，窃取访问令牌进而获取整个域的权限。</p>
<h3 id="正常情况下什么时候需要用到令牌模拟">正常情况下什么时候需要用到令牌模拟？</h3>
<p>例如，服务器应用程序为客户端提供某些服务，服务器需要以客户端的权限访问其他资源，这个时候就需要利用令牌模拟的功能。</p>
<p>进程令牌模拟的流程：</p>
<ol>
<li>调用OpenProcess获取进程句柄</li>
<li>调用OpenProcessToken，传入进程句柄获取访问令牌句柄</li>
<li>调用DuplicateTokenEx，设置访问令牌模拟级别并复制一个令牌句柄</li>
<li>调用CreateProcessWithToken，传入模拟令牌，创建一个新的进程达到代码执行的目的</li>
</ol>
<p>注意，要达到令牌窃取创建进程的效果需要有一些前提：</p>
<ul>
<li>当前用户必须拥有SeImpersonatePrivilege或SeAssignPrimaryTokenPrivilege特权</li>
<li>拥有目标进程的PROCESS_QUERY_INFORMATION权限</li>
<li>拥有目标进程访问令牌的<code>TOKEN_DUPLICATE | TOKEN_IMPERSONATE</code>权限</li>
</ul>
<p>Windows将每一个权限都以二进制位标示，但在C语言头文件中是以16禁止标示的。</p>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/53e19171b35c621ca5d52a338cd04f2a.png" alt="2021-01-31-22-10-47"></p>
<p>两个权限的组合就是两个二进制数的与运算结果，由此可以看出Windows进程权限最大可以表示0xFFFF个，也就是2个字节，当然一般情况下用不到那么多。同时，我们也可以推断，任何可以设置权限的安全对象，想要设置全部权限<code>ALL_ACCESS</code>，可以全部用0xFFFFFFFF填充。</p>
<h2 id="0x08-进程注入process-inject">0x08 进程注入（Process Inject）</h2>
<p>进程注入是为了解决A进程想要在B进程的安全上下文中执行代码的技术手段。要完成一个进程注入需要A进程的访问令牌拥有B进程的权限。</p>
<p>进程注入的流程：</p>
<ol>
<li>调用OpenProcess获取进程句柄</li>
<li>调用WriteProcessMemory，传入进程句柄，向进程的虚拟内存空间写入Shellcode</li>
<li>调用CreateRemoteThread，传入进程句柄，创建远程线程</li>
</ol>
<p>场景：某些终端安全软件禁止用户转储lsass.exe进程内存，但我们可以先进程注入到lsass.exe，然后再转储内存。</p>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/1295bf932f2f68f39bc801ab2685f4e2.png" alt="2021-01-31-22-16-26"></p>
<p>小技巧：有些软件在失败后返回一些数字，其实是Windows错误代码，我们可以通过<code>net helpmsg</code>命令来查看详情。</p>
<pre><code>net helpmsg &lt;错误代码&gt;
</code></pre><p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/d0a32acc8540964e278cadc2b4ebc1ef.png" alt="2021-01-31-22-17-03"></p>
<h2 id="0x09-文件的权限修改">0x09 文件的权限修改</h2>
<p>在Windows系统中，除了用户交互的窗口以外，还可以通过icacls命令修改文件的权限。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">icacls c:<span style="color:#960050;background-color:#1e0010">\</span>windows<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#f92672">*</span> <span style="color:#f92672">/</span>save AclFile <span style="color:#f92672">/</span>T
  <span style="color:#f92672">-</span> <span style="color:#960050;background-color:#1e0010">将</span> c:<span style="color:#960050;background-color:#1e0010">\</span>windows <span style="color:#960050;background-color:#1e0010">及其子目录下所有文件的</span>
     ACL <span style="color:#960050;background-color:#1e0010">保存到</span> AclFile<span style="color:#960050;background-color:#1e0010">。</span>

  icacls c:<span style="color:#960050;background-color:#1e0010">\</span>windows<span style="color:#960050;background-color:#1e0010">\</span> <span style="color:#f92672">/</span>restore AclFile
  <span style="color:#f92672">-</span> <span style="color:#960050;background-color:#1e0010">将还原</span> c:<span style="color:#960050;background-color:#1e0010">\</span>windows <span style="color:#960050;background-color:#1e0010">及其子目录下存在的</span> AclFile <span style="color:#960050;background-color:#1e0010">内</span>
    <span style="color:#960050;background-color:#1e0010">所有文件的</span> ACL<span style="color:#960050;background-color:#1e0010">。</span>

  icacls file <span style="color:#f92672">/</span>grant Administrator:(D,WDAC)
  <span style="color:#f92672">-</span> <span style="color:#960050;background-color:#1e0010">将授予用户对文件删除和写入</span> DAC <span style="color:#960050;background-color:#1e0010">的管理员权限。</span>

  icacls file <span style="color:#f92672">/</span>grant <span style="color:#f92672">*</span>S<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0</span><span style="color:#f92672">:</span>(D,WDAC)
  <span style="color:#f92672">-</span> <span style="color:#960050;background-color:#1e0010">将授予由</span> sid S<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0</span> <span style="color:#960050;background-color:#1e0010">定义的用户对文件删除和写入</span> DAC <span style="color:#960050;background-color:#1e0010">的权限。</span>
</code></pre></div><p>还可以查看文件的权限，例如常见的Shift后门：</p>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/a51beeb1dc8a459081c277b5d73055dd.png" alt="2021-01-31-22-17-42"></p>
<p>现如今普通用户，包括管理员、系统账户都不能随意更改这个文件了，能够看出Windows对这块有做加强。</p>
<h3 id="创建匿名共享">创建匿名共享</h3>
<p>在内网渗透中，经常会需要一个机器的共享作为中转，因此可以使用net share命令快速开启一个任意用户可读可写的共享。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">net share everyone<span style="color:#f92672">=</span>C:<span style="color:#960050;background-color:#1e0010">\</span>Windows <span style="color:#f92672">/</span>grant:everyone,full
</code></pre></div><p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/36fa07c6a69d5488ae07ff181e1e9a1d.png" alt="2021-01-31-22-18-14"></p>
<h2 id="0x10-创造提权漏洞服务后门">0x10 创造提权漏洞——服务后门</h2>
<p>前面提到可以通过API修改内核对象的ACL，那么是否可以通过代码帮助我们完成一些窗口无法做到的操作，例如：任意用户可以读写的内核对象。</p>
<p>我尝试过以下几种方案用作后门：</p>
<ol>
<li>注册表 成功</li>
<li>任务计划 失败</li>
<li>服务 成功</li>
<li>进程 失败</li>
</ol>
<p>服务是最容易被利用的，通常情况下，Guest用户是无法启动、创建服务的，通过修改某个服务的ACL，让Guest轻松创建以SYSTEM权限运行的进程。</p>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/a133d4e2a6c445e6d8c6d0958e0896aa.png" alt="2021-01-31-22-19-00"></p>
<p>由于Windows没有提供修改服务的窗口操作接口，所以按常规情况来看，上机查看的管理员不容易发现这类后门。</p>
<blockquote>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/services/modifying-the-dacl-for-a-service">https://docs.microsoft.com/en-us/windows/win32/services/modifying-the-dacl-for-a-service</a></p>
</blockquote>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/9c9018725dd03ebfa7c65a35af351b2b.png" alt="2021-01-31-22-19-23"></p>
<h3 id="powershell更改服务权限">Powershell更改服务权限</h3>
<p><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/set-service?view=powershell-7.1">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/set-service?view=powershell-7.1</a></p>
<p>使用Powershell修改服务的权限可以使用Set-Service：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#960050;background-color:#1e0010">$</span>SDDL <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCLCSWLOCRRC;;;SU)&#34;</span>
Set<span style="color:#f92672">-</span>Service <span style="color:#f92672">-</span>Name <span style="color:#e6db74">&#34;BITS&#34;</span> <span style="color:#f92672">-</span>SecurityDescriptorSddl <span style="color:#960050;background-color:#1e0010">$</span>SDDL
</code></pre></div><h3 id="cmd修改服务权限">CMD修改服务权限</h3>
<p>想象一个场景，如果随时都拥有一个服务器的权限，但是不能长时间登录某个特权账户，那么可以留置一个任意用户可以修改的系统服务，方便随时提权。</p>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/15e51162189ade667eab88c3dee28e33.png" alt="2021-01-31-22-27-28"></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">sc setsd <span style="color:#f92672">&lt;</span>Service Name<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span>SDDL String<span style="color:#f92672">&gt;</span>
sc sdset defragsvc <span style="color:#e6db74">&#34;D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)&#34;</span>
</code></pre></div><h2 id="0x11-windows域下的dcsync攻击及后门实现">0x11 Windows域下的DCSync攻击及后门实现</h2>
<p>DCSync是域控之间同步域数据的一个传递方式，一旦攻击者获取了具有域复制权限的特权帐户，攻击者就可以利用复制协议来模仿域控制器，诱使域控制器将域用户相关的数据发送出来。</p>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/096326c7f2f688515dfa17874be3f91c.png" alt="2021-01-31-22-28-23"></p>
<p>其中最核心的一步就是调用 <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-drsr/b63730ac-614c-431c-9501-28d6aca91894?redirectedfrom=MSDN">GetNCChanges</a> 复制用户凭据。</p>
<p>这篇文章中展示了更加详细的原理：<a href="https://adsecurity.org/?p=1729">《Mimikatz DCSync Usage, Exploitation, and Detection》</a></p>
<h3 id="哪些用户拥有域复制权限">哪些用户拥有域复制权限？</h3>
<ul>
<li>Administrators</li>
<li>Domain Admins</li>
<li>Enterprise Admins</li>
<li>&hellip;</li>
</ul>
<p>使用DcSync技术攻击的前提是获取域管理员权限。</p>
<h3 id="什么是域复制权限--域扩展权限">什么是域复制权限 — 域扩展权限</h3>
<p>Windows活动目录除了支持常规权限以外，还拥有自身对扩展权限，这些扩展权限与常规权限等效，主要是为了限定某些特殊的行为而制定的。</p>
<p>常规权限：</p>
<ul>
<li>读取</li>
<li>写入</li>
<li>执行</li>
</ul>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/extended-rights">扩展权限（Extended Rights）</a>：</p>
<ol>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-allowed-to-authenticate">Allowed-To-Authenticate</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-apply-group-policy">Apply-Group-Policy</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-certificate-enrollment">Certificate-Enrollment</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-change-domain-master">Change-Domain-Master</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-change-infrastructure-master">Change-Infrastructure-Master</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes">DS-Replication-Get-Changes</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes-all">DS-Replication-Get-Changes-All</a></strong></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/extended-rights">&hellip;</a></li>
</ol>
<h3 id="ds-replication-get-changes">DS-Replication-Get-Changes</h3>
<p>从指定NC复制更改所需的扩展权限。</p>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/1100dbde69da8ab05abda6112f315ec4.png" alt="2021-01-31-22-29-40"></p>
<p>为了方便未来扩展新的特性，每一个扩展权限都具有一个GUID值，如果要对域对象赋予这个权限，可以传入这个GUID值。GUID等效于权限常量。</p>
<p>DS-Replication-Get-Changes扩展权限支持的系统版本：</p>
<ul>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes#windows-2000-server">Windows 2000 Server</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes#windows-server-2003">Windows Server 2003</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes#adam">ADAM</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes#windows-server-2003-r2">Windows Server 2003 R2</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes#windows-server-2008">Windows Server 2008</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes#windows-server-2008-r2">Windows Server 2008 R2</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes#windows-server-2012">Windows Server 2012</a></strong></li>
</ul>
<h3 id="dcsync后门实现">DcSync后门实现</h3>
<p>通过调用活动目录自身独有的COM组件接口，可以获取域对象的安全描述符，修改方式与本地修改ACL没有太多差别。</p>
<p><a href="https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1#L8270">Powerview</a>实现了Powershell版本的DCSync后门植入：</p>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/80466ac445595447e9b11290cd4147d7.png" alt="2021-01-31-22-30-43"></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Add<span style="color:#f92672">-</span>DomainObjectAcl <span style="color:#f92672">-</span>TargetIdentity <span style="color:#e6db74">&#34;DC=Domain,DC=com&#34;</span> <span style="color:#f92672">-</span>PrincipalIdentity <span style="color:#f92672">&lt;</span>UserName<span style="color:#f92672">&gt;</span> <span style="color:#f92672">-</span>Rights DCSync <span style="color:#f92672">-</span>Verbose
</code></pre></div><p>我这里实现了一个C++版本的：<a href="https://github.com/Rvn0xsy/PDacl">https://github.com/Rvn0xsy/PDacl</a></p>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/f6516259d175c841e63575cacd95a7aa.png" alt="2021-01-31-22-33-32"></p>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/7ac3672261363352f05cff161840dab6.png" alt="2021-01-31-22-33-58"></p>
<p>在Cobalt Strike中以普通用户权限转储NTLM验证成功：</p>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/f7079ec60a5abbd69c8177725823f466.png" alt="2021-01-31-22-34-59"></p>
<p>C++实现过程：</p>
<ul>
<li>获取IADsSecurityDescriptor接口指针</li>
<li>获取IADsAccessControlList接口指针</li>
<li>获取IADsAccessControlEntry接口指针</li>
<li>调用IADsAccessControlList::AddAce添加ACE</li>
<li>调用IADs::put更新</li>
</ul>
<p>由于涉及到COM组件对象，所以过程比较繁琐。</p>
<h3 id="dcsync权限检测">DCSync权限检测</h3>
<p><a href="https://github.com/cyberark/ACLight">https://github.com/cyberark/ACLight</a> 能够列出所有用户的ACL，可以根据结果进行匹配DS-Replication-Get-Changes权限。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/iads/ne-iads-ads_rights_enum">https://docs.microsoft.com/en-us/windows/win32/api/iads/ne-iads-ads_rights_enum</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/ad/example-code-for-setting-a-control-access-right-ace">https://docs.microsoft.com/en-us/windows/win32/ad/example-code-for-setting-a-control-access-right-ace</a></li>
<li><a href="https://stealthbits.com/blog/what-is-dcsync-an-introduction/">https://stealthbits.com/blog/what-is-dcsync-an-introduction/</a></li>
<li><a href="https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1#L8270">https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1#L8270</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes">https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes</a></li>
<li><a href="https://3gstudent.github.io/3gstudent.github.io/">https://3gstudent.github.io/3gstudent.github.io/</a>域渗透-DCSync/</li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/ad/how-security-descriptors-are-set-on-new-directory-objects">https://docs.microsoft.com/en-us/windows/win32/ad/how-security-descriptors-are-set-on-new-directory-objects</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/iads/nf-iads-iadssecuritydescriptor-copysecuritydescriptor">https://docs.microsoft.com/en-us/windows/win32/api/iads/nf-iads-iadssecuritydescriptor-copysecuritydescriptor</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/_adsi/">https://docs.microsoft.com/en-us/windows/win32/api/_adsi/</a></li>
<li><a href="http://systemmanager.ru/adam-sdk.en/ad/setting_access_rights_on_an_object.htm">http://systemmanager.ru/adam-sdk.en/ad/setting_access_rights_on_an_object.htm</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/order-of-aces-in-a-dacl">https://docs.microsoft.com/en-us/windows/win32/secauthz/order-of-aces-in-a-dacl</a></li>
<li><a href="https://www.installsetupconfig.com/win32programming/accesscontrollistacl1_1.html">https://www.installsetupconfig.com/win32programming/accesscontrollistacl1_1.html</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/secbp/creating-a-dacl">https://docs.microsoft.com/en-us/windows/win32/secbp/creating-a-dacl</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/security-descriptor-string-format">https://docs.microsoft.com/en-us/windows/win32/secauthz/security-descriptor-string-format</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/iads/nf-iads-iadsaccesscontrollist-addace">https://docs.microsoft.com/en-us/windows/win32/api/iads/nf-iads-iadsaccesscontrollist-addace</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/modifying-the-acls-of-an-object-in-c--">https://docs.microsoft.com/en-us/windows/win32/secauthz/modifying-the-acls-of-an-object-in-c--</a></li>
</ul>

</div>

        </div><div id="footer" class="mb-5">
    <hr>
    <div class="container text-center">
        
            <a href="https://twitter.com/Rvn0xsy" class="fab fa-twitter fa-1x" title="Twitter"></a>
        
            <a href="mailto:rvn0xsy@gmail.com" class="fas fa-envelope fa-1x" title="E-mail"></a>
        
    </div>
    
        <div class="container text-center">
            <a href="https://payloads.online" title="- PAYLOADS.ONLINE -"><small>- PAYLOADS.ONLINE -</small></a>
        </div>
    
</div>
</body>
</html>
