<!DOCTYPE html>
<html lang=""><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>Windows权限控制相关的防御与攻击技术 « 倾旋的博客</title>
    <meta name="description" content="倾旋的博客">
    <meta name="author" content='倾旋'>

    <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&display=swap" rel="stylesheet">
   
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/FortAwesome/Font-Awesome@5.15.3/css/all.min.css">

    
    <link rel="stylesheet" href="/sass/researcher.min.css">
    
    
        <link rel="icon" type="image/ico" href="https://payloads.online/favicon.ico">
    

    
        
    
</head>

    <body>
<input type="checkbox" id="menu-toggle" class="menu-toggle">
<label tabindex="0" for="menu-toggle" class="burger"><span></span> <span></span> <span></span><div class="burger-text">Menu</div></label>
<nav class="main-nav">
    
    <ul>
    
        
        
            <li><a href="/projects/">Projects</a></li>
        
            <li><a href="/links/">Links</a></li>
        
            <li><a href="/post/">Posts</a></li>
        
            <li><a href="/index.xml">Rss</a></li>
        
            <li><a href="/tools/">Tools</a></li>
        
    
    </ul>
   
</nav>
<nav><a href="/" class="all-posts-link">‹ All Posts</a></nav><div id="content">
<div class="container">
    <h1>Windows权限控制相关的防御与攻击技术</h1>
    <p>近年来终端安全检测与响应的产品发展迅速，我们不得不意识到，安全是在一个循环中发展的，从人们意识到安全开始，大部分了解到层面都是病毒、木马，然后接着是浏览器相关的Web安全领域，最后又开始回到终端。这个议题我们通过了解Windows操作系统下的访问控制技术，站在攻防的不同角度去进行对抗，提升自身的知识储备，个人觉得这些知识适用于许多使用Windows操作系统的用户。</p>
        <div class = "toc-wrapper">
            
<div class="post-toc" id="post-toc">
<aside>
    
    
    
    <nav id="TableOfContents">
  <ul>
    <li><a href="#0x00-前言">0x00 前言</a></li>
    <li><a href="#0x01-安全描述符security-descriptorssd">0X01 安全描述符(Security Descriptors，SD)</a>
      <ul>
        <li><a href="#windows具体有哪些安全对象">Windows具体有哪些安全对象？</a></li>
      </ul>
    </li>
    <li><a href="#0x02-安全描述符的组成">0x02 安全描述符的组成</a>
      <ul>
        <li><a href="#什么是sidsecurity-identifiersid">什么是SID（Security Identifier，SID）</a></li>
        <li><a href="#相对标识符relative-identifer-rid">相对标识符(Relative Identifer, RID)</a></li>
      </ul>
    </li>
    <li><a href="#0x03-自主访问控制列表discretionary-access-control-listdacl">0x03 自主访问控制列表（Discretionary access control list，DACL）</a></li>
    <li><a href="#0x04-系统访问控制列表system-access-control-listsacl">0x04 系统访问控制列表（System access control list，SACL）</a></li>
    <li><a href="#0x05-修改访问控制列表access-control-listacl">0x05 修改访问控制列表（Access control list，ACL）</a>
      <ul>
        <li><a href="#null-dacl和空dacl">NULL DACL和空DACL</a></li>
      </ul>
    </li>
    <li><a href="#0x06-土豆potato提权的本质与进程访问控制">0x06 土豆（Potato）提权的本质与进程访问控制</a></li>
    <li><a href="#0x07-访问令牌模拟access-token-impersonation">0x07 访问令牌模拟（Access Token Impersonation）</a>
      <ul>
        <li><a href="#正常情况下什么时候需要用到令牌模拟">正常情况下什么时候需要用到令牌模拟？</a></li>
      </ul>
    </li>
    <li><a href="#0x08-进程注入process-inject">0x08 进程注入（Process Inject）</a></li>
    <li><a href="#0x09-文件的权限修改">0x09 文件的权限修改</a>
      <ul>
        <li><a href="#创建匿名共享">创建匿名共享</a></li>
      </ul>
    </li>
    <li><a href="#0x10-创造提权漏洞服务后门">0x10 创造提权漏洞——服务后门</a>
      <ul>
        <li><a href="#powershell更改服务权限">Powershell更改服务权限</a></li>
        <li><a href="#cmd修改服务权限">CMD修改服务权限</a></li>
      </ul>
    </li>
    <li><a href="#0x11-windows域下的dcsync攻击及后门实现">0x11 Windows域下的DCSync攻击及后门实现</a>
      <ul>
        <li><a href="#哪些用户拥有域复制权限">哪些用户拥有域复制权限？</a></li>
        <li><a href="#什么是域复制权限--域扩展权限">什么是域复制权限 — 域扩展权限</a></li>
        <li><a href="#ds-replication-get-changes">DS-Replication-Get-Changes</a></li>
        <li><a href="#dcsync后门实现">DcSync后门实现</a></li>
        <li><a href="#dcsync权限检测">DCSync权限检测</a></li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
    
    
</aside>
<a href="#" id="toc-toggle"></a>
</div>



        </div>
    <h2 id="0x00-前言">0x00 前言</h2>
<p>近年来终端安全检测与响应的产品发展迅速，我们不得不意识到，安全是在一个循环中发展的，从人们意识到安全开始，大部分了解到层面都是病毒、木马，然后接着是浏览器相关的Web安全领域，最后又开始回到终端。这个议题我们通过了解Windows操作系统下的访问控制技术，站在攻防的不同角度去进行对抗，提升自身的知识储备，个人觉得这些知识适用于许多使用Windows操作系统的用户。</p>
<h2 id="0x01-安全描述符security-descriptorssd">0X01 安全描述符(Security Descriptors，SD)</h2>
<p>在Windows中，每一个安全对象实体都拥有一个安全描述符，安全描述符包含了被保护对象相关联的安全信息的数据结构，它的作用主要是为了给操作系统提供判断来访对象的权限。</p>
<pre tabindex="0"><code>0:000&gt; dt nt!_security_descriptor
ntdll!_SECURITY_DESCRIPTOR
   +0x000 Revision         : UChar  # 版本
   +0x001 Sbz1             : UChar  # 大小
   +0x002 Control          : Uint2B # 一组标志，用于限定安全描述符或安全描述符的各个字段的含义
   +0x008 Owner            : Ptr64 Void # 指定对象的所有者（SID）
   +0x010 Group            : Ptr64 Void # 指定对象的主组（SID）
   +0x018 Sacl             : Ptr64 _ACL # 系统访问控制列表
   +0x020 Dacl             : Ptr64 _ACL # 自主访问控制列表
</code></pre><h3 id="windows具体有哪些安全对象">Windows具体有哪些安全对象？</h3>
<ul>
<li>进程</li>
<li>线程</li>
<li>文件</li>
<li>服务</li>
<li>计划任务</li>
<li>互斥体</li>
<li>管道</li>
<li>油槽</li>
<li>文件共享</li>
<li>访问令牌</li>
<li>注册表</li>
<li>打印机</li>
<li>作业</li>
<li>&hellip;</li>
</ul>
<p>一般情况下，大部分用户接触更多的可能就是文件了，我们就以文件开始，文件对于我们去学习访问控制是最直观的。</p>
<p>一个文件的权限描述符主要表现为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rvn0xsy/rvn0xsy.github.io/static/images/a87eb66c-4f5f-11ec-adb7-00d861bf4abb.png" alt="2021-01-31-21-43-05"></p>
<p>上图中的安全选项卡主要是表述了sethc.exe这个文件能够被哪些用户访问，并且这些用户拥有sethc.exe的哪些权限，如：读取、读取和执行、写入、完全控制等。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rvn0xsy/rvn0xsy.github.io/static/images/a8c5e5a0-4f5f-11ec-b9be-00d861bf4abb.png" alt="2021-01-31-21-44-40"></p>
<h2 id="0x02-安全描述符的组成">0x02 安全描述符的组成</h2>
<p>DACL通过一系列ACE定义了所有被允许或者禁止的安全对象的访问者，SACL描述了系统应该审核的内容，系统会根据审核项产生对应的系统日志。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rvn0xsy/rvn0xsy.github.io/static/images/a90af0be-4f5f-11ec-94bd-00d861bf4abb.png" alt="2021-01-31-21-45-22"></p>
<blockquote>
<p>权限选项卡代表了 DACL，审核选项卡代表了 SACL。</p>
</blockquote>
<h3 id="什么是sidsecurity-identifiersid">什么是SID（Security Identifier，SID）</h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rvn0xsy/rvn0xsy.github.io/static/images/a95f5988-4f5f-11ec-8610-00d861bf4abb.png" alt="2021-01-31-21-49-18"></p>
<p>每个参与权限决策的角色都拥有一个SID，这个SID为了保证角色的唯一性。</p>
<pre tabindex="0"><code>S-[修订级别]-[权值]-[标识符]
</code></pre><p>SID分为两种：</p>
<ul>
<li>内置SID</li>
<li>自动分配SID</li>
</ul>
<p>内置SID有：</p>
<ul>
<li>S-1-5-18 (LocalSystem)</li>
<li>S-1-5-19 (LocalService)</li>
<li>S-1-5-20 (NetworkService)</li>
<li>S-1-5-32-544 (Administrators)</li>
<li>S-1-5-32-545 (Users)</li>
<li>S-1-5-32-550 (PrintOperators)</li>
<li>&hellip;</li>
</ul>
<h3 id="相对标识符relative-identifer-rid">相对标识符(Relative Identifer, RID)</h3>
<pre tabindex="0"><code>S-[修订级别]-[权值]-[标识符]-[相对标识符]
</code></pre><p>例如：</p>
<ul>
<li>S-1-5-21-xxxx-xxx-500 (Administrator) 本地管理员</li>
<li>S-1-5-21-xxxx-xxx-501 (Guest) 本地来宾用户</li>
<li>S-1-5-21-xxxx-xxx-1004 (Workstaion) 本地工作站</li>
</ul>
<p>其中RID为<code>500</code>的用户代表管理员用户，账户个RID值是固定的，通常渗透中常说的RID劫持、克隆用户就是修改其他用户的RID值来实现让系统认为当前用户是管理员。</p>
<h2 id="0x03-自主访问控制列表discretionary-access-control-listdacl">0x03 自主访问控制列表（Discretionary access control list，DACL）</h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rvn0xsy/rvn0xsy.github.io/static/images/a99be9c0-4f5f-11ec-93a4-00d861bf4abb.png" alt="2021-01-31-21-51-33"></p>
<p>解读：每一个Windows进程都拥有一个线程，当程序想要访问某个安全对象时，系统会提取当前线程的访问令牌，然后将访问令牌的权限和被访问的安全对象DACL进行比较。</p>
<ul>
<li>
<p>Thread A拥有Adrew的访问令牌，当它访问对象Object的时候，系统会从DACL第一个条目开始向下比对，由于第一个ACE是Access denied，并且用户名恰巧是Adrew，因此系统会拒绝访问，返回错误代码5。</p>
</li>
<li>
<p>Thread B拥有Jane的访问令牌，当它访问对象Object的时候，系统会从DACL第一个条目开始向下比对，由于第一个ACE不是针对Jane设置的，因此会继续向下比对，当到达第二个ACE时，Jane属于Group A，满足比对条件，因此拥有Write的权限。到达第三个时，如果Jane想要的是读取，那么也会在到达第三个ACE后，获得读取的权限。</p>
</li>
</ul>
<p>这张图很清晰的描述了一个线程访问系统安全对象的过程，也能够帮我们更清楚的理解令牌窃取、假冒的原理。</p>
<blockquote>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/how-dacls-control-access-to-an-object">https://docs.microsoft.com/en-us/windows/win32/secauthz/how-dacls-control-access-to-an-object</a></p>
</blockquote>
<p>当一个线程访问安全对象时，操作系统会将访问令牌的属性与被访问对象安全描述符中的DACL进行检查，检查的条目就是访问控制条目（Access control entries，ACE），最先检查的ACE优先级越高。</p>
<h2 id="0x04-系统访问控制列表system-access-control-listsacl">0x04 系统访问控制列表（System access control list，SACL）</h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rvn0xsy/rvn0xsy.github.io/static/images/a9d46df4-4f5f-11ec-98aa-00d861bf4abb.png" alt="2021-01-31-22-00-15"></p>
<p>系统访问控制列表主要是配置审核对象的ACE，当这些ACE被允许或拒绝的时候，系统将自动产生“安全”日志。</p>
<p>图中设置了Service.log的SACL，当它的DACL被改变成功后，操作系统会自动帮助我们产生一条安全日志，我们可以提取其中的关键信息，如：</p>
<ul>
<li>时间</li>
<li>访问的进程</li>
<li>访问的线程ID</li>
<li>访问的计算机</li>
<li>访问的用户名等</li>
<li>&hellip;</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rvn0xsy/rvn0xsy.github.io/static/images/aa196238-4f5f-11ec-9987-00d861bf4abb.png" alt="2021-01-31-22-03-10"></p>
<h2 id="0x05-修改访问控制列表access-control-listacl">0x05 修改访问控制列表（Access control list，ACL）</h2>
<p>在Windows中，修改内核对象的方法只有调用API，因此，可以将安全描述符也理解为一个内核对象的属性。</p>
<p>以下是修改ACL的简要过程：</p>
<ol>
<li>使用 <strong><a href="https://docs.microsoft.com/en-us/windows/desktop/api/Aclapi/nf-aclapi-getsecurityinfo">GetSecurityInfo</a></strong> 或者 <strong><a href="https://docs.microsoft.com/en-us/windows/desktop/api/Aclapi/nf-aclapi-getnamedsecurityinfoa">GetNamedSecurityInfo</a></strong> 函数从对象的<a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/s-gly">安全描述符</a>中获取DACL。</li>
<li>对于每个新的ACE，请调用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/Aclapi/nf-aclapi-buildexplicitaccesswithnamea">BuildExplicitAccessWithName</a>函数以使用描述ACE的信息填充<a href="https://docs.microsoft.com/en-us/windows/desktop/api/AccCtrl/ns-accctrl-explicit_access_a">EXPLICIT_ACCESS</a>结构。</li>
<li>调用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/Aclapi/nf-aclapi-setentriesinacla">SetEntriesInAcl</a>，为新ACE指定现有的ACL和<a href="https://docs.microsoft.com/en-us/windows/desktop/api/AccCtrl/ns-accctrl-explicit_access_a">EXPLICIT_ACCESS</a>结构的数组。SetEntriesInAcl函数分配和初始化的ACL和的ACE。</li>
<li>调用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/Aclapi/nf-aclapi-setsecurityinfo">SetSecurityInfo</a>或<a href="https://docs.microsoft.com/en-us/windows/desktop/api/Aclapi/nf-aclapi-setnamedsecurityinfoa">SetNamedSecurityInfo</a>函数，将新的ACL附加到对象的安全描述符。</li>
</ol>
<p>下方的链接提供了一个简单的例子：</p>
<blockquote>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/creating-or-modifying-an-acl">https://docs.microsoft.com/en-us/windows/win32/secauthz/creating-or-modifying-an-acl</a></p>
</blockquote>
<h3 id="null-dacl和空dacl">NULL DACL和空DACL</h3>
<p>如果属于对象的安全描述符的自由访问控制列表（Discretionary access control list，DACL）设置为NULL，则会创建一个NULL DACL。NULL DACL授予对请求它的任何用户的完全访问权限，不对该对象执行正常的安全检查。</p>
<p>NULL的DACL与空的DACL是有区别的，空DACL是正确分配和初始化的DACL，其中不包含访问控制项（Access control entries，ACE），任何对象都不允许访问。</p>
<p>我发现两个有趣的事情：</p>
<ol>
<li>如果我将lsass.exe进程的DACL设置为NULL，我发现在系统重启后，再也启动不起来了，一直循环蓝屏。</li>
<li>如果我将lsass.exe进程的DACL设置为空，我发现即便是以Guest用户登录，也不能轻易的转储lsass.exe的内存。应该是有某些保护机制。</li>
</ol>
<h2 id="0x06-土豆potato提权的本质与进程访问控制">0x06 土豆（Potato）提权的本质与进程访问控制</h2>
<p>土豆系列的提权原理主要是诱导高权限访问低权限的系统对象，导致低权限的对象可以模拟高权限对象的访问令牌（Access Token），进而可以用访问令牌创建进程，达到代码执行。</p>
<p><a href="https://payloads.online/archivers/2020-03-21/1">《Windows特权提升漏洞-符号》</a> 提到过：访问控制模型有两个主要的组成部分，访问令牌（Access Token）和安全描述符（Security Descriptor），它们分别是访问者和被访问者拥有的东西。通过访问令牌和安全描述符的内容，Windows可以确定持有令牌的访问者能否访问持有安全描述符的对象。</p>
<ul>
<li>烂土豆(Rotten Potato)提权MS16-075</li>
</ul>
<p><a href="https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2016/ms16-075">https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2016/ms16-075</a></p>
<ul>
<li><a href="https://itm4n.github.io/cve-2020-0668-windows-service-tracing-eop/">CVE-2020-0668</a></li>
<li><a href="https://www.youtube.com/watch?v=1axTbxPz2_8">CVE-2020-0683 MSI Packages Symbolic Links Processing - Windows 10 Privilege Escalation</a></li>
<li><a href="https://github.com/nomi-sec/PoC-in-GitHub#cve-2020-8950">CVE-2020-8950</a></li>
<li><a href="https://github.com/nomi-sec/PoC-in-GitHub#cve-2020-0686">CVE-2020-0683</a></li>
<li><a href="https://github.com/nomi-sec/PoC-in-GitHub#cve-2019-1002101">CVE-2019-1002101</a></li>
<li><a href="https://github.com/nomi-sec/PoC-in-GitHub#cve-2019-0986">CVE-2019-0986</a></li>
<li><a href="https://github.com/nomi-sec/PoC-in-GitHub#cve-2018-1088">CVE-2018-1088</a></li>
<li>&hellip;.</li>
</ul>
<p>这些漏洞要么是利用巧妙的手法获取令牌、要么是用高权限移动文件，因此用户层的提权漏洞大多都需要系统“主动”起来。</p>
<h2 id="0x07-访问令牌模拟access-token-impersonation">0x07 访问令牌模拟（Access Token Impersonation）</h2>
<p>Windows 的令牌类型：</p>
<ol>
<li>主令牌（Primary Token）</li>
<li>模拟令牌（Impersonation Token）</li>
</ol>
<p>渗透中常说的令牌假冒、令牌窃取都是利用Windows的令牌模拟功能获取其他用户的令牌来创建进程。</p>
<p>这两类访问令牌只有在系统重启后才会清除，而授权令牌在用户注销后该令牌会变为模拟令牌，依旧有效。</p>
<p>因此在域渗透的过程中，我们常常发现域管理员登录了某些不安全的机器，会针对这些机器进行定向的攻击，获取机器权限后，寻找域管理员创建的进程，窃取访问令牌进而获取整个域的权限。</p>
<h3 id="正常情况下什么时候需要用到令牌模拟">正常情况下什么时候需要用到令牌模拟？</h3>
<p>例如，服务器应用程序为客户端提供某些服务，服务器需要以客户端的权限访问其他资源，这个时候就需要利用令牌模拟的功能。</p>
<p>进程令牌模拟的流程：</p>
<ol>
<li>调用OpenProcess获取进程句柄</li>
<li>调用OpenProcessToken，传入进程句柄获取访问令牌句柄</li>
<li>调用DuplicateTokenEx，设置访问令牌模拟级别并复制一个令牌句柄</li>
<li>调用CreateProcessWithToken，传入模拟令牌，创建一个新的进程达到代码执行的目的</li>
</ol>
<p>注意，要达到令牌窃取创建进程的效果需要有一些前提：</p>
<ul>
<li>当前用户必须拥有SeImpersonatePrivilege或SeAssignPrimaryTokenPrivilege特权</li>
<li>拥有目标进程的PROCESS_QUERY_INFORMATION权限</li>
<li>拥有目标进程访问令牌的<code>TOKEN_DUPLICATE | TOKEN_IMPERSONATE</code>权限</li>
</ul>
<p>Windows将每一个权限都以二进制位标示，但在C语言头文件中是以16禁止标示的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rvn0xsy/rvn0xsy.github.io/static/images/aa5f8a9c-4f5f-11ec-9212-00d861bf4abb.png" alt="2021-01-31-22-10-47"></p>
<p>两个权限的组合就是两个二进制数的与运算结果，由此可以看出Windows进程权限最大可以表示0xFFFF个，也就是2个字节，当然一般情况下用不到那么多。同时，我们也可以推断，任何可以设置权限的安全对象，想要设置全部权限<code>ALL_ACCESS</code>，可以全部用0xFFFFFFFF填充。</p>
<h2 id="0x08-进程注入process-inject">0x08 进程注入（Process Inject）</h2>
<p>进程注入是为了解决A进程想要在B进程的安全上下文中执行代码的技术手段。要完成一个进程注入需要A进程的访问令牌拥有B进程的权限。</p>
<p>进程注入的流程：</p>
<ol>
<li>调用OpenProcess获取进程句柄</li>
<li>调用WriteProcessMemory，传入进程句柄，向进程的虚拟内存空间写入Shellcode</li>
<li>调用CreateRemoteThread，传入进程句柄，创建远程线程</li>
</ol>
<p>场景：某些终端安全软件禁止用户转储lsass.exe进程内存，但我们可以先进程注入到lsass.exe，然后再转储内存。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rvn0xsy/rvn0xsy.github.io/static/images/aa9a27d8-4f5f-11ec-b281-00d861bf4abb.png" alt="2021-01-31-22-16-26"></p>
<p>小技巧：有些软件在失败后返回一些数字，其实是Windows错误代码，我们可以通过<code>net helpmsg</code>命令来查看详情。</p>
<pre tabindex="0"><code>net helpmsg &lt;错误代码&gt;
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/Rvn0xsy/rvn0xsy.github.io/static/images/aace09a4-4f5f-11ec-a006-00d861bf4abb.png" alt="2021-01-31-22-17-03"></p>
<h2 id="0x09-文件的权限修改">0x09 文件的权限修改</h2>
<p>在Windows系统中，除了用户交互的窗口以外，还可以通过icacls命令修改文件的权限。</p>
<pre tabindex="0"><code>icacls c:\windows\* /save AclFile /T
  - 将 c:\windows 及其子目录下所有文件的ACL 保存到 AclFile。

  icacls c:\windows\ /restore AclFile
  - 将还原 c:\windows 及其子目录下存在的 AclFile 内所有文件的 ACL。

  icacls file /grant Administrator:(D,WDAC)
  - 将授予用户对文件删除和写入 DAC 的管理员权限。

  icacls file /grant *S-1-1-0:(D,WDAC)
  - 将授予由 sid S-1-1-0 定义的用户对文件删除和写入 DAC 的权限。
</code></pre><p>还可以查看文件的权限，例如常见的Shift后门：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rvn0xsy/rvn0xsy.github.io/static/images/ab070f92-4f5f-11ec-a1c5-00d861bf4abb.png" alt="2021-01-31-22-17-42"></p>
<p>现如今普通用户，包括管理员、系统账户都不能随意更改这个文件了，能够看出Windows对这块有做加强。</p>
<h3 id="创建匿名共享">创建匿名共享</h3>
<p>在内网渗透中，经常会需要一个机器的共享作为中转，因此可以使用net share命令快速开启一个任意用户可读可写的共享。</p>
<pre tabindex="0"><code>net share everyone=C:\Windows /grant:everyone,full
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/Rvn0xsy/rvn0xsy.github.io/static/images/ab3ec108-4f5f-11ec-82f4-00d861bf4abb.png" alt="2021-01-31-22-18-14"></p>
<h2 id="0x10-创造提权漏洞服务后门">0x10 创造提权漏洞——服务后门</h2>
<p>前面提到可以通过API修改内核对象的ACL，那么是否可以通过代码帮助我们完成一些窗口无法做到的操作，例如：任意用户可以读写的内核对象。</p>
<p>我尝试过以下几种方案用作后门：</p>
<ol>
<li>注册表 成功</li>
<li>任务计划 失败</li>
<li>服务 成功</li>
<li>进程 失败</li>
</ol>
<p>服务是最容易被利用的，通常情况下，Guest用户是无法启动、创建服务的，通过修改某个服务的ACL，让Guest轻松创建以SYSTEM权限运行的进程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rvn0xsy/rvn0xsy.github.io/static/images/ab84c306-4f5f-11ec-ae41-00d861bf4abb.png" alt="2021-01-31-22-19-00"></p>
<p>由于Windows没有提供修改服务的窗口操作接口，所以按常规情况来看，上机查看的管理员不容易发现这类后门。</p>
<blockquote>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/services/modifying-the-dacl-for-a-service">https://docs.microsoft.com/en-us/windows/win32/services/modifying-the-dacl-for-a-service</a></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Rvn0xsy/rvn0xsy.github.io/static/images/abc10a82-4f5f-11ec-8408-00d861bf4abb.png" alt="2021-01-31-22-19-23"></p>
<h3 id="powershell更改服务权限">Powershell更改服务权限</h3>
<p><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/set-service?view=powershell-7.1">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/set-service?view=powershell-7.1</a></p>
<p>使用Powershell修改服务的权限可以使用Set-Service：</p>
<pre tabindex="0"><code>$SDDL = &#34;D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCLCSWLOCRRC;;;SU)&#34;
Set-Service -Name &#34;BITS&#34; -SecurityDescriptorSddl $SDDL
</code></pre><h3 id="cmd修改服务权限">CMD修改服务权限</h3>
<p>想象一个场景，如果随时都拥有一个服务器的权限，但是不能长时间登录某个特权账户，那么可以留置一个任意用户可以修改的系统服务，方便随时提权。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rvn0xsy/rvn0xsy.github.io/static/images/ac1169be-4f5f-11ec-98c9-00d861bf4abb.png" alt="2021-01-31-22-27-28"></p>
<pre tabindex="0"><code>sc setsd &lt;Service Name&gt; &lt;SDDL String&gt;
sc sdset defragsvc &#34;D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)&#34;
</code></pre><h2 id="0x11-windows域下的dcsync攻击及后门实现">0x11 Windows域下的DCSync攻击及后门实现</h2>
<p>DCSync是域控之间同步域数据的一个传递方式，一旦攻击者获取了具有域复制权限的特权帐户，攻击者就可以利用复制协议来模仿域控制器，诱使域控制器将域用户相关的数据发送出来。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rvn0xsy/rvn0xsy.github.io/static/images/ac48005a-4f5f-11ec-be47-00d861bf4abb.png" alt="2021-01-31-22-28-23"></p>
<p>其中最核心的一步就是调用 <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-drsr/b63730ac-614c-431c-9501-28d6aca91894?redirectedfrom=MSDN">GetNCChanges</a> 复制用户凭据。</p>
<p>这篇文章中展示了更加详细的原理：<a href="https://adsecurity.org/?p=1729">《Mimikatz DCSync Usage, Exploitation, and Detection》</a></p>
<h3 id="哪些用户拥有域复制权限">哪些用户拥有域复制权限？</h3>
<ul>
<li>Administrators</li>
<li>Domain Admins</li>
<li>Enterprise Admins</li>
<li>&hellip;</li>
</ul>
<p>使用DcSync技术攻击的前提是获取域管理员权限。</p>
<h3 id="什么是域复制权限--域扩展权限">什么是域复制权限 — 域扩展权限</h3>
<p>Windows活动目录除了支持常规权限以外，还拥有自身对扩展权限，这些扩展权限与常规权限等效，主要是为了限定某些特殊的行为而制定的。</p>
<p>常规权限：</p>
<ul>
<li>读取</li>
<li>写入</li>
<li>执行</li>
</ul>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/extended-rights">扩展权限（Extended Rights）</a>：</p>
<ol>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-allowed-to-authenticate">Allowed-To-Authenticate</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-apply-group-policy">Apply-Group-Policy</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-certificate-enrollment">Certificate-Enrollment</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-change-domain-master">Change-Domain-Master</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-change-infrastructure-master">Change-Infrastructure-Master</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes">DS-Replication-Get-Changes</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes-all">DS-Replication-Get-Changes-All</a></strong></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/extended-rights">&hellip;</a></li>
</ol>
<h3 id="ds-replication-get-changes">DS-Replication-Get-Changes</h3>
<p>从指定NC复制更改所需的扩展权限。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rvn0xsy/rvn0xsy.github.io/static/images/acb2c0c0-4f5f-11ec-be1f-00d861bf4abb.png" alt="2021-01-31-22-29-40"></p>
<p>为了方便未来扩展新的特性，每一个扩展权限都具有一个GUID值，如果要对域对象赋予这个权限，可以传入这个GUID值。GUID等效于权限常量。</p>
<p>DS-Replication-Get-Changes扩展权限支持的系统版本：</p>
<ul>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes#windows-2000-server">Windows 2000 Server</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes#windows-server-2003">Windows Server 2003</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes#adam">ADAM</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes#windows-server-2003-r2">Windows Server 2003 R2</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes#windows-server-2008">Windows Server 2008</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes#windows-server-2008-r2">Windows Server 2008 R2</a></strong></li>
<li><strong><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes#windows-server-2012">Windows Server 2012</a></strong></li>
</ul>
<h3 id="dcsync后门实现">DcSync后门实现</h3>
<p>通过调用活动目录自身独有的COM组件接口，可以获取域对象的安全描述符，修改方式与本地修改ACL没有太多差别。</p>
<p><a href="https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1#L8270">Powerview</a>实现了Powershell版本的DCSync后门植入：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rvn0xsy/rvn0xsy.github.io/static/images/acece174-4f5f-11ec-991c-00d861bf4abb.png" alt="2021-01-31-22-30-43"></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Add<span style="color:#f92672">-</span>DomainObjectAcl <span style="color:#f92672">-</span>TargetIdentity <span style="color:#e6db74">&#34;DC=Domain,DC=com&#34;</span> <span style="color:#f92672">-</span>PrincipalIdentity <span style="color:#f92672">&lt;</span>UserName<span style="color:#f92672">&gt;</span> <span style="color:#f92672">-</span>Rights DCSync <span style="color:#f92672">-</span>Verbose
</span></span></code></pre></div><p>我这里实现了一个C++版本的：<a href="https://github.com/Rvn0xsy/PDacl">https://github.com/Rvn0xsy/PDacl</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rvn0xsy/rvn0xsy.github.io/static/images/ad26d0be-4f5f-11ec-aa64-00d861bf4abb.png" alt="2021-01-31-22-33-32"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rvn0xsy/rvn0xsy.github.io/static/images/ad79864c-4f5f-11ec-90cc-00d861bf4abb.png" alt="2021-01-31-22-33-58"></p>
<p>在Cobalt Strike中以普通用户权限转储NTLM验证成功：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rvn0xsy/rvn0xsy.github.io/static/images/adbf79e0-4f5f-11ec-8d7f-00d861bf4abb.png" alt="2021-01-31-22-34-59"></p>
<p>C++实现过程：</p>
<ul>
<li>获取IADsSecurityDescriptor接口指针</li>
<li>获取IADsAccessControlList接口指针</li>
<li>获取IADsAccessControlEntry接口指针</li>
<li>调用IADsAccessControlList::AddAce添加ACE</li>
<li>调用IADs::put更新</li>
</ul>
<p>由于涉及到COM组件对象，所以过程比较繁琐。</p>
<h3 id="dcsync权限检测">DCSync权限检测</h3>
<p><a href="https://github.com/cyberark/ACLight">https://github.com/cyberark/ACLight</a> 能够列出所有用户的ACL，可以根据结果进行匹配DS-Replication-Get-Changes权限。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/iads/ne-iads-ads_rights_enum">https://docs.microsoft.com/en-us/windows/win32/api/iads/ne-iads-ads_rights_enum</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/ad/example-code-for-setting-a-control-access-right-ace">https://docs.microsoft.com/en-us/windows/win32/ad/example-code-for-setting-a-control-access-right-ace</a></li>
<li><a href="https://stealthbits.com/blog/what-is-dcsync-an-introduction/">https://stealthbits.com/blog/what-is-dcsync-an-introduction/</a></li>
<li><a href="https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1#L8270">https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1#L8270</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes">https://docs.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes</a></li>
<li><a href="https://3gstudent.github.io/3gstudent.github.io/">https://3gstudent.github.io/3gstudent.github.io/</a>域渗透-DCSync/</li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/ad/how-security-descriptors-are-set-on-new-directory-objects">https://docs.microsoft.com/en-us/windows/win32/ad/how-security-descriptors-are-set-on-new-directory-objects</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/iads/nf-iads-iadssecuritydescriptor-copysecuritydescriptor">https://docs.microsoft.com/en-us/windows/win32/api/iads/nf-iads-iadssecuritydescriptor-copysecuritydescriptor</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/_adsi/">https://docs.microsoft.com/en-us/windows/win32/api/_adsi/</a></li>
<li><a href="http://systemmanager.ru/adam-sdk.en/ad/setting_access_rights_on_an_object.htm">http://systemmanager.ru/adam-sdk.en/ad/setting_access_rights_on_an_object.htm</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/order-of-aces-in-a-dacl">https://docs.microsoft.com/en-us/windows/win32/secauthz/order-of-aces-in-a-dacl</a></li>
<li><a href="https://www.installsetupconfig.com/win32programming/accesscontrollistacl1_1.html">https://www.installsetupconfig.com/win32programming/accesscontrollistacl1_1.html</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/secbp/creating-a-dacl">https://docs.microsoft.com/en-us/windows/win32/secbp/creating-a-dacl</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/security-descriptor-string-format">https://docs.microsoft.com/en-us/windows/win32/secauthz/security-descriptor-string-format</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/iads/nf-iads-iadsaccesscontrollist-addace">https://docs.microsoft.com/en-us/windows/win32/api/iads/nf-iads-iadsaccesscontrollist-addace</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/modifying-the-acls-of-an-object-in-c--">https://docs.microsoft.com/en-us/windows/win32/secauthz/modifying-the-acls-of-an-object-in-c--</a></li>
</ul>

</div>
<div class="container">
    <section class="bio" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
    <div class="bio__blurb">
        <h2 class="site-h2">网络安全爱好者、安全工具开发者</h2>
        <p>现阶段在进行红队相关的工作，我的博客会记录一些我的学习过程和部分安全技术研究成果。</p>
    </div>
<div class="bio__avatar">
    <img src="/avatar.jpeg" alt="Duncan McDougall and heir apparent">
</div></section>
</div>

        </div>
<footer class="site-footer">
    <div class="container">
        <div class="site-footer__col">
        <h5>Get in touch</h5>
        <p>
            If you like my project or have some questions,feel free
            to contact me</a>.
        </p>
        </div>
        <div class="site-footer__col site-footer__col--links">
        <h5>Me Elsewhere</h5>
        <ul>
        
                <li>
                    <a href="https://twitter.com/Rvn0xsy"><i class="fab fa-twitter"></i> Twitter</a>
                    
                </li>
        
                <li>
                    <a href="mailto:rvn0xsy@gmail.com"><i class="fas fa-envelope"></i> E-mail</a>
                    
                </li>
        
                <li>
                    <a href="https://github.com/Rvn0xsy"><i class="fab fa-github"></i> Github</a>
                    
                </li>
        
        </ul>
        </div>
        <div class="site-footer__col site-footer__col--links">
        <h5>Meta Links</h5>
        <ul>
            
                
                
                    <li class="">
                        <a href="/projects/"><i class="fas fa-code"></i> Projects</a>
                    </li>
                
                    <li class="">
                        <a href="/links/"><i class="fas fa-link"></i> Links</a>
                    </li>
                
                    <li class="">
                        <a href="/post/"><i class="fa fa-file-alt"></i> Posts</a>
                    </li>
                
                    <li class="">
                        <a href="/index.xml"><i class="fa fa-rss-square"></i> Rss</a>
                    </li>
                
                    <li class="">
                        <a href="/tools/"><i class="fas fa-tools"></i> Tools</a>
                    </li>
                
            
        </ul>
        </div>
        <p class="site-footer__copyright">
        © 倾旋 2021. All rights reserved.
        </p>
    </div>
    </footer>



<script src="https://cdn.jsdelivr.net/gh/jmnote/plantuml-encoder@1.2.4/dist/plantuml-encoder.min.js" integrity="sha256-Qsk2KRBCN5qVZX7B+8+2IvQl1Aqc723qV1tBCQaVoqo=" crossorigin="anonymous"></script>
<script>
(function(){
  let plantumlPrefix = "language-plantuml";
  Array.prototype.forEach.call(document.querySelectorAll("[class^=" + plantumlPrefix + "]"), function(code){
    let image = document.createElement("IMG");
    image.loading = 'lazy'; 
    image.src = 'http://www.plantuml.com/plantuml/svg/~1' + plantumlEncoder.encode(code.innerText);
    code.parentNode.insertBefore(image, code);
    code.style.display = 'none';
  });
})();
</script>

</body>
</html>
