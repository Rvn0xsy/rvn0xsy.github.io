<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=zh-cn dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Linux透明代理在红队渗透中的应用 - 倾旋的博客</title><meta name=theme-color><meta name=description content="0x00 前言
决定写这篇文章是我解决了所有问题以后决定记录一下这个过程所写的，因此可能会忽略很多细节上的东西。

问题一：打点的时候经常会被WAF封禁IP怎么办？
问题二：内网的时候只想代理部分目的地址怎么办？

我想大部分人解决问题一的方案就是不断切换出口IP，使得出口地址一直改变，避免被封，而解决问题二的方案可能就是Proxifier或者Proxycap。

Proxifier是一款能够实现系统全局代理的软件，它支持的代理类型有：Http、Https、Socks4a、Socks5.
在使用Windows渗透的过程中，我经常使用Proxifier来实现进程单位的代理进行内网渗透，利用好rules就能避免系统全局流量被导入代理，流量流入内网从而暴露自己的一些信息。
以上两个问题在Windows下不是问题，我之前经常使用Kali Linux来进行渗透，自从更新版本以后，它设置系统代理需要自己写PAC文件，这一点增加了一点点学习门槛，并且好像不是那么好用。最近我使用Arch Linux已经有段时间了，并且把它安装在了我的工作机、家庭电脑上，我非常喜欢这个操作系统和这个操作系统的生态。
因此我不得不开始完全适应更多在Linux上渗透的场景，这也让我收获颇多，这篇文章就记录一下我如何学习自己搭建透明代理实现愉快的工作环境。
0x01 透明代理
什么是透明代理？

透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改变你的request fields（报文），并会传送真实IP，多用于路由器的NAT转发中。
为什么要用到透明代理？
因为这样能够让我的机器“身处”在内网中，也能让我的机器在“世界上的任何角落里”。
大家都知道，在Linux下常规的内网渗透需要使用一些如：proxychains的工具实现指定的进程访问内网的资源，相当于给程序套了一层代理。
它的实现原理如下：

ProxyChains is a UNIX program, that hooks network-related libc functions in dynamically linked programs via a preloaded DLL and redirects the connections through SOCKS4a/5 or HTTP proxies.
关于LD_PRELOAD之前有写过相关文章：Linux权限维持之LD_PRELOAD
它的缺点却是每个命令必须要在前面加上proxychains，这样Bash shell有时候可能不会正常工作给我们进行参数提示。
我要做的就是使用iptables实现透明代理，让我的机器所有与目标地址相关的流量都导入socks5代理端口。
题外话一，关闭proxychains的输出信息可以将/etc/proxychains.conf文件中的quiet_mode前面的#去除。

题外话二，设置metasploit全局代理的方法：

可以将metasploit全局变量proxies的值进行设置来使得后续所有的流量都经过代理发出，这样能够达到内网穿透的效果。

图中演示了2层代理的设置
0x02 Linux下的iptables防火墙
iptables是一个用户空间实用程序，它允许系统管理员配置Linux内核防火墙的IP数据包过滤器规则，这些规则实现为不同的Netfilter模块。筛选器组织在不同的表中，这些表包含有关如何处理网络流量数据包的规则链。当前，不同的内核模块和程序用于不同的协议。iptables适用于IPv4，ip6tables适用于IPv6，arptables适用于ARP，而ebtables适用于以太网帧。
学习iptables有一点门槛，需要对表、规则链、动作等关系有一定的了解，这里不继续铺垫，可以自行搜索关于iptables的文章。
流量导入Socks代理
通过将规则插入到NAT表的PREROUTING链中，可以轻松地重定向传入流量。
例如：
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 8080

所有访问eth0网卡80端口的流量，都会被重定向到8080端口。"><meta name=author content="倾旋的博客"><link rel="preload stylesheet" as=style href=https://payloads.online/main.min.css><link rel=preload as=image href=https://payloads.online/theme.png><link rel=preload as=image href=/avatar.jpeg><script defer src=https://payloads.online/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://payloads.online/favicon.ico><link rel=apple-touch-icon href=https://payloads.online/apple-touch-icon.png><meta name=generator content="Hugo 0.148.2"><meta itemprop=name content="Linux透明代理在红队渗透中的应用"><meta itemprop=description content="本篇文章，主要是记录工作中想让外网打点和内网渗透的场景进行透明代理的体验。"><meta itemprop=datePublished content="2020-11-13T00:00:00+00:00"><meta itemprop=dateModified content="2020-11-13T00:00:00+00:00"><meta itemprop=wordCount content="1049"><meta property="og:url" content="https://payloads.online/archivers/2020-11-13/1/"><meta property="og:site_name" content="倾旋的博客"><meta property="og:title" content="Linux透明代理在红队渗透中的应用"><meta property="og:description" content="本篇文章，主要是记录工作中想让外网打点和内网渗透的场景进行透明代理的体验。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-11-13T00:00:00+00:00"><meta property="article:modified_time" content="2020-11-13T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux透明代理在红队渗透中的应用"><meta name=twitter:description content="本篇文章，主要是记录工作中想让外网打点和内网渗透的场景进行透明代理的体验。"><link rel=canonical href=https://payloads.online/archivers/2020-11-13/1/></head><body class="bg-(--bg) text-black antialiased duration-200 ease-out [-webkit-tap-highlight-color:transparent] dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-(--w) px-8 whitespace-nowrap lg:justify-center"><div class="relative z-50 flex items-center ltr:mr-auto rtl:ml-auto"><a class="-translate-y-[1px] text-2xl font-medium" href=https://payloads.online/>倾旋的博客</a><div class="btn-dark text-[0px] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden ltr:-mr-8 rtl:-ml-8" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full flex-col justify-center bg-(--bg) pb-16 duration-200 select-none lg:static lg:h-auto lg:flex-row lg:bg-transparent! lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-10 rtl:space-x-reverse"><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/>首页</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/posts/>文章列表</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/tags>标签</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/projects>开源项目</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/about>关于我</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/links/>友情链接</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/message>留言</a><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/sponsor>赞助</a></nav></div></header><main class="prose prose-neutral dark:prose-invert relative mx-auto min-h-[calc(100vh-9rem)] max-w-(--w) px-8 pt-14 pb-16"><article><header class=mb-14><h1 class="my-0! pb-2.5">Linux透明代理在红队渗透中的应用</h1><div class="text-xs antialiased opacity-60"><time>Nov 13, 2020</time><span class=mx-1>&#183;</span>
<span>倾旋</span></div></header><section><h2 id=0x00-前言>0x00 前言</h2><p>决定写这篇文章是我解决了所有问题以后决定记录一下这个过程所写的，因此可能会忽略很多细节上的东西。</p><ul><li>问题一：打点的时候经常会被WAF封禁IP怎么办？</li><li>问题二：内网的时候只想代理部分目的地址怎么办？</li></ul><p>我想大部分人解决问题一的方案就是不断切换出口IP，使得出口地址一直改变，避免被封，而解决问题二的方案可能就是<a href=https://www.proxifier.com/download/>Proxifier</a>或者<a href=https://www.proxycap.com/>Proxycap</a>。</p><blockquote><p>Proxifier是一款能够实现系统全局代理的软件，它支持的代理类型有：Http、Https、Socks4a、Socks5.</p></blockquote><p>在使用Windows渗透的过程中，我经常使用Proxifier来实现进程单位的代理进行内网渗透，利用好rules就能避免系统全局流量被导入代理，流量流入内网从而暴露自己的一些信息。</p><p>以上两个问题在Windows下不是问题，我之前经常使用<a href=https://www.kali.org/>Kali Linux</a>来进行渗透，自从更新版本以后，它设置系统代理需要自己写PAC文件，这一点增加了一点点学习门槛，并且好像不是那么好用。最近我使用<a href=https://www.archlinux.org/>Arch Linux</a>已经有段时间了，并且把它安装在了我的工作机、家庭电脑上，我非常喜欢这个操作系统和这个操作系统的生态。</p><p>因此我不得不开始完全适应更多在Linux上渗透的场景，这也让我收获颇多，这篇文章就记录一下我如何学习自己搭建透明代理实现愉快的工作环境。</p><h2 id=0x01-透明代理>0x01 透明代理</h2><h3 id=什么是透明代理>什么是透明代理？</h3><p><img src=https://images.payloads.online/a5194b40-4f5f-11ec-85cb-00d861bf4abb.png alt=2020-11-13-20-03-20></p><p>透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改变你的request fields（报文），并会传送真实IP，多用于路由器的NAT转发中。</p><h3 id=为什么要用到透明代理>为什么要用到透明代理？</h3><p>因为这样能够让我的机器“身处”在内网中，也能让我的机器在“世界上的任何角落里”。</p><p>大家都知道，在Linux下常规的内网渗透需要使用一些如：<a href=https://github.com/haad/proxychains>proxychains</a>的工具实现指定的进程访问内网的资源，相当于给程序套了一层代理。</p><p>它的实现原理如下：</p><blockquote><p>ProxyChains is a UNIX program, that hooks network-related libc functions in dynamically linked programs via a preloaded DLL and redirects the connections through SOCKS4a/5 or HTTP proxies.</p></blockquote><p>关于<code>LD_PRELOAD</code>之前有写过相关文章：<a href=https://payloads.online/archivers/2020-01-01/1>Linux权限维持之LD_PRELOAD</a></p><p>它的缺点却是每个命令必须要在前面加上<code>proxychains</code>，这样<code>Bash shell</code>有时候可能不会正常工作给我们进行参数提示。</p><p>我要做的就是使用<code>iptables</code>实现透明代理，让我的机器所有与目标地址相关的流量都导入<code>socks5</code>代理端口。</p><p>题外话一，关闭<code>proxychains</code>的输出信息可以将<code>/etc/proxychains.conf</code>文件中的<code>quiet_mode</code>前面的<code>#</code>去除。</p><p><img src=https://images.payloads.online/a555ab4e-4f5f-11ec-885e-00d861bf4abb.png alt=2020-11-13-20-18-48></p><p>题外话二，设置metasploit全局代理的方法：</p><p><img src=https://images.payloads.online/a5aea60e-4f5f-11ec-89ed-00d861bf4abb.png alt=2020-11-13-22-15-29></p><p>可以将metasploit全局变量<code>proxies</code>的值进行设置来使得后续所有的流量都经过代理发出，这样能够达到内网穿透的效果。</p><blockquote><p>图中演示了2层代理的设置</p></blockquote><h2 id=0x02-linux下的iptables防火墙>0x02 Linux下的iptables防火墙</h2><p><code>iptables</code>是一个用户空间实用程序，它允许系统管理员配置Linux内核防火墙的IP数据包过滤器规则，这些规则实现为不同的<code>Netfilter</code>模块。筛选器组织在不同的表中，这些表包含有关如何处理网络流量数据包的规则链。当前，不同的内核模块和程序用于不同的协议。<code>iptables</code>适用于IPv4，<code>ip6tables</code>适用于IPv6，<code>arptables</code>适用于ARP，而<code>ebtables</code>适用于以太网帧。</p><p>学习<code>iptables</code>有一点门槛，需要对表、规则链、动作等关系有一定的了解，这里不继续铺垫，可以自行搜索关于<code>iptables</code>的文章。</p><h3 id=流量导入socks代理>流量导入Socks代理</h3><p>通过将规则插入到<code>NAT</code>表的<code>PREROUTING</code>链中，可以轻松地重定向传入流量。</p><p>例如：</p><pre tabindex=0><code>iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 8080
</code></pre><blockquote><p>所有访问eth0网卡80端口的流量，都会被重定向到8080端口。</p></blockquote><p>它不同于端口转发，<code>REDIRECT</code>的<code>--dport</code>端口并不会被<code>iptables</code>进行监听。</p><pre tabindex=0><code class=language-plantuml data-lang=plantuml>title iptables的流量在规则链中的走向图

PREROUTING -&gt; INPUT
INPUT -&gt; POSTROUTING
POSTROUTING -&gt; OUTPUT
</code></pre><h2 id=0x03-实现简单的透明代理>0x03 实现简单的透明代理</h2><p><a href=https://github.com/darkk/redsocks>redsocks</a>是一个能够重定向socks代理的一款开源软件，它允许我们在系统上监听一个端口，与远程socks端口进行转换，并且支持socks5认证，这一点非常赞。后来发现还有新的redsocks一些还在维护，但旧版已经足够满足我的需要了，就没有下载。</p><h3 id=redsocks安装>redsocks安装</h3><p>安装必备库：</p><ul><li>ArchLinux ： <code>yaourt -S --noconfirm redsocks-git</code></li><li>Debian : <code>apt install gcc libevent-dev</code></li><li>CentOS : <code>yum install libevent-devel git gcc</code></li></ul><p>编译代码：</p><pre tabindex=0><code>git clone https://github.com/darkk/redsocks
cd redsocks
make
</code></pre><ol><li><p>安装完毕后，当前目录会生成<code>redsocks</code>二进制可执行文件，把它拷贝到环境变量目录下即可，例如：<code>/usr/bin/redsocks</code></p></li><li><p>将配置文件<code>redsocks.conf</code>拷贝至<code>/etc/redsocks.conf</code></p></li></ol><h3 id=配置redsocks代理服务器>配置redsocks代理服务器</h3><p>在<code>/etc/redsocks.conf</code>第61行-62行是设置Socks5服务器IP和端口的：</p><pre tabindex=0><code>// `ip&#39; and `port&#39; are IP and tcp-port of proxy-server
// You can also use hostname instead of IP, only one (random)
// address of multihomed host will be used.
ip=***;
port=***;
</code></pre><h3 id=配置redsocks启动身份>配置redsocks启动身份</h3><pre tabindex=0><code class=language-plantuml data-lang=plantuml>title 数据回环

浏览器 -&gt; PREROUTING
PREROUTING -&gt; Redsocks
Redsocks -&gt; PREROUTING
PREROUTING -&gt; Redsocks
...
...
</code></pre><p>为了避免启用端口流量重定向后数据发生回环问题，需要用iptables根据UID进行过滤<code>redsocks</code>的出口流量。</p><p>添加<code>redsocks</code>组与<code>redsocks</code>用户：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>groupadd redsocks
</span></span><span style=display:flex><span>useradd -g redsocks redsocks
</span></span></code></pre></div><p>将<code>/etc/redsocks.conf</code>的启动用户名和用户组进行更改：</p><pre tabindex=0><code>user = redsocks;
group = redsocks;
</code></pre><p>对应的防火墙规则：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iptables -t nat -A OUTPUT -p tcp -m owner ! --uid-owner redsocks  -j REDSOCKS
</span></span></code></pre></div><blockquote><p>这么做是为了把除了redsocks用户产生的流量全部经过REDSOCKS链。</p></blockquote><h2 id=0x04-打点模式-配置代理链>0x04 打点模式-配置代理链</h2><h3 id=创建自定义规则链>创建自定义规则链</h3><pre tabindex=0><code>iptables -t nat -N REDSOCKS 
# 建立REDSOCKS链
iptables -t nat -A PREROUTING -p tcp -j REDSOCKS 
# 将所有的TCP流量经过REDSOCKS链
iptables -t nat -A REDSOCKS -d &lt;SOCKS_API_SERVER&gt; -j RETURN 
# 放行获取Socks代理的API服务器
iptables -t nat -A REDSOCKS -d 10.0.0.0/8 -j RETURN 
# 放行内网地址
iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN 
# 放行内网地址
iptables -t nat -A REDSOCKS -d 169.254.0.0/16 -j RETURN 
# 放行内网地址
iptables -t nat -A REDSOCKS -d 172.16.0.0/12 -j RETURN 
# 放行内网地址
iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN 
# 放行内网地址
iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-port 31338 
# 将所有的TCP流量在经过REDSOCKS链后，全部重定向到31338端口。
iptables -t nat -A OUTPUT -p tcp -m owner ! --uid-owner redsocks  -j REDSOCKS
# 将准备流出的流量除了redsocks产生的以外，全部经过REDSOCKS链
</code></pre><p>建立一个独立的链是为了方便的清空和新建，并且还不会污染内置链的规则。</p><blockquote><p>31338是redsocks的默认端口。</p></blockquote><h3 id=启动redsocks>启动redsocks</h3><pre tabindex=0><code>sudo /usr/bin/redsocks -c /etc/redsocks.conf
</code></pre><blockquote><p>启动redsocks后，进程的所属者会被自动更改为redsocks。</p></blockquote><p>这时访问公网查看出口IP，会变成Socks5代理服务器的出口IP，实现打点模式的透明代理。</p><h2 id=0x05-内网模式-配置代理链>0x05 内网模式-配置代理链</h2><p>内网与打点模式不同，主要是实现指定IP地址范围的代理，打点是“放哪些”，内网是“要哪些”。</p><pre tabindex=0><code>iptables -t nat -N REDSOCKS
iptables -t nat -F REDSOCKS # 清空

iptables -t nat -A PREROUTING -p tcp -j REDSOCKS
iptables -t nat -A REDSOCKS -p tcp -d 10.0.0.0/8 -j REDIRECT --to-port 31338
iptables -t nat -A REDSOCKS -p tcp -d 172.0.0.0/8 -j REDIRECT --to-port 31338
iptables -t nat -A REDSOCKS -p tcp -d 192.168.0.0/16 -j REDIRECT --to-port 31338
iptables -t nat -A OUTPUT -p tcp -m owner ! --uid-owner $redsocks_user  -j REDSOCKS
</code></pre><p>以上防火墙规则是将以下目的地址的流量全部导入redsoks：</p><ul><li>10.0.0.0/8</li><li>172.0.0.0/8</li><li>192.168.0.0/16</li></ul><p>如果要添加专网的地址，可以手动添加：</p><pre tabindex=0><code>iptables -t nat -A REDSOCKS -p tcp -d XXX.XXX.XX.XX/XX -j REDIRECT --to-port 31338
</code></pre><p>启用以上防火墙规则后，我可以不需要使用proxychains，直接可以用nmap探测端口，自定义的工具也能够像在内网一样工作，本机开的虚拟机切换到NAT模式也能够“身处”内网。</p><h2 id=0x06-自动化实现>0x06 自动化实现</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>redsocks_bin_path<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/usr/bin/redsocks&#34;</span>
</span></span><span style=display:flex><span>redsocks_config_file_path<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/etc/redsocks.conf&#34;</span>
</span></span><span style=display:flex><span>socks_api_url<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;*****&#39;</span>
</span></span><span style=display:flex><span>shell_log_path<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/tmp/socks-switch.log&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ssh port</span>
</span></span><span style=display:flex><span>ssh_port<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;22&#34;</span>
</span></span><span style=display:flex><span>redsocks_user<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;redsocks&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>socks_loging<span style=color:#f92672>(){</span>
</span></span><span style=display:flex><span>    current_time<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>date +<span style=color:#e6db74>&#34;%Y-%m-%d %H:%M:%S&#34;</span><span style=color:#66d9ef>)</span>;
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;[*] &#34;</span>$current_time <span style=color:#e6db74>&#34;: &#34;</span> $1 &gt;&gt; $shell_log_path
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;[*] &#34;</span>$current_time <span style=color:#e6db74>&#34;: &#34;</span> $1
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>change_socks<span style=color:#f92672>(){</span>
</span></span><span style=display:flex><span>    local socks_ip<span style=color:#f92672>=</span>$1;
</span></span><span style=display:flex><span>    local socks_port<span style=color:#f92672>=</span>$2;
</span></span><span style=display:flex><span>    socks_loging <span style=color:#e6db74>&#34;Change Socks: </span>$1<span style=color:#e6db74>, Port: </span>$2<span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e># 61行是Socks IP</span>
</span></span><span style=display:flex><span>    sed -i <span style=color:#e6db74>&#39;61d&#39;</span> $redsocks_config_file_path
</span></span><span style=display:flex><span>    sed -i <span style=color:#e6db74>&#34;61i\        ip=</span>$socks_ip<span style=color:#e6db74>;&#34;</span>  $redsocks_config_file_path
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 62行是Socks Port</span>
</span></span><span style=display:flex><span>    sed -i <span style=color:#e6db74>&#39;62d&#39;</span> $redsocks_config_file_path
</span></span><span style=display:flex><span>    sed -i <span style=color:#e6db74>&#34;62i\        port=</span>$socks_port<span style=color:#e6db74>;&#34;</span>  $redsocks_config_file_path
</span></span><span style=display:flex><span>    pkill redsocks
</span></span><span style=display:flex><span>    socks_loging <span style=color:#e6db74>&#34;Run redsocks....&#34;</span>
</span></span><span style=display:flex><span>    $redsocks_bin_path -c $redsocks_config_file_path
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>start_pentest<span style=color:#f92672>(){</span>
</span></span><span style=display:flex><span>    uninstall_iptables
</span></span><span style=display:flex><span>    iptables -t nat -N REDSOCKS
</span></span><span style=display:flex><span>    iptables -t nat -F REDSOCKS <span style=color:#75715e># 清空</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    iptables -t nat -A PREROUTING -p tcp -j REDSOCKS
</span></span><span style=display:flex><span>    iptables -t nat -A REDSOCKS -p tcp -d 10.0.0.0/8 -j REDIRECT --to-port <span style=color:#ae81ff>31338</span>
</span></span><span style=display:flex><span>    iptables -t nat -A REDSOCKS -p tcp -d 172.0.0.0/8 -j REDIRECT --to-port <span style=color:#ae81ff>31338</span>
</span></span><span style=display:flex><span>    iptables -t nat -A REDSOCKS -p tcp -d 192.168.0.0/16 -j REDIRECT --to-port <span style=color:#ae81ff>31338</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    unset_iptables
</span></span><span style=display:flex><span>    set_iptables
</span></span><span style=display:flex><span>    local socks_ip<span style=color:#f92672>=</span>$1;
</span></span><span style=display:flex><span>    local socks_port<span style=color:#f92672>=</span>$2;
</span></span><span style=display:flex><span>    change_socks $socks_ip $socks_port
</span></span><span style=display:flex><span>    socks_loging <span style=color:#e6db74>&#34;Change Socks: </span>$1<span style=color:#e6db74>, Port: </span>$2<span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>install_iptables<span style=color:#f92672>(){</span>
</span></span><span style=display:flex><span>    iptables -t nat -F OUTPUT
</span></span><span style=display:flex><span>    iptables -t nat -F PREROUTING
</span></span><span style=display:flex><span>    <span style=color:#75715e># 如果没有就新建一个</span>
</span></span><span style=display:flex><span>    local is_redsocks<span style=color:#f92672>=</span><span style=color:#e6db74>`</span>iptables -t nat -nL --line-number |grep REDSOCKS<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -z <span style=color:#e6db74>&#34;</span>$is_redsocks<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>            iptables -t nat -N REDSOCKS
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>    iptables -t nat -F REDSOCKS <span style=color:#75715e># 清空</span>
</span></span><span style=display:flex><span>    iptables -t nat -A PREROUTING -p tcp -j REDSOCKS
</span></span><span style=display:flex><span>    iptables -t nat -A REDSOCKS -p tcp --dport $ssh_port -j RETURN
</span></span><span style=display:flex><span>    iptables -t nat -A REDSOCKS -d &lt;SOCKS API Server&gt; -j RETURN
</span></span><span style=display:flex><span>    iptables -t nat -A REDSOCKS -d 10.0.0.0/8 -j RETURN
</span></span><span style=display:flex><span>    iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN
</span></span><span style=display:flex><span>    iptables -t nat -A REDSOCKS -d 169.254.0.0/16 -j RETURN
</span></span><span style=display:flex><span>    iptables -t nat -A REDSOCKS -d 172.16.0.0/12 -j RETURN
</span></span><span style=display:flex><span>    iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN
</span></span><span style=display:flex><span>    iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-port <span style=color:#ae81ff>31338</span>
</span></span><span style=display:flex><span>    socks_loging <span style=color:#e6db74>&#34;Install Success!&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>uninstall_iptables<span style=color:#f92672>(){</span>
</span></span><span style=display:flex><span>    iptables -t nat -F OUTPUT
</span></span><span style=display:flex><span>    iptables -t nat -F PREROUTING
</span></span><span style=display:flex><span>    socks_loging <span style=color:#e6db74>&#34;Uninstall iptables  ...&#34;</span>
</span></span><span style=display:flex><span>    is_redsocks<span style=color:#f92672>=</span><span style=color:#e6db74>`</span>iptables -t nat -nvL REDSOCKS |wc -l<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span>$is_redsocks<span style=color:#e6db74>&#34;</span>!<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>            iptables -t nat -F REDSOCKS
</span></span><span style=display:flex><span>            iptables -t nat -X REDSOCKS
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>set_iptables<span style=color:#f92672>(){</span>
</span></span><span style=display:flex><span>    iptables -t nat -A OUTPUT -p tcp -m owner ! --uid-owner $redsocks_user  -j REDSOCKS
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>unset_iptables<span style=color:#f92672>(){</span>
</span></span><span style=display:flex><span>    ids<span style=color:#f92672>=</span><span style=color:#e6db74>`</span>iptables -t nat -nL OUTPUT --line-number | grep REDSOCKS | awk <span style=color:#e6db74>&#39;{print $1}&#39;</span><span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -z <span style=color:#e6db74>&#34;</span>$ids<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        socks_loging <span style=color:#e6db74>&#34;No Set Iptables ...&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>    id_array<span style=color:#f92672>=(</span><span style=color:#e6db74>${</span>ids//<span style=color:#ae81ff>\\</span>n/ <span style=color:#e6db74>}</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    socks_loging <span style=color:#e6db74>&#34;REDSOCKS OUTPUT Chian ID : </span>$id_array<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> id in <span style=color:#e6db74>${</span>id_array[@]<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>        id<span style=color:#f92672>=</span><span style=color:#e6db74>`</span>echo $id|egrep -o <span style=color:#e6db74>&#34;[0-9]{1,4}&#34;</span><span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> $id!<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>            iptables -t nat -D OUTPUT $id
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -z <span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;[*] Usage : </span>$0<span style=color:#e6db74> &lt;start | stop | clean | install | uninstall | change IP PORT | pentest IP PORT&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        </span>$0<span style=color:#e6db74> start : 启动redsocks，自动设置iptables
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        </span>$0<span style=color:#e6db74> stop : 停止redsocks，自动清空iptables
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        </span>$0<span style=color:#e6db74> clean : 清空iptables所有规则
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        </span>$0<span style=color:#e6db74> install : 安装iptables规则
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        </span>$0<span style=color:#e6db74> uninstall : 卸载iptables规则
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        </span>$0<span style=color:#e6db74> change : 改变Socks的IP和端口
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        </span>$0<span style=color:#e6db74> pentest : 开始内网渗透，传入Socks的IP和端口
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;</span>
</span></span><span style=display:flex><span>    exit <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;install&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    install_iptables
</span></span><span style=display:flex><span>    exit <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;pentest&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    start_pentest $2 $3
</span></span><span style=display:flex><span>    exit <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>使用方式：</p><ul><li>打点模式简单使用（每执行一次，向API拉取新的代理）：</li></ul><p><img src=https://images.payloads.online/a5fc0642-4f5f-11ec-a814-00d861bf4abb.png alt=2020-11-13-22-04-21></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo ./socks-switch.sh install
</span></span><span style=display:flex><span>sudo ./socks-switch.sh start
</span></span></code></pre></div><ul><li>切换至内网模式使用：</li></ul><p><img src=https://images.payloads.online/a65575e2-4f5f-11ec-81ed-00d861bf4abb.png alt=2020-11-13-22-00-56></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo ./socks-switch.sh uninstall
</span></span><span style=display:flex><span>sudo ./socks-switch.sh pentest &lt;Socks IP&gt; &lt;Socks Port&gt;
</span></span></code></pre></div><ul><li>手动指定Socks的IP和端口（打点模式与内网模式兼容）：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo ./socks-switch.sh change &lt;Socks IP&gt; &lt;Socks Port&gt;
</span></span></code></pre></div><h2 id=0x06-树莓派实现6小时切换一次出口的wifi>0x06 树莓派实现6小时切换一次出口的WiFi</h2><p><img src=https://images.payloads.online/a6b460f2-4f5f-11ec-bc9f-00d861bf4abb.png alt=2020-11-13-21-36-29></p><p>这个是我在熟悉透明代理后产生的想法，适合“团队作战”，尤其是Web渗透这块最消耗IP了，实验室的小伙伴大多也都是笔记本，因此想出了用树莓派实现6小时切换一次出口的WiFi，当然了，也能把穿透内网的Socks变成一个WiFi :)</p><h3 id=更改redsocks监听地址>更改redsocks监听地址</h3><p>如果是多网卡需要把redsocks配置文件<code>/etc/redsocks.conf</code>的监听IP地址改为：0.0.0.0，不然在<code>wlan0</code>的流量转向<code>eth0</code>的时候，会找不到31338端口。</p><pre tabindex=0><code>local_ip = 0.0.0.0;
local_port = 31338;
</code></pre><h3 id=安装创建ap的工具>安装创建AP的工具</h3><pre tabindex=0><code>sudo apt-get install util-linux procps hostapd iproute2 iw haveged dnsmasq
sudo git clone https://github.com/oblique/create_ap
cd create_ap
sudo make install
</code></pre><p>创建WiFi：<code>/usr/bin/create_ap -w 2 wlan0 eth0 &lt;WiFi Name> &lt;WiFi Pass></code></p><blockquote><p>-w 为启用WPA2</p></blockquote><h3 id=编写ap服务脚本>编写AP服务脚本</h3><p>在 <code>/usr/lib/systemd/system/</code>创建<code>wifi.service</code></p><pre tabindex=0><code>[Unit]
Description=Create AP Service
After=network.target

[Service]
Type=simple
ExecStart=/usr/bin/create_ap -w 2 wlan0 eth0 &lt;WiFi Name&gt; &lt;WiFi Pass&gt; 
KillSignal=SIGINT
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
</code></pre><h3 id=编写计划任务脚本>编写计划任务脚本</h3><p>random-wifi.sh:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cd /home/pi/socks-switch
</span></span><span style=display:flex><span>systemctl stop wifi <span style=color:#75715e># 先停止WiFi</span>
</span></span><span style=display:flex><span>./socks-switch.sh clean <span style=color:#75715e># 清空规则</span>
</span></span><span style=display:flex><span>./socks-switch.sh install <span style=color:#75715e># 安装规则</span>
</span></span><span style=display:flex><span>./socks-switch.sh start <span style=color:#75715e># 启用规则</span>
</span></span><span style=display:flex><span>systemctl start wifi <span style=color:#75715e># 创建WiFi</span>
</span></span></code></pre></div><p><code>sudo crontab -e</code>进入root用户的计划任务编写：</p><pre tabindex=0><code>* */6 * * * /home/pi/socks-switch/random-wifi.sh # 每隔六小时重置一次，并获取新的出口代理
</code></pre><h3 id=待完善的缺点>待完善的缺点</h3><p>比如在切换新的出口时，WiFi是关闭的，现在的客户端一般都是会自动寻找下一个WiFi自动连接的，如果工具正在扫描会导致真实出口IP被发现。</p><p>思路：在切换WiFi前，将<code>wlan0</code>网卡的流量全部<code>DROP</code>，这样WiFi也不需要重启。</p><p>放两张喜爱的桌面：</p><p><img src=https://images.payloads.online/a701e3d6-4f5f-11ec-b204-00d861bf4abb.png alt=2020-11-13-21-55-15></p><h2 id=0x07-总结>0x07 总结</h2><p>通过动手实践，解决了工作痛点，让技术的价值发挥出来更能收获成就感。</p><p>期间还实现了科学上网的透明代理，但是与工作无关，网络上已经大把帖子了，收获颇多，关于渗透还需要研究更多，看问题的角度也要多变，就如上一篇<a href=https://payloads.online/archivers/2020-11-01/1>Web正向代理的思考</a>
，虽说不是一个通用技术，但是能够解决一些场景的问题，提升效率。</p></section><nav class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg leading-[1.2]! *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"><a class="ltr:pr-3 rtl:pl-3" href=https://payloads.online/archivers/2020-11-29/1/><span class="ltr:mr-1.5 rtl:ml-1.5">←</span><span>静态恶意代码逃逸（第八课）</span></a><a class="justify-end pl-3 ltr:ml-auto rtl:mr-auto" href=https://payloads.online/archivers/2020-11-01/1/><span>Web正向代理的思考</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a></nav><div class="giscus mt-24"></div><script src=https://giscus.app/client.js data-repo=Rvn0xsy/rvn0xsy.github.io data-repo-id="MDEwOlJlcG9zaXRvcnk0MDEyMzI3MTY=" data-category=General data-category-id=DIC_kwDOF-pTTM4CRDk_ data-mapping=title data-strict=1 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class="mx-auto flex h-[4.5rem] max-w-(--w) items-center px-8 text-xs tracking-wider uppercase opacity-60"><div class=mr-auto>倾旋 All rights reserved</div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️</footer></body></html>